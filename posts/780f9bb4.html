<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="true">
  <meta name="baidu-site-verification" content="true">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://blog.zxkidea.top').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"mac"},
    back2top: {"enable":true,"sidebar":true,"scrollpercent":true},
    bookmark: {"enable":true,"color":"#222","save":"auto"},
    fancybox: true,
    mediumzoom: false,
    lazyload: true,
    pangu: true,
    comments: {"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>



  <meta name="description" content="Ch5. Embedded SQL （嵌入式SQL） 1. 定义 嵌入式SQL是将SQL嵌入到某一种高级语言之中，如C&#x2F;C++,Java等 这种高级语言被称为宿主语言  2. 特性 ​	1）继承了高级语言的过程控制性">
<meta property="og:type" content="article">
<meta property="og:title" content="DatabaseNotes-Ch5,6">
<meta property="og:url" content="https://blog.zxkidea.top/posts/780f9bb4.html">
<meta property="og:site_name" content="遇见时光">
<meta property="og:description" content="Ch5. Embedded SQL （嵌入式SQL） 1. 定义 嵌入式SQL是将SQL嵌入到某一种高级语言之中，如C&#x2F;C++,Java等 这种高级语言被称为宿主语言  2. 特性 ​	1）继承了高级语言的过程控制性">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://image.zxkidea.top/1550801364139.png">
<meta property="og:image" content="https://image.zxkidea.top/1550819223540.png">
<meta property="og:image" content="https://image.zxkidea.top/1550819281705.png">
<meta property="og:image" content="https://image.zxkidea.top/1550819339152.png">
<meta property="og:image" content="https://image.zxkidea.top/blog/20200305/hIbetOLmvo1p.png?imageslim">
<meta property="og:image" content="https://image.zxkidea.top/blog/20200305/yObnKWDQl3Pw.jpg?imageslim">
<meta property="og:image" content="https://image.zxkidea.top/1550972584581.png">
<meta property="og:image" content="https://image.zxkidea.top/1550972612189.png">
<meta property="og:image" content="https://image.zxkidea.top/1550972829882.png">
<meta property="og:image" content="https://image.zxkidea.top/1550972896178.png">
<meta property="og:image" content="https://image.zxkidea.top/1550973002005.png">
<meta property="og:image" content="https://image.zxkidea.top/1550973163185.png">
<meta property="og:image" content="https://image.zxkidea.top/1550973274552.png">
<meta property="og:image" content="https://image.zxkidea.top/1550973308600.png">
<meta property="og:image" content="https://image.zxkidea.top/1550973358353.png">
<meta property="og:image" content="https://image.zxkidea.top/1550973397877.png">
<meta property="og:image" content="https://image.zxkidea.top/1550973473571.png">
<meta property="og:image" content="https://image.zxkidea.top/1550973533008.png">
<meta property="og:image" content="https://image.zxkidea.top/1551058200955.png">
<meta property="og:image" content="https://image.zxkidea.top/1551058364790.png">
<meta property="og:image" content="https://image.zxkidea.top/1551150366580.png">
<meta property="og:image" content="https://image.zxkidea.top/1551253082653.png">
<meta property="og:image" content="https://image.zxkidea.top/blog/20200304/FnyH4i7YiPew.gif">
<meta property="og:image" content="https://image.zxkidea.top/1551266870484.png">
<meta property="og:image" content="https://image.zxkidea.top/blog/20200304/KywgHGFgPUdl.gif">
<meta property="og:image" content="https://image.zxkidea.top/1551857237283.png">
<meta property="article:published_time" content="2020-03-05T15:30:17.000Z">
<meta property="article:modified_time" content="2021-05-09T08:26:16.132Z">
<meta property="article:author" content="Rocky Zhou">
<meta property="article:tag" content="数据库">
<meta property="article:tag" content="笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://image.zxkidea.top/1550801364139.png">

<link rel="canonical" href="https://blog.zxkidea.top/posts/780f9bb4.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>DatabaseNotes-Ch5,6 | 遇见时光</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="遇见时光" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">

<!-- 动态线条 -->
<script type="text/javascript" src="https://cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.min.js"></script>

<!-- 页面点击烟花 -->
<canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
<script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
<script type="text/javascript" src="/js/fireworks.js"></script>

<!-- 不蒜子 -->
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">遇见时光</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <h1 class="site-subtitle" itemprop="description">Keep Looking , Don't Settle <br> Stay Hungry , Stay Foolish</h1>
      
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/Joyrocky" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.zxkidea.top/posts/780f9bb4.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cat.jpg">
      <meta itemprop="name" content="Rocky Zhou">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="遇见时光">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          DatabaseNotes-Ch5,6
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-05 23:30:17" itemprop="dateCreated datePublished" datetime="2020-03-05T23:30:17+08:00">2020-03-05</time>
            </span>

          <span class="post-meta-divider">|</span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-09 16:26:16" itemprop="dateModified" datetime="2021-05-09T16:26:16+08:00">2021-05-09</time>
              </span>

          <span class="post-meta-divider">|</span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">数据库基础</span>
                  </a>
                </span>
            </span>

          

          <span class="post-meta-divider">|</span>
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/posts/780f9bb4.html#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/posts/780f9bb4.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

          <span class="post-meta-divider">|</span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>24k</span>
            </span>

          <span class="post-meta-divider">|</span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>22 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="Ch5-Embedded-SQL-（嵌入式SQL）">Ch5. Embedded SQL （嵌入式SQL）</h2>
<h3 id="1-定义">1. 定义</h3>
<p><font color = blue size = 4>嵌入式SQL是将SQL嵌入到某一种高级语言之中，如C/C++,Java等 这种高级语言被称为宿主语言</font></p>
<br/>
<h3 id="2-特性">2. 特性</h3>
<p>​	<font color = blue size = 4>1）继承了高级语言的过程控制性</font></p>
<a id="more"></a>
<p>​	<font color = blue size = 4>2) 结合了SQL语言的复杂结果集操作的非过程性</font></p>
<p>​	<font color = blue size = 4>3) 为数据库操作者提供了安全可靠的操作方式：通过应用程序进行操作</font></p>
<br/>
<h3 id="3-和交互式SQL的对比">3. 和交互式SQL的对比</h3>
<p><font color = blue size = 4>1) 交互式(Interactive SQL ):</font></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Sname,Sage <span class="keyword">from</span> Students <span class="keyword">where</span> Sname = <span class="string">"张三"</span>；</span><br></pre></td></tr></table></figure>
<br/>
<p><font color = blue size = 4>2) 嵌入式(Embedded SQL, 此文宿主语言为C):</font></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec sql <span class="keyword">select</span> Sname,Sage <span class="keyword">into</span> :vSname,:vSage <span class="keyword">from</span> Students <span class="keyword">where</span> Sname =  <span class="string">"张三"</span>；</span><br></pre></td></tr></table></figure>
<blockquote>
<p><font color = green size  = 4>1. exec sql : 引导SQL语句，提供给C编译器,以便对SQl语句预编译成C编译器可识别的语句</font></p>
<p><font color = green size = 4>2. into 子句: 用于把SQL 语句的检索结果赋给高级语言的程序变量</font></p>
<p><font color = green size = 4>3. 用冒号开头: </font></p>
<ul>
<li><font color = green size = 4>表示高级语言的程序变量  :vsname  , :vsage</font></li>
<li><font color = green size = 4>冒号很重要, 用于区分是程序变量还是表的字段!!</font></li>
</ul>
</blockquote>
<br/>
<h3 id="4-宿主语言如何与数据库连接">4. 宿主语言如何与数据库连接</h3>
<p><span style="background: linear-gradient(to right, #f2994a, #f2c94c);"><font color = green size = 4>连接：</font></span></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exec sql connect to target-server as connect-name user user-name;</span><br><span class="line">or</span><br><span class="line">exec sql connect to default;</span><br></pre></td></tr></table></figure>
<p><span style="background: linear-gradient(to right, #f2994a, #f2c94c);"><font color = green size = 4>断开：</font></span></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exec sql disconnect connect-name;</span><br><span class="line">or</span><br><span class="line">exec sql disconnect current;</span><br></pre></td></tr></table></figure>
<br/>
<h3 id="5-如何将宿主语言的变量传递给SQL语句">5. 如何将宿主语言的变量传递给SQL语句</h3>
<p><span style="background: linear-gradient(to right, #f2994a, #f2c94c);"><font color = green size = 4>变量声明：</font></span></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">exec sql <span class="keyword">begin</span> <span class="keyword">declare</span> <span class="keyword">section</span>;</span><br><span class="line">     char vSname[10],specName[10]="张三"</span><br><span class="line">     int vSage;</span><br><span class="line">exec sql <span class="keyword">end</span> <span class="keyword">declare</span> <span class="keyword">section</span>;</span><br></pre></td></tr></table></figure>
<br/>
<p><span style="background: linear-gradient(to right, #f2994a, #f2c94c);"><font color = green size = 4>变量使用：</font></span></p>
<ul>
<li><font color = green size = 4>变量可传递给SQL语句的where等字句，以便SQL语言能够按照指定的要求进行检索</font></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exec sql <span class="keyword">select</span> Sname,Sage <span class="keyword">into</span> </span><br><span class="line"><span class="comment">--宿主程序的变量</span></span><br><span class="line">:vSname.:vSage <span class="keyword">from</span> Student <span class="keyword">where</span> Sname=:specName;</span><br></pre></td></tr></table></figure>
<br/>
<h3 id="6-SQL语句如何执行">6. SQL语句如何执行</h3>
<p><font color = blue size = 4>1) SQL语句在执行过程中，必须有提交和撤销语句才能确认其操作结果 </font></p>
<p><span style="background: linear-gradient(to right, #f2994a, #f2c94c);"><font color = green size = 4>提交：</font></span></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec sql <span class="keyword">commit</span> <span class="keyword">work</span></span><br></pre></td></tr></table></figure>
<p><span style="background: linear-gradient(to right, #f2994a, #f2c94c);"><font color = green size = 4>撤销：</font></span></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec sql <span class="keyword">rollback</span> <span class="keyword">work</span></span><br></pre></td></tr></table></figure>
<br/>
<h3 id="7-事务">7. 事务</h3>
<p><font color = blue size = 4>1) 定义: </font></p>
<ul>
<li><font color = green size = 4>事务是一个存取或改变数据库内容的程序的一次执行，或者说一条或多条SQL语句的一次执行被看做一个事务，一般由应用程序提出，有开始和结束，结束前需要提交或撤销</font></li>
</ul>
<br/>
<p><font color = blue size = 4>2) 事务的ACID 特性</font></p>
<ul>
<li><font color = red size = 4>原子性Atoomicity：</font>DBMS能够保证事务的一组更新操作是原子不可分的，要么全做，要么全不做</li>
<li><font color = red size = 4>一致性Consistency: </font> DBMS保证事务的操作状态是正确的</li>
<li><font color = red size = 4>隔离性Isolation:</font> DBMS保证并发的多个事务之间相互不受影响</li>
<li><font color = red size = 4>持久性Durability：</font>DBMS保证已提交事务的影响是持久的，被撤销事务的影响是可恢复的</li>
</ul>
<br/>
<h3 id="8-如何将SQL检索到的结构传递回宿主程序进行处理">8. 如何将SQL检索到的结构传递回宿主程序进行处理</h3>
<p><font color = blue size = 4>1) 单行结果处理</font></p>
<ul>
<li>
<p><font color = green size = 4>检索单行结果，可以将结果直接传到==宿主程序的变量==中</font></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">exec sql <span class="keyword">select</span> [<span class="keyword">ALL</span>|<span class="keyword">DISTINCT</span>] expression [,expression...]</span><br><span class="line">     <span class="keyword">INTO</span> host-<span class="keyword">variable</span>,[host-<span class="keyword">variable</span>,...]</span><br><span class="line">     <span class="keyword">From</span> tableref [corr_name][,tableref[corr_name]...]</span><br><span class="line">     <span class="keyword">Where</span> search_condition;</span><br></pre></td></tr></table></figure>
<p><font color = green size = 4>Eg：</font></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec sql <span class="keyword">select</span> Sname,Sage <span class="keyword">into</span> :vSname,:vSage <span class="keyword">from</span> Student <span class="keyword">where</span> Sname=:specName;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<br/>
<p><font color = blue size = 4>2) 多行结果处理</font></p>
<p><font color = red size = 4>游标(Cursor)</font></p>
<blockquote>
<p><font color = green size  = 4>1. 游标是指向某检索记录集的指针，通过这个指针的移动，每次读一行，处理一行，再读一行，直到处理完毕 ;</font></p>
<p><font color = green size  = 4>2. 读一行的操作是通过Fetch…into实现的，每一次Fetch，都是先向下移动指针，然后再读取，记录集有结束表示EOF,用来标记后面已经没有记录了 ;</font></p>
<p><font color = green size  = 4>3. 游标的使用需要先定义，再打开，接着一条一条处理，最后关闭 。</font></p>
</blockquote>
<br/>
<ul>
<li>
<p><font color = green size = 4>Cursor的定义：</font></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL <span class="keyword">DECLARE</span> cursor_name <span class="keyword">CURSOR</span> <span class="keyword">FOR</span></span><br><span class="line">     Subquery</span><br><span class="line">     [<span class="keyword">ORDER</span>　<span class="keyword">BY</span> result_column [<span class="keyword">ASC</span>|<span class="keyword">DESC</span>][,result_column...]]</span><br><span class="line">     [<span class="keyword">FOR</span> [<span class="keyword">READ</span> <span class="keyword">ONLY</span> |<span class="keyword">UPDATE</span> [<span class="keyword">OF</span> columnname[,columnname....]]]]</span><br></pre></td></tr></table></figure>
<p><font color = green size = 4>Eg：</font></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">exec sql <span class="keyword">declare</span> cur_student <span class="keyword">cursor</span> <span class="keyword">for</span></span><br><span class="line">     <span class="keyword">select</span> Sno ,Sname,Sclass <span class="keyword">from</span> Student <span class="keyword">where</span> Sclass=:vClass</span><br><span class="line">     <span class="keyword">order</span> <span class="keyword">by</span> Sno</span><br><span class="line"><span class="comment">--只读属性</span></span><br><span class="line">     <span class="keyword">for</span> <span class="keyword">read</span> <span class="keyword">only</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = green size = 4>Cursor的打开和关闭 </font></p>
<p><span style="background: linear-gradient(to right, #f2994a, #f2c94c);"><font color = green szie = 4>打开：</font></span></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec sql open cursor_name;</span><br></pre></td></tr></table></figure>
<p><span style="background: linear-gradient(to right, #f2994a, #f2c94c);"><font color = green size = 4>关闭：</font></span></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec sql close cursor_name;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = green size = 4>Cursor的数据读取（多行，并传入宿主程序变量）</font></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exec sql fetch cursor_name</span><br><span class="line">     into host-variable,[host-variable,...]</span><br></pre></td></tr></table></figure>
<p><font color = green size = 4>Eg：</font></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec sql fetch cur_student into :vSno,:vSname,:vSage;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<br/>
<h3 id="9-数据库的删除与更新">9. 数据库的删除与更新</h3>
<p><font color = blue size = 4>1) 删除</font></p>
<ul>
<li>
<p><font color = green size = 4>查找删除：</font></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec sql <span class="keyword">delete</span> <span class="keyword">from</span> tablename [corr_name] <span class="keyword">where</span> search_condition</span><br></pre></td></tr></table></figure>
<p><font color = green size = 4>Eg：</font></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec sql <span class="keyword">delete</span> <span class="keyword">from</span> customers c <span class="keyword">where</span> c.city=<span class="string">'Harbin'</span> <span class="keyword">and</span> <span class="keyword">not</span> <span class="keyword">exists</span> (<span class="keyword">select</span> * <span class="keyword">from</span> orders o <span class="keyword">where</span> o.cid=c.cid)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = green size = 4>定位删除：</font></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec sql <span class="keyword">delete</span> <span class="keyword">from</span> tablename [corr_name] <span class="keyword">where</span> <span class="keyword">current</span> <span class="keyword">of</span> cursor_name</span><br></pre></td></tr></table></figure>
<p><font color = green size = 4>Eg：</font></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 声明游标</span></span><br><span class="line">exec sql <span class="keyword">declare</span> delcust <span class="keyword">cursor</span> <span class="keyword">for</span></span><br><span class="line">     <span class="keyword">select</span> cid <span class="keyword">from</span> customers c <span class="keyword">where</span> c.city=<span class="string">'harbin'</span> <span class="keyword">and</span> <span class="keyword">not</span> <span class="keyword">exists</span>(<span class="keyword">select</span> * <span class="keyword">from</span> orders o <span class="keyword">where</span> o.cid=c.cid)</span><br><span class="line"><span class="comment">-- 更新属性</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">update</span> <span class="keyword">of</span> cid;</span><br><span class="line"><span class="comment">-- 打开游标</span></span><br><span class="line">exec sql open delcust</span><br><span class="line"><span class="comment">-- 提取变量并删除</span></span><br><span class="line">while(TRUE)&#123;</span><br><span class="line"><span class="comment">-- 循环提取游标内变量到宿主程序的变量</span></span><br><span class="line">     exec sql fetch delcust into :cust_id;</span><br><span class="line"><span class="comment">-- 删除当前行</span></span><br><span class="line">     exec sql <span class="keyword">delete</span> <span class="keyword">from</span> customers <span class="keyword">where</span> <span class="keyword">current</span> <span class="keyword">of</span> delcust;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<br/>
<p><font color = blue size = 4>2) 更新</font></p>
<ul>
<li>
<p><font color = green size = 4>查找更新：</font></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec sql <span class="keyword">update</span> tablename [corr_name] <span class="keyword">SET</span> columname= expr [,columname=expr...] <span class="keyword">where</span> search_condition</span><br></pre></td></tr></table></figure>
<p><font color = green size = 4>Eg：</font></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec sql <span class="keyword">update</span> student s <span class="keyword">set</span> sclass=<span class="string">'035102'</span> <span class="keyword">where</span> s.sclass=<span class="string">'034101‘;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = green size = 4>定位更新:</font></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec sql <span class="keyword">update</span> tablename [corr_name] <span class="keyword">SET</span> columname= expr [,columname=expr...] <span class="keyword">where</span> <span class="keyword">current</span> <span class="keyword">of</span> cursor_name</span><br></pre></td></tr></table></figure>
<p><font color = green size = 4>Eg：</font></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 声明游标</span></span><br><span class="line">exec sql <span class="keyword">declare</span> stud <span class="keyword">cursor</span> <span class="keyword">for</span></span><br><span class="line">     <span class="keyword">select</span> * <span class="keyword">from</span> student s <span class="keyword">where</span> s.class=<span class="string">'034101'</span></span><br><span class="line"><span class="comment">-- 更新属性</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">update</span> <span class="keyword">of</span> sclass;</span><br><span class="line"><span class="comment">-- 打开游标</span></span><br><span class="line">exec sql open stud</span><br><span class="line">while(TRUE)&#123;</span><br><span class="line"><span class="comment">-- 循环提取游标内变量到宿主程序的变量</span></span><br><span class="line">     exec sql fetch stud into :vSno,:vSname,:vSclass;</span><br><span class="line"><span class="comment">-- 更新当前行</span></span><br><span class="line">     exec sql <span class="keyword">update</span> student  <span class="keyword">set</span> sclass=<span class="string">'035102'</span> <span class="keyword">where</span> <span class="keyword">current</span> <span class="keyword">of</span> stud;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<br/>
<h3 id="10-宿主程序如何知道SQL语句的执行状态，是否发生错误">10. 宿主程序如何知道SQL语句的执行状态，是否发生错误</h3>
<p><font color  = blue size = 4>1) 状态：</font></p>
<ul>
<li><font color = green size = 4>是指嵌入式SQL语句的执行状态，尤其指一些出错状态，有时程序需要知道这些状态并对这些状态进行处理 </font></li>
</ul>
<br/>
<p><font color = blue size = 4>2) 状态捕获及处理由三部分构成:</font></p>
<ul>
<li>
<p><font color = green size = 4>设置SQL通信区：</font></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec sql include sqlca;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其中SQLCA是一个已被声明过的具有C语言的结构形式的内存信息区，其中的成员变量用来记录SQL语句的执行状态，便于宿主程序读取与处理</p>
</blockquote>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = green size = 4>设置状态捕获语句：</font></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec sql whenever condition action;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>
<p>可设置多次</p>
</li>
<li>
<p>该语句会对所有由exec sql语句所引起的对数据库系统的调用自动检查它是否满足条件</p>
</li>
<li>
<p>condition包括 sqlerror；not found；sqlwarning ; action包括continue;goto;stop;do|call</p>
</li>
<li>
<p>状态捕获语句Whenever的作用范围是其后的所有exec sql 语句，直到程序中出现另一条相同条件的whenever为止</p>
</li>
</ol>
</blockquote>
<br/>
</li>
<li>
<p><font color = green size = 4>状态处理语句：</font></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">report_error:exec sql <span class="keyword">rollback</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>某一段程序以应对SQL操作的某种状态</p>
</blockquote>
</li>
</ul>
<br/>
<h3 id="11-动态SQL-依据条件动态构造SQL语句，但欲访问的表名和字段对编程者是已知的">11. 动态SQL,依据条件动态构造SQL语句，但欲访问的表名和字段对编程者是已知的</h3>
<p><font color = blue size = 4>1) 静态SQL:</font></p>
<ul>
<li>
<p><font color = green size = 4>SQL语句在程序中已经按要求写好，只需要把一些参数通过变量传送给嵌入式SQL语句即可 </font></p>
</li>
<li>
<p><font color = green size = 4>示例：</font></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SpecName='张三';</span><br><span class="line">exec sql <span class="keyword">select</span> Sno,Sname,Sclass <span class="keyword">into</span> :vSno,:vSname,:vSclass <span class="keyword">from</span> Student <span class="keyword">where</span> Sname=:SpecName;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<br/>
<p><font color = blue size = 4>2) 动态SQL:</font></p>
<ul>
<li>
<p><font color = green size = 4>SQL语言可以在程序中动态构造，形成一个字符串，然后再交给DBMS执行，交给DBMS执行时仍然可以传递变量</font></p>
</li>
<li>
<p><font color = green size = 4>示例：</font></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">--设置SQL通信区</span></span><br><span class="line">exec sql include sqlca;</span><br><span class="line"></span><br><span class="line"><span class="comment">--变量声明</span></span><br><span class="line">exec sql <span class="keyword">begin</span> <span class="keyword">declare</span> <span class="keyword">section</span>;</span><br><span class="line">     char user_name[]="Scott"; char user_pwd[]="tiger";</span><br><span class="line">     char sqltext[]="<span class="keyword">delete</span> <span class="keyword">from</span> customers <span class="keyword">where</span> cid=\<span class="string">'c006\'</span><span class="string">";</span></span><br><span class="line"><span class="string">exec sql end declare section;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">int main()</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">--设置状态捕获语句</span></span><br><span class="line"><span class="string">     exec sql whenever sqlerror goto report_error;</span></span><br><span class="line"><span class="string">--连接数据库</span></span><br><span class="line"><span class="string">     exec sql connect :user_name identified by :user_pwd;</span></span><br><span class="line"><span class="string">--立即执行语句</span></span><br><span class="line"><span class="string">     exec sql execute  immediate :sqltext;</span></span><br><span class="line"><span class="string">--提交事务</span></span><br><span class="line"><span class="string">     exec sql commit release: return 0;</span></span><br><span class="line"><span class="string">--状态处理语句</span></span><br><span class="line"><span class="string">     report_error:print_dberror(); </span></span><br><span class="line"><span class="string">--撤销事务    </span></span><br><span class="line"><span class="string">     exec sql rollback release :return 1;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = green size = 4>动态SQL的两种执行方式：</font></p>
<ul>
<li>
<p><font color = brown>立即执行语句(构造的字符串SQL内部没有变量参数)：</font></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec sql <span class="keyword">execute</span> <span class="keyword">immediate</span>:host-<span class="keyword">variable</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><font color = blue size = 4>运行时编译并执行</font></p>
</blockquote>
<br/>
</li>
<li>
<p><font color = brown>Prepare-Execute-Using语句（构造的字符串内部有变量参数）：</font></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exec sql <span class="keyword">prepare</span> sql_temp <span class="keyword">from</span> :host-<span class="keyword">variable</span>;</span><br><span class="line"><span class="comment">-----</span></span><br><span class="line">exec sql <span class="keyword">execute</span> sql_temp <span class="keyword">using</span> :cond-<span class="keyword">variable</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><font color = blue size = 4>1) Prepare语句先编译，编译后的SQL语句允许动态参数</font></p>
<p><font color = blue size = 4>2) Execute语句执行，用using语句将动态参数传送给编译好的Sql语句</font></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<br/>
<h3 id="12-数据字典（Data-dictionary）">12. 数据字典（Data dictionary）</h3>
<ul>
<li>
<p><font color = blue size = 4>定义：</font></p>
<ul>
<li><font color = green size = 4>是系统维护的一些表或视图的集合，存储了数据库中各类对象的定义，这些信息又称数据库的元数据–关于数据的数据</font></li>
</ul>
</li>
<li>
<p><font color = blue size = 4>内容：</font></p>
<ul>
<li><font color = green size = 4>与关系相关的信息；用户与账户信息；统计与描述性数据；物理文件组织信息；索引相关信息</font></li>
</ul>
</li>
</ul>
<br/>
<hr>
<h2 id="Ch6-Database-Design">Ch6. Database Design</h2>
<h3 id="1-E-R概念简介">1.E-R概念简介</h3>
<h4 id="font-color-blue-size-4-1-定义：-font"><font color = blue size = 4>1) 定义：</font></h4>
<p><font color = green size = 4>E-R(Entity-Relationship)模型即实体-联系模型, E-R模型可以成功描述数据库所存储的数据。</font></p>
<br/>
<h4 id="font-color-blue-size-4-2-E-R模型的基本要素-font"><font color = blue size = 4>2) E-R模型的基本要素: </font></h4>
<ul>
<li><font color = green size = 4>实体(Entity):</font>
<ul>
<li>实体是E-R模型的基本对象，是现实世界中各种事物的抽象，凡是可以相互区别，并可以被识别的事、物概念等均可认为是实体。</li>
</ul>
</li>
<li><font color = green size = 4>属性(Attribute):</font>
<ul>
<li>每个实体都具有各种特征，称其为实体的属性，如学生有学号，姓名，年龄等属性。实体的属性值是数据库存储的主要数据</li>
<li>可设置主键(primary key)和其他候选键(candidate key)等</li>
</ul>
</li>
<li><font color = green size = 4>联系(Relationship):</font>
<ul>
<li>实体间会存在各种关系，如人与人之间可能存在领导与雇员关系等，实体间的关系被抽象为联系。</li>
</ul>
</li>
<li><font color = green size = 4>图例: </font></li>
</ul>
<p><img data-src="https://image.zxkidea.top/1550801364139.png" alt="zxk"></p>
<br/>
<h4 id="font-color-blue-size-4-3-E-R图像关系模型的转换：-font"><font color = blue size = 4>3) E-R图像关系模型的转换：</font></h4>
<ul>
<li>
<p><font color = green size = 4>一个1：1联系可以转换成一个独立的关系模式，也可以与任意一端对应的关系模式合并。</font></p>
<p><img data-src="https://image.zxkidea.top/1550819223540.png" alt="zxk"></p>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = green size = 4>一个1：n联系可以转换为一个独立的关系模式，也可以与n端对应的关系模式合并。</font></p>
<p><img data-src="https://image.zxkidea.top/1550819281705.png" alt="zxk"></p>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = green size = 4>一个m：n联系转换为一个关系模式</font></p>
<p><img data-src="https://image.zxkidea.top/1550819339152.png" alt="zxk"></p>
</li>
</ul>
<br/>
<ul>
<li><font color = green size = 4>三个或三个以上实体间的一个多元联系可以转换为一个关系模式。</font></li>
<li><font color = green size = 4>具有相同码的关系可以合并。</font></li>
</ul>
<br/>
<h4 id="font-color-blue-4）关联基数-font"><font color = blue >4）关联基数</font></h4>
<p><img data-src="https://image.zxkidea.top/blog/20200305/hIbetOLmvo1p.png?imageslim" alt="zxk"></p>
<br/>
<blockquote>
<p><font color = red size = 4>基数表示的含义：</font></p>
<p><font color = green>1. Purchase Order右边的(1, 1)表示一个Purchase Order有且必须有一个Party </font></p>
<p><font color = green>2. Party左边的(0, n)表示一个Party可以拥有多个Purchase Order，也可以没有</font></p>
<p><font color = green>3. Purchase Order左边的(1, n)表示Purchase Order必须有一个或多个Order Line</font></p>
<p><font color = green>4. Order Line右边的(1, 1)表示每个Order Lien必须属于一个Purchase Order</font></p>
<p><font color = green>5. Order Line下面的(1, 1)和菱形符号一起表示每个Order Line要么是一个Product要么是一个Service </font></p>
<p><font color = green>6. Product和Service上面的(0, n)表示Product和Service可以属于0个或多个Order Line</font></p>
</blockquote>
<blockquote>
<p><font color = red>注意：</font></p>
<p><font color = blue>(E, R) = (x, y)中x只能为0或1；y只能为1或n</font></p>
</blockquote>
<br/>
<h4 id="font-color-red-size-4-5-用例-将下面的E-R图转换为关系模式，关系的码用下划线标出-：-font"><font color = red size = 4>5) 用例 (将下面的E-R图转换为关系模式，关系的码用下划线标出)：</font></h4>
<ul>
<li><font  color = green size = 4>用例1</font></li>
</ul>
<blockquote>
<ol>
<li>
<p>部门（部门号，部门名，经理的职工号，…）；此为部门实体对应的关系模式，该关系模式已包含了联系&quot;领导&quot;所对应的关系模式。经理的职工号是关系的候选码。</p>
</li>
<li>
<p>职工（职工号，部门号，职工名，职务，…）；此为职工实体对应的关系模式，该关系模式已包含了联系“属于”所对应的关系模式。</p>
</li>
<li>
<p>产品（产品号，产品名，产品组长的职工号，…）；此为产品实体对应的关系模式。</p>
</li>
<li>
<p>供应商(供应商号，姓名，…）；此为供应商实体对应的关系模式 。</p>
</li>
<li>
<p>零件（零件号，零件名，…）；此为零件实体对应的关系模式。</p>
</li>
<li>
<p>生产（职工号，产品号，工作天数，…）；此为联系“生产”所对应的关系模式。</p>
</li>
<li>
<p>供应（产品号，供应商号，零件号，供应量）；此为联系“联系”所对应的关系模式。</p>
</li>
</ol>
</blockquote>
  <br/>
<p><img data-src="https://image.zxkidea.top/blog/20200305/yObnKWDQl3Pw.jpg?imageslim" alt="zxk"></p>
<br/>
<ul>
<li><font color = green size = 4>用例2</font></li>
</ul>
<blockquote>
<p><font color = blue size = 4>设有一个图书借阅管理数据库，已知：</font></p>
<ol>
<li>
<p>图书的属性有书号（具有唯一性）、书名</p>
</li>
<li>
<p>读者的属性有借书证号（具有唯一性，每个读者只能有一个借书证号）、姓名、身份证号、住址、电话</p>
</li>
<li>
<p>出版社的属性有出版社名称（具有唯一性）、地址、联系电话。</p>
</li>
</ol>
<p><font color = blue size = 4>其中：</font></p>
<ol>
<li>
<p>每本图书只能有一个出版社出版发行</p>
</li>
<li>
<p>每个读者可以同时借阅多本图书，也可以在不同时候借阅同一本图书</p>
</li>
<li>
<p>系统需要记录每本图书被借阅的借阅日期和归还日期</p>
</li>
</ol>
</blockquote>
  <br/>
<p><font color = red size = 4>请用E-R模型表示该数据库系统的概念模型，并将其转换成等价的关系模式。</font></p>
<table>
<thead>
<tr>
<th><img data-src="https://image.zxkidea.top/1550972584581.png" alt="zxk"></th>
<th><img data-src="https://image.zxkidea.top/1550972612189.png" alt="zxk"></th>
<th><img data-src="https://image.zxkidea.top/1550972829882.png" alt="zxk"></th>
</tr>
</thead>
<tbody>
<tr>
<td><img data-src="https://image.zxkidea.top/1550972896178.png" alt="zxk"></td>
<td><img data-src="https://image.zxkidea.top/1550973002005.png" alt="zxk"></td>
<td><img data-src="https://image.zxkidea.top/1550973163185.png" alt="zxk"></td>
</tr>
<tr>
<td><img data-src="https://image.zxkidea.top/1550973274552.png" alt="zxk"></td>
<td><img data-src="https://image.zxkidea.top/1550973308600.png" alt="zxk"></td>
<td><img data-src="https://image.zxkidea.top/1550973358353.png" alt="zxk"></td>
</tr>
<tr>
<td><img data-src="https://image.zxkidea.top/1550973397877.png" alt="zxk"></td>
<td><img data-src="https://image.zxkidea.top/1550973473571.png" alt="zxk"></td>
<td><img data-src="https://image.zxkidea.top/1550973533008.png" alt="zxk"></td>
</tr>
</tbody>
</table>
<br/>
<h3 id="2-函数依赖-FD">2.函数依赖(FD)</h3>
<h4 id="font-color-blue-size-4-1）-定义-font"><font color = blue size = 4>1） 定义: </font></h4>
<ul>
<li><font color = green size = 4>函数依赖是数据依赖的一种，它反映属性或属性组之间相依存，互相制约的关系，即反映现实世界的约束关系。</font></li>
<li><font color = green size = 4>设R（U）是属性U上的一个关系模式，X和Y均为U={A1，A2，…，An}的子集，r为R的任一关系，如果对于r中的任意两个元组u，v，只要有u[X]=v[X]，就有u[Y]=v[Y]，则称X函数决定Y，或称Y函数依赖于X，记为X→Y。</font></li>
</ul>
<br/>
<blockquote>
<p>示例：</p>
<p>(sno-学生ID，tno-教师ID，cno-课程ID，sname-学生姓名，tname-教师姓名，cname-课程名称，grade-成绩）</p>
<ol>
<li>
<p>sno→sname, cno→cname, (sno, cno)→grade $\surd$</p>
</li>
<li>
<p>sname→sno, tno→cno, sno→tname × （不存在一一对应关系）</p>
</li>
</ol>
</blockquote>
<br/>
<p><img data-src="https://image.zxkidea.top/1551058200955.png" alt="zxk"></p>
<p><img data-src="https://image.zxkidea.top/1551058364790.png" alt="zxk"></p>
<br/>
<h4 id="font-color-blue-size-4-2）完全函数依赖和部分函数依赖-font"><font color = blue size = 4>2）完全函数依赖和部分函数依赖</font></h4>
<ul>
<li><font color = green size = 4>在完全函数依赖：R(U)中，如果X→Y，并且对于X的任何真子集X’ , 都有X’$\nrightarrow$ Y，则称Y完全依赖于X，记作X→Y；</font></li>
<li><font color = green size = 4>在部分函数依赖：如果X→Y，且X中存在一个真子集X’ ，使得X’→Y成立，则称Y部分依赖于X。</font></li>
</ul>
<br/>
<blockquote>
<p>示例:</p>
<ul>
<li>
<p><font color = blue size = 4>学生ID，学生姓名，所修课程ID，课程名称，成绩</font></p>
<p>（学生ID，所修课程ID）→成绩</p>
<p>成绩既不能单独依赖于学生ID，也不能单独依赖于所修课程ID，因此成绩完全函数依赖于关键字。</p>
<p><font color = red size = 4>(学生ID不能唯一决定成绩，所选修课程ID也不能唯一决定成绩，需要(学生ID,所选修课程ID)一起才能唯一决定一个成绩)。</font></p>
</li>
<li>
<p><font color = blue size = 4>（学生ID，所修课程ID）→学生姓名</font></p>
<p>学生ID→学生姓名</p>
<p>学生姓名可以依赖于关键字的一个主属性——学生ID，因此学生姓名部分函数依赖于（学生ID，所修课程ID）。</p>
</li>
</ul>
</blockquote>
<br/>
<h4 id="font-color-blue-size-4-3）平凡函数依赖和非平凡函数依赖-font"><font color = blue size = 4>3）平凡函数依赖和非平凡函数依赖</font></h4>
<ul>
<li><font color = green size = 4>非平凡 函数依赖: X $\rightarrow$ Y, 但是Y $\nsubseteq$ X,则称X $\rightarrow$  Y是非平凡的函数依赖。</font></li>
<li><font color = green size = 4>平凡函数依赖： X $\rightarrow$ Y, 但是Y $\subseteq$ X,则称X $\rightarrow$  Y是平凡的函数依赖。</font></li>
</ul>
<br/>
<h4 id="font-color-blue-size-4-4）传递函数依赖-font"><font color = blue size = 4>4）传递函数依赖</font></h4>
<ul>
<li><font color = green size = 4>设X,Y,Z是关系R中互不相同的属性集合，存在X→Y(Y$\nrightarrow$X), Y→Z，则称Z传递函数依赖于X。</font></li>
</ul>
<br/>
<h3 id="3-多值依赖">3.多值依赖</h3>
<h4 id="font-color-blue-size-4-1-定义-font"><font color = blue size = 4>1) 定义</font></h4>
<ul>
<li><font color = green size = 4>设R(U)是属性集U上的一个关系模式。X，Y，Z是U的子集,并且Z=U-X-Y。关系模式R(U)中多值依赖X→→Y成立，当且仅当对R(U)的任一关系R,给定的一对(X，Z)值有<span style="background: linear-gradient(to right, #f2994a, #f2c94c);">一组Y（依赖的属性集合）</span>的值，这组值仅仅决定于X值而与Z值无关；<span style="background: linear-gradient(to right, #74ebd5, #acb6e5);">即U=X+Y+Z，有（X,Z）→ Y，但Y仅由X唯一确定，此时记X→→Y，称多值依赖。</span></font></li>
</ul>
<br/>
<ul>
<li><font color = green size = 4>若X→→Y，而Z＝φ，则称X→→Y为平凡的多值依赖。否则称X→→Y为非平凡的多值依赖；多值依赖属4NF的定义范围，比函数依赖要复杂得多，很多书上都没有讲清楚。</font></li>
</ul>
<br/>
<ul>
<li><font color = red size = 4>说得简单点就是：</font><font color = green size = 4>在关系模式中，函数依赖不能表示属性值之间的一对多联系，这些属性之间有些虽然没有直接关系，但存在间接的关系，把没有直接联系、但有间接的联系称为多值依赖的数据依赖。例如，教师和学生之间没有直接联系，但教师和学生可通过系名，或任课把教师和学生联系起来。</font></li>
</ul>
<br/>
<blockquote>
<p>可以看出，如果把上面的一组改为一个，那么多值依赖就变成了函数依赖。当然一个值组成的组也是组，所以说，<font color = green>函数依赖是多值依赖的特殊情况。</font></p>
</blockquote>
<br/>
<h4 id="font-color-blue-size-4-2-示例：-font"><font color = blue size = 4>2) 示例：</font></h4>
<table>
<thead>
<tr>
<th style="text-align:left">课程C</th>
<th>教师T</th>
<th>参考书B</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">数学</td>
<td>邓军</td>
<td>数学分析</td>
</tr>
<tr>
<td style="text-align:left">数学</td>
<td>邓军</td>
<td>高等代数</td>
</tr>
<tr>
<td style="text-align:left">数学</td>
<td>邓军</td>
<td>微分方程</td>
</tr>
</tbody>
</table>
<br/>
<blockquote>
<p><font color = green >分析：</font></p>
<ol>
<li>
<p>表中，U = C+T+B，（C,T）确定一组B（依赖的属性集合），但是这组B其实<font color = red>与T无关，仅由C确定</font>，所以(C,T)-&gt;-&gt;B。又因为T不是空集，所以(C,T)-&gt;-&gt;B为<font color = red>非平凡多值依赖</font>。</p>
</li>
<li>
<p>要想消除多值依赖，可以分解为：(C,T), (C,B)即表1，表2</p>
</li>
</ol>
</blockquote>
<p><font color = green>表1：</font></p>
<table>
<thead>
<tr>
<th>课程C</th>
<th>教师T</th>
</tr>
</thead>
<tbody>
<tr>
<td>数学</td>
<td>邓军</td>
</tr>
</tbody>
</table>
<p><font color = green>表2：</font></p>
<table>
<thead>
<tr>
<th>课程C</th>
<th>参考书B</th>
</tr>
</thead>
<tbody>
<tr>
<td>数学</td>
<td>数学分析</td>
</tr>
<tr>
<td>数学</td>
<td>高等代数</td>
</tr>
<tr>
<td>数学</td>
<td>微分方程</td>
</tr>
</tbody>
</table>
<br/>
<blockquote>
<p><font color = green>结论：</font></p>
<ol>
<li>
<p>对于R中的每个非平凡多值依赖X-&gt;-&gt;Y（Y不属于X)，X都含有候选码，则R属于4NF。</p>
</li>
<li>
<p>对于每一个非平凡多值依赖X-&gt;-&gt;Y，X若含有候选码，也就是X-&gt;Y，所以4NF所允许的非平凡多值依赖是函数依赖。</p>
</li>
</ol>
</blockquote>
<br/>
<p><font color = red size = 4>实例解释:</font></p>
<blockquote>
<p>有这样一个关系 &lt;仓库管理员，仓库号，库存产品号&gt; ，假设一个产品只能放到一个仓库中，但是一个仓库可以有若干管理员，那么对应于一个 &lt;仓库管理员，库存产品号&gt;有一个仓库号，而实际上，<span style="background: linear-gradient(to right, #74ebd5, #acb6e5);">这个仓库号只与库存产品号有关，与管理员无关，就说这是多值依赖。</span></p>
</blockquote>
<blockquote>
<p>（C，B）上的一个值（物理，光学原理）对应一组T值（李平，王强，刘明），这组值仅仅决定于课程C上的值，也就是说对于（C，B）上的另一个值（物理，普通物理学），它对应的一组T值仍是（李平，王强，刘明），尽管这时参考书B的值已经改变了。因此T多值依赖于C，即C→→T。</p>
</blockquote>
<br/>
<h4 id="font-color-blue-size-4-3）性质：-font"><font color = blue size = 4>3）性质：</font></h4>
<ul>
<li><font color = green size = 4>多值依赖具有对称性；即若X→→Y，则X→→Z，其中Z＝U－X－Y。</font></li>
<li><font color = green size = 4>多值依赖具有传递性；即若X→→Y，Y→→Z，则X→→Z－Y。</font></li>
<li><font color = green size = 4>若X→→Y，X→→Z，则X→→YZ。</font></li>
<li><font color = green size = 4>若X→→Y，X→→Z，则X→→Y∩Z。</font></li>
<li><font color = green size = 4>若X→→Y，X→→Z，则X→→Y－Z，X→→Z－Y。</font></li>
</ul>
<br/>
<h3 id="4-函数依赖的推理规则">4.函数依赖的推理规则</h3>
<h4 id="font-color-blue-size-4-1-逻辑蕴涵-font"><font color = blue size = 4>1) 逻辑蕴涵</font></h4>
<p><font color = green size = 4>给定一个关系模式，只考虑给定的函数依赖是不够的，必须找出在该关系模式上成立的其他函数依赖。</font></p>
<p><font color = red size = 4>逻辑蕴含：设F是关系模式R（U）的函数依赖集合，由F出发，可以证明其他某些函数依赖也成立，我们称这些函数依赖被F逻辑蕴含。&quot;F蕴含X→Y&quot;意味着关系实例只要满足F就满足X→Y。</font></p>
<blockquote>
<p>例如，设F={ A→B，B→C }，则函数依赖A→C被F逻辑蕴含，记作：F |= A→C。即函数依赖集 F 逻辑蕴含函数依赖A→C。</p>
</blockquote>
<br/>
<h4 id="font-color-blue-size-4-2-F的闭包F-font"><font color = blue size = 4>2) F的闭包F^+^ </font></h4>
<p><font color = green size = 4>对于一个关系模式，如何由已知的函数依赖集合F，找出F逻辑蕴涵的所有函数依赖集合呢？这就是我们下面要讨论的问题。</font></p>
<p><font color = red size = 4>F的闭包F^+^：设F为一个函数依赖集，F的闭包是指F逻辑蕴涵的所有函数依赖集合。 F的闭包记作F^+^。</font></p>
<br/>
<p><span style="background: linear-gradient(to right, #f2994a, #f2c94c);"><font color = green size = 4>示例：</font></span></p>
<blockquote>
<p>给定关系模式R(A, B, C, G, H, I)，函数依赖集合F={A→B，A→C，CG→H，CG→I，B→H}。</p>
<p>可以证明函数依赖A→H被F逻辑蕴涵。</p>
</blockquote>
<p><span style="background: linear-gradient(to right, #f2994a, #f2c94c);"><font color = green size = 4>证明：</font></span></p>
<blockquote>
<p>设有元组s和t，满足s[A]=t[A]，根据函数依赖的定义，由已知的A→B，可以推出s[B]=t[B]。又根据函数依赖B→H，可以有 s[H]=t[H]。因此，已经证明对任意的两个元组s和t，只要有s[A]=t[A]，就有s[H]=t[H]。所以，函数依赖A→H被F逻辑蕴涵。</p>
</blockquote>
<br/>
<blockquote>
<p><font color = red size = 4><em>注意：</em></font><font color = green size = 4>当F很大时，计算的过程会很长。为了从已知的函数依赖推导出其它函数依赖，Armstrong 提出了一套推理规则，称为Armstrong 公理 ，通过反复使用这些规则，可以找出给定F的闭包F^+^。</font></p>
</blockquote>
<br/>
<h4 id="font-color-blue-size-4-3-Armstrong-公理-font"><font color = blue size = 4>3) Armstrong 公理</font></h4>
<p><font color = green size = 4>a. 定义：</font>从已知的一些，可以推导出另外一些函数依赖的推理规则称作“Armstrong 公理”。</p>
<br/>
<p><font color = green size = 4>b. 基本公理：</font></p>
<ul>
<li>
<p><font color = red size = 4>自反律：</font>如果 Y $\subseteq$ X$\subseteq$ U，则 X → Y 成立。（平凡函数依赖）</p>
<blockquote>
<p>证明：</p>
<p>设t1, t2是关系R中的任意两个元组(t1$\in$R, t2$\in$R), 且它们在属性集X上的值相等(t1[X] = t2[X])；</p>
<p>由于Y是X的子集，即X $\supseteq$ Y；</p>
<p>因此必有t1[Y] = t2[Y]。</p>
</blockquote>
<br/>
</li>
<li>
<p><font color = red size = 4>增广律：</font>如果 X → Y 在 R(U)  成立，且 Z$\subseteq$ U，则 XZ [^1]→ YZ成立</p>
<blockquote>
<p>证明：</p>
<p>设 t1$\in$R, t2$\in$R, 如果 t1[XZ] = t2[XZ], 则：<br>
t1[X] = t2[X] …………………………(1)<br>
t1[Z] = t2[Z] …………………………(2)；</p>
<p>由(1)及X→Y得： t1[Y] = t2[Y] …………(3)；</p>
<p>由(2)及(3)得：t1[YZ] = t2[YZ]。</p>
</blockquote>
</li>
</ul>
<p>[^1]: <font color = green size= 4>XZ表示X $\cup$ Z, YZ表示Y $\cup$ Z</font></p>
<br/>
<ul>
<li>
<p><font color = red size = 4>传递律：</font>如果 X → Y，Y → Z 成立，则 X → Z 成立。</p>
<blockquote>
<p>证明：</p>
<p>设 t1$\in$R, t2$\in$R, 如果 t1[X] = t2[X] ………………(1)；</p>
<p>由(1)及X→Y得：t1[Y] = t2[Y] ……………… (2)；</p>
<p>由(2)及Y→Z得：t1[Z] = t2[Z]。</p>
</blockquote>
<br/>
</li>
</ul>
<p><font color = green size = 4>c. 推理规则：</font></p>
<blockquote>
<p><font color = red size = 4>(合并)：</font>{X → Y，X → Z}，则 X → YZ</p>
<p><font  color = red size = 4>(分解)：</font>{X → Y，Z ∈ Y}，则 X → Z（或：X → YZ，那么 X → Y，X → Z）</p>
<p><font color = red size = 4>(伪传递)：</font>{X → Y , YW → Z}，则 WX → Z</p>
<p><font color = red size = 4>(复合)：</font>{X → Y，W → Z},则 XW → YZ</p>
<p><font color = red size = 4>(自积律)：</font>{X → YZ，Z → W}，则 X → YZW</p>
</blockquote>
<br/>
<h4 id="font-color-blue-size-4-4-Armstrong公理系统的有效性和完备性-font"><font color = blue size = 4>4) Armstrong公理系统的有效性和完备性</font></h4>
<ul>
<li>
<p><font color = green size = 4>Armstrong公理系统的有效性指的是：</font></p>
<p>由F出发根据Armstrong公理系统推导出来的每一个函数依赖一定在F^+^中。</p>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = green size = 4>Armstrong公理系统的完备性指的是：</font></p>
<p>对于F^+^所逻辑蕴含的每一函数依赖，必定可以由F出发根据Armstrong公理系统推导出来。</p>
</li>
</ul>
<br/>
<h4 id="font-color-blue-size-4-5-属性集的闭包-font"><font color = blue size = 4>5) 属性集的闭包</font></h4>
<blockquote>
<p>原则上讲，对于一个关系模式R(U, F)，根据已知的函数依赖F，反复使用前面的规则，可以计算函数依赖集合F的闭包F+。但是，利用推理规则求出其全部的函数依赖F+是非常困难的，而且也没有必要。因此，可以计算闭包的子集，即选择一个属性子集，判断该属性子集能函数决定哪些属性，这就是利用属性集闭包的概念。</p>
</blockquote>
<ul>
<li>
<p><font color = green size = 4>定义：</font></p>
<p>设F为属性集U上的函数依赖集，X∈U，即X为U的一个子集。在函数依赖集F下被X函数决定的所有属性为F^+^下属性集X的闭包，记作X^+^。即X^+^＝{ A| X→A } 。</p>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = green size = 4>计算属性集闭包X^+^的算法如下：</font></p>
<p>输入：X，F<br>
输出： X^+^</p>
<br/>
<p><span style="background: linear-gradient(to right, #f2994a, #f2c94c);"><font color = green size = 4>迭代算法的步骤：</font></span></p>
<blockquote>
<ol>
<li>
<p>选取X^+^的初始值为X ，即X^+^＝{X}；</p>
</li>
<li>
<p>计算X^+^， X^+^＝{X, Z} ，其中Z要满足如下条件：</p>
<p><span style="background: linear-gradient(to right, #74ebd5, #acb6e5);">Y是X^+^的真子集，且F中存在一函数依赖Y→Z。</span>实际上就是以X^+^中的属性子集作为函数依赖的决定因素，在F中搜索函数依赖集，找到函数依赖的被决定属性Z放到X^+^中。</p>
</li>
<li>
<p>判断：如果X^+^没有变化？或X^+^等于U？则X^+^就是所求的结果，算法终止。否则转②。</p>
</li>
<li>
<p>因为U是有穷的，所以上述迭代过程经过有限步骤之后就会终止。</p>
</li>
</ol>
</blockquote>
<br/>
</li>
<li>
<p><font color = red size = 4>示例：</font></p>
<p><img data-src="https://image.zxkidea.top/1551150366580.png" alt="zxk"></p>
</li>
</ul>
<br/>
<h4 id="font-color-blue-size-4-6-极小函数依赖集（最小函数依赖集）-font"><font color = blue size = 4>6) 极小函数依赖集（最小函数依赖集）</font></h4>
<ul>
<li>
<p><font color = green size = 4>定义：</font></p>
<p>如果函数依赖集F满足下列条件，则称F为最小函数依赖集或最小覆盖。</p>
<blockquote>
<ol>
<li>
<p>F中的任何一个函数依赖的右部仅含有一个属性；</p>
</li>
<li>
<p>F中不存在这样一个函数依赖X→A，使得F与F-{X→A}等价；</p>
</li>
<li>
<p>F中不存在这样一个函数依赖X→A，X有真子集Z使得F-{X→A}∪{Z→A}与F等价。</p>
</li>
</ol>
</blockquote>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = red size = 4>计算最小函数依赖集的算法:</font></p>
<blockquote>
<ol>
<li>将F中的所有依赖右边化为单一元素</li>
<li>去掉F各函数依赖左边的冗余属性<span style="background: linear-gradient(to right, #f2994a, #f2c94c);">（只检查左部不是单个属性的函数依赖）</span></li>
<li>去掉F中所有冗余依赖关系<span style="background: linear-gradient(to right, #74ebd5, #acb6e5);">（逐个求，在去掉某个函数依赖的F中求该函数依赖左边的闭包，如果闭包能包含右边属性，则表示这个函数依赖要去掉）</span></li>
</ol>
</blockquote>
<br/>
</li>
<li>
<p><font color = red size = 4>举例：</font></p>
<blockquote>
<p>已知关系模式R&lt;U, F&gt;，U={A, B, C, D, E, G}，F={AB→C, D→EG, C→A, BE→C, BC→D, CG→BD, ACD→B, CE→AG}，求F的最小函数依赖集。</p>
</blockquote>
<br/>
<p><font color = brown size = 4>求解步骤：</font></p>
<p><font color = green size = 4>1. 将F中的所有依赖右边化为单一元素</font></p>
<p><font color = red size = 4>F = {AB→C, D→E, D→G, C→A, BE→C, BC→D, CG→B, CG→D, ACD→B, CE→A, CE→G}</font></p>
<br/>
<p><font color = green size = 4>2. 去掉F各函数依赖左边的冗余属性(只检查左部不是单个属性的函数依赖)</font></p>
<p><font color = blue size = 4>AB→C:</font></p>
<blockquote>
<ol>
<li>去掉A, B^+^ = B, 不包含C,A不为冗余属性，所以A不能去掉</li>
<li>去掉B, A^+^ = A, 不包含C,B不为冗余属性，所以B不能去掉</li>
</ol>
</blockquote>
  <br/>
<p><font color = blue size = 4>BE→C:</font></p>
<blockquote>
<ol>
<li>去掉B, E^+^ = E, 不包含C,B不为冗余属性，所以B不能去掉</li>
<li>去掉E, B^+^ = B, 不包含C,E不为冗余属性，所以E不能去掉</li>
</ol>
</blockquote>
<br/>
<p><font color = blue size = 4>BC→D:</font></p>
<blockquote>
<ol>
<li>
<p>去掉B, C^+^ = {A,C}, 不包含D, B不为冗余属性，所以B不能去掉</p>
</li>
<li>
<p>去掉C, B^+^ = B, 不包含D, C不为冗余属性，所以C不能去掉</p>
</li>
</ol>
</blockquote>
  <br/>
<p><font color = blue size = 4>CG→B:</font></p>
<blockquote>
<ol>
<li>
<p>去掉C, G^+^ = G, 不包含B, C不为冗余属性，所以C不能去掉</p>
</li>
<li>
<p>去掉G, C^+^ = {A,C}, 不包含B, G不为冗余属性，所以G不能去掉</p>
</li>
</ol>
</blockquote>
<br/>
<p><font color = blue size = 4>ACD→B:</font></p>
<blockquote>
<ol>
<li>
<p>去掉A, (CD)^+^ = {A, B, C, D, E, G}, 包含B, A为冗余属性，所以把A去掉,则为<font color = red size = 4>CD→B</font></p>
</li>
<li>
<p>去掉C, D^+^ = {D, E, G}, 不包含B, C不为冗余属性，所以C不能去掉</p>
</li>
<li>
<p>去掉D, C^+^ = {A, C}, 不包含B, D不为冗余属性，所以D不能去掉</p>
</li>
</ol>
</blockquote>
  <br/>
<p><font color = blue size = 4>CE→A:</font></p>
<blockquote>
<ol>
<li>
<p>去掉C, E^+^ = E, 不包含A, C不为冗余属性，所以C不能去掉</p>
</li>
<li>
<p>去掉E, C^+^ = {A, C}, 包含A, E不为冗余属性，所以把E去掉,则为<font color = red size = 4>C→A</font></p>
</li>
<li>
<p>与存在依赖重复，故舍去</p>
</li>
</ol>
</blockquote>
<br/>
<p><font color = blue size = 4>CE→G:</font></p>
<blockquote>
<ol>
<li>
<p>去掉C, E^+^ = E, 不包含G, C不为冗余属性，所以C不能去掉</p>
</li>
<li>
<p>去掉E, C^+^ = {A, C}, 不包含G, E不为冗余属性，所以E不能去掉</p>
</li>
</ol>
</blockquote>
<p><font color = red size = 4>所以：F = {AB→C, D→E, D→G, C→A, BE→C, BC→D, CG→B, CG→D, CD→B, CE→G}</font></p>
<br/>
<p><font color = green size = 4>3. 去掉F中所有冗余依赖关系(逐个求，在去掉某个函数依赖的F中求闭包，如果包含右边属性，则表示这个函数依赖要去掉)</font></p>
<p><font color = blue size = 4>AB→C:</font></p>
<blockquote>
<p>(AB)^+^ = {A, B}, 不包含C, 则不用去掉</p>
</blockquote>
<br/>
<p><font color = blue size = 4>D→E:</font></p>
<blockquote>
<p>D^+^ = {D, G}, 不包含E, 则不用去掉</p>
</blockquote>
<br/>
<p><font color = blue size = 4>D→G:</font></p>
<blockquote>
<p>D^+^ = {D, E}, 不包含G, 则不用去掉</p>
</blockquote>
<br/>
<p><font color = blue size = 4>C→A:</font></p>
<blockquote>
<p>C^+^ = C, 不包含A, 则不用去掉</p>
</blockquote>
<br/>
<p><font color = blue size = 4>BE→C:</font></p>
<blockquote>
<p>(BE)^+^ = {B, E}, 不包含C, 则不用去掉</p>
</blockquote>
<br/>
<p><font color = blue size = 4>BC→D:</font></p>
<blockquote>
<p>(BC)^+^ = {A, B, C}, 不包含D, 则不用去掉</p>
</blockquote>
<br/>
<p><font color = blue size = 4>CG→B:</font></p>
<blockquote>
<p>(CG)^+^ = {A, B, C, D, E, G}, 包含B, 则<b>去掉</b></p>
</blockquote>
<br/>
<blockquote>
<p><font color = red size = 4>注意：</font><span style="background: linear-gradient(to right, #f2994a, #f2c94c);"><font color = green size = 4>此时CG→B已被去掉，函数依赖集F需要更新后再求新的函数依赖的闭包</font></span></p>
</blockquote>
<p><font color = blue size = 4>CG→D:</font></p>
<blockquote>
<p>(CG)^+^ = {A, C, G}, 不包含D, 则不用去掉</p>
</blockquote>
<br/>
<p><font color = blue size = 4>CD→B:</font></p>
<blockquote>
<p>(CD)^+^ = {A, C, D, E, G}, 不包含B, 则不用去掉</p>
</blockquote>
  <br/>
<p><font color = blue size = 4>CE→G:</font></p>
<blockquote>
<p>(CE)^+^ = {A, C, E}, 不包含G, 则不用去掉</p>
</blockquote>
<br/>
<p><font color = red size = 4>故最小依赖集为：F~m~= {AB→C, D→E, D→G, C→A, BE→C, BC→D, CG→D, CD→B, CE→G}</font></p>
</li>
</ul>
<br/>
<h4 id="font-color-blue-size-4-7-超码，候选码与主码-font"><font color = blue size = 4>7) 超码，候选码与主码</font></h4>
<ul>
<li>
<p><font color = green size = 4>关系：</font></p>
<blockquote>
<p>超码包括候选码，候选码包括主码</p>
</blockquote>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = green size = 4>超码：</font></p>
<blockquote>
<ol>
<li>
<p>是一个或多个属性的集合，这些属性可以让我们在一个实体集中地标识一个实体</p>
</li>
<li>
<p>如果K是超码，那么所有包含K的集合也是超码</p>
</li>
</ol>
</blockquote>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = green size = 4>候选码：</font></p>
<blockquote>
<ol>
<li>
<p>从超码中选出的，自然地，候选码也是一个或多个属性的集合；</p>
</li>
<li>
<p>可能大多数超码中含有多余的属性。所以我们需要候选码，<font color = red>不含有多余属性的超码称为候选码，候选码是可以标识一个元组的最少的属性集合。</font></p>
</li>
<li>
<p>关系中的一个超码，其值能标识一个元组，若从<font color = red>该超码中去掉任何一个属性，它就不具有这一性质了。</font>（即该超码不应该存在一个真子集也能标识一个元组）。这样的属性组称作候选码。</p>
</li>
<li>
<p><font color = red>候选码是最小超码</font>，它们的<font color = red>任意真子集都不能成为超码</font>。例如，如果K是超码，那么所有包含K的集合都不能是候选码；如果K，J都不是超码，那么K和J组成的集合（K，J）有可能是候选码。</p>
</li>
</ol>
</blockquote>
<br/>
</li>
<li>
<p><font color = green size = 4>主码：</font></p>
<blockquote>
<p>一个表的候选码可能有多个，从这些个候选码中选择一个做为主码，至于选择哪一个候选码，这个是无所谓的，只要是从候选码中选的就行。</p>
</blockquote>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = green size = 4>主属性：</font></p>
<blockquote>
<p>一个表可以有多个候选码，那么对于某个属性来说，如果这个属性存在于所有的候选码中，它就称之为主属性。<font color = red>简单来说，主属性是候选码属性的并集。</font></p>
</blockquote>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = green size = 4>非主属性：</font></p>
<blockquote>
<p>不包含在候选码中的属性称为非主属性。 非主属性是相对于主属性来定义的。</p>
</blockquote>
</li>
</ul>
<br/>
<blockquote>
<p><font color = dark size = 5>&lt;各类码及属性整理&gt;</font></p>
<p><a href="https://blog.csdn.net/sumaliqinghua/article/details/85872446" target="_blank" rel="noopener">https://blog.csdn.net/sumaliqinghua/article/details/85872446</a></p>
</blockquote>
<br/>
<h4 id="font-color-blue-size-4-8-求解候选码-font"><font color = blue size = 4>8) 求解候选码</font></h4>
<ul>
<li>
<p><font color = green size = 4>对于给定的关系R（A1，A2，…An）和函数依赖集F，可将其属性分为4类：</font></p>
<blockquote>
<p>L类：仅出现在函数依赖左部的属性。</p>
<p>R 类：仅出现在函数依赖右部的属性。</p>
<p>N类：在函数依赖左右两边均未出现的属性。</p>
<p>LR类：在函数依赖左右两边均出现的属性。</p>
</blockquote>
  <br/>
<blockquote>
<p><font color = red>定理1：</font>对于给定的关系模式R及其函数依赖集F，若X（X∈R）是L类属性，则X必为R的<font color = blue>任一候选码的成员。</font></p>
<p><font color = red>推论1：</font>对于给定的关系模式R及其函数依赖集F，若X（X∈R）是L类属性，且X^+^包含了R的全部属性；则X必为R的<span style="background: linear-gradient(to right, #f2994a, #f2c94c);"><font color = blue>唯一候选码。</font></span></p>
</blockquote>
<br/>
<blockquote>
<p><font color = red>定理2：</font>对于给定的关系模式R及其函数依赖集F，若X（X∈R）是R类属性，则X<font color = blue>不在任何候选码中。</font></p>
<p><font color = red>定理3：</font>对于给定的关系模式R及其函数依赖集F，若X（X∈R）是N类属性，则X<font color = blue>必包含在R的任一候选码中。</font></p>
<p><font color = red>推论2：</font>对于给定的关系模式R及其函数依赖集F，若X（X∈R）是L类和N类组成的属性集，且X^+^包含了<font color = blue>R的全部属性</font>；则X是R的<span style="background: linear-gradient(to right, #f2994a, #f2c94c);"><font color = blue>唯一候选码。</font></span></p>
</blockquote>
</li>
</ul>
<br/>
<p><font color = red size = 4>具体步骤：</font></p>
<p><strong>算法描述：</strong></p>
<blockquote>
<ol>
<li>
<p>将R 的所有属性分为L、R、LR 和N 四类，并令X 代表L、N 类，Y 代表LR 类。</p>
</li>
<li>
<p>求X^+^。若X^+^包含了R 的全部属性，则即为R 的<span style="background: linear-gradient(to right, #f2994a, #f2c94c);">唯一候选码</span>，转（5）；否则，转（3）。</p>
</li>
<li>
<p>在Y 中取一属性A，求(XA)^+^ ，若它包含了R 的全部属性，则是<span style="background: linear-gradient(to right, #74ebd5, #acb6e5);">候选码</span>，转（4）；否则，调换一属性反复进行这一过程，直到试完所有Y 中的属性。</p>
</li>
<li>
<p>如果已找出所有候选码，则转（5）；否则在Y 中依次取2 个、3 个、…，求它们的属性闭包，若其闭包包含R 的全部属性，则是<span style="background: linear-gradient(to right, #74ebd5, #acb6e5);">候选码</span>。</p>
</li>
<li>
<p>结束。</p>
</li>
</ol>
</blockquote>
<br/>
<p><font color = green size = 4>示例1：</font></p>
<blockquote>
<p>如设有关系模式R(U), 其函数依赖集为F, 其中U={A, B, C, D, E}, F={A$\rightarrow$C, C$\rightarrow$A, B$\rightarrow$AC, D$\rightarrow$AC}<br>
求R 的候选码。</p>
</blockquote>
<br/>
<p><font color = brown size = 4>求解方法：</font></p>
<p><font color = green size = 4>根据函数依赖可得：</font></p>
<blockquote>
<p>属性<font color = red>B 、D</font> 为L 类，<font color = red>E</font> 为N 类，因此属性<font color = red>B 、D 、E</font> 必为候选码的成员， 且此三个属性的闭包： <font color = blue>B^+^=ABC, (BD)^+^=ABCD, (BDE)^+^=ABCDE</font>, 根据推论2 可得BDE 是R 的唯一候选码。所以R 的候选码为BDE 。</p>
</blockquote>
<blockquote>
<p><font color = red>变式：</font>如果把例题中关系模式<font color = blue>R(U) 中的属性E</font> 去掉，那么再求R 的候选码的话可以根据推论1得出<br>
BD 为R 的唯—候选码。</p>
</blockquote>
<br/>
<p><font color = green size = 4>示例2：</font></p>
<blockquote>
<p>如设有关系模式R(U), 其函数依赖集为F, 其中U={A, B, C, D, E}, F={B$\rightarrow$A, D$\rightarrow$A, A$\rightarrow$E, AC$\rightarrow$B}<br>
求R 的候选码。</p>
</blockquote>
<p><font color = brown size = 4>求解方法：</font></p>
<p><font color = green size = 4>根据函数依赖可得：</font></p>
<blockquote>
<p>属性<font color = red>C、D</font> 为L 类，因此属性<font color = red>C、D </font> 必为候选码的成员， 且此两个属性的闭包： <font color = blue>C^+^=C, (CD) ^+^=ABCDE</font>, 根据推论1可得CD 是R 的唯一候选码。所以R 的候选码为CD 。</p>
</blockquote>
<br/>
<blockquote>
<p><font color = red size = 4>注意：</font></p>
<ul>
<li>
<p>快速求解方法适用于判断有属性是属于L 类、N 类或其中一种的情况下求解。如果有L 类和N类的属性， 则求解候选码速度非常快。</p>
</li>
<li>
<p><span style="background: linear-gradient(to right, #f2994a, #f2c94c);">简而言之：</span> L、R、N、LR 类。根据定理， L、N 类必为侯选码之一，如果L^+^包含全部R, 则L为唯一侯选。R 类不在任何侯选码中。L+N 类且(L+N)^+^包含所有R, 则L+N 为唯一侯选。(适于有L、N 类至少一种的情况。)</p>
</li>
</ul>
</blockquote>
<br/>
<h3 id="5-关系模式的分解">5.关系模式的分解</h3>
<h4 id="font-color-blue-1-无损联接-font"><font color = blue>1) 无损联接</font></h4>
<ul>
<li>
<p><font color = green size = 4>定义：</font></p>
<p>无损联接分解是将一个关系模式分解成若干个关系模式后，通过自然联接和投影等运算仍能还原到原来的关系模式，则称这种分解为无损联接分解。</p>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = green size = 4>示例：</font></p>
<blockquote>
<p>关系模式：成绩（学号，姓名，课程号，课程名，分数）</p>
<p>函数依赖：学号-&gt;姓名，课程号-&gt;课程名， （学号，课程号）-&gt;分数</p>
</blockquote>
<blockquote>
<p>若将其分解为下面三个关系模式：</p>
<p>成绩（学号，课程号，分数）</p>
<p>学生（学号，姓名）</p>
<p>课程（课程号，课程名）</p>
</blockquote>
<br/>
<p><font color = red size = 4>1. 这样的分解是无损分解吗？</font></p>
<blockquote>
<p><font color = green size = 4>$\because$ 学号-&gt;姓名</font></p>
<p><font color = green size = 4> $\therefore$  成绩（<font color = red  size = 4>学号</font>，课程号，分数，<font color = blue size = 4>姓名</font>）</font></p>
<p><font color = green size = 4>$\because$ 课程号-&gt;课程名</font></p>
<p><font color = green size = 4>$\therefore$ 成绩（学号，<font color = red size = 4>课程号</font>，分数，姓名，<font color = blue size = 4>课程名</font>）</font></p>
</blockquote>
<p><font color = red size = 4>因此这个例子是无损分解的</font></p>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = green size = 4>无损分解判定算法：</font></p>
<ol>
<li>
<p>建立一张k行n列的表来检验连接是否失真(第i行对应于Ri，第j列对应于属性Aj)；</p>
<p><img data-src="https://image.zxkidea.top/1551253082653.png" alt="zxk"></p>
</li>
<li>
<p>填表：若A属于Ri，则将第i行第j列填为aj否则填入bij；</p>
</li>
<li>
<p>修改表：逐一考察F中的函数依赖X -&gt; Y，X可能包含一个或者多个属性，如果这（个）些属性对应于表中的列的值相同，则值相等的行所对应的Y属性所有的列的值也相等。（比方说X -&gt; Y，X是A1A2所对应的属性，Y是属性A4。由第一步，如果表中第一行和第二行的值相等，那么表中A4对应的第一行和第二行的值也要修改成一样的。）如果其中有aj，则将bij改成aj；如果没有aj，就将他们都改成bij，一般来说i是值相等的行中最小的行号。</p>
</li>
<li>
<p>反复（指在前一次修改地基础上，反复进行直到表中的数据不再改变）进行（3），若发现某一行变成a1，a2，…aj，则可以得出分解p{(R1,F1)，(R2,F2)，…(Rk,Fk)}具有连接不失真性（即无损分解）</p>
</li>
</ol>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = green size = 4>具体示例：</font></p>
<p><font color = blue size = 4>设R=ABCDE, R1=AD, R2=BC, R3=BE, R4=CDE, R5=AE（<span style="background: linear-gradient(to right, #f2994a, #f2c94c);">省略F~i~，若给出U~i~，则表示求R~i~（U~i~，F~i~）</span>）, 设函数依赖：A-&gt;C, B-&gt;C, C-&gt;D, DE-&gt;C, CE-&gt;A. 判断R分解成 ρ={R1,  R2,  R3,  R4,  R5}是否无损联接分解？</font></p>
<br/>
<p><font color = dark size = 4>1. 建表:</font></p>
<table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
</tr>
</thead>
<tbody>
<tr>
<td>AD</td>
<td><font color = red >a1</font></td>
<td>b12</td>
<td>b13</td>
<td><font color = red >a4</font></td>
<td>b15</td>
</tr>
<tr>
<td>BC</td>
<td>b21</td>
<td><font color = red >a2</font></td>
<td><font color = red >a3</font></td>
<td>b24</td>
<td>b25</td>
</tr>
<tr>
<td>BE</td>
<td>b31</td>
<td><font color = red >a2</font></td>
<td>b33</td>
<td>b34</td>
<td><font color = red >a5</font></td>
</tr>
<tr>
<td>CDE</td>
<td>b41</td>
<td>b42</td>
<td><font color = red >a3</font></td>
<td><font color = red >a4</font></td>
<td><font color = red >a5</font></td>
</tr>
<tr>
<td>AE</td>
<td><font color = red >a1</font></td>
<td>b52</td>
<td>b53</td>
<td>b54</td>
<td><font color = red >a5</font></td>
</tr>
</tbody>
</table>
<br/>
<blockquote>
<p><font color = green size = 4>分析：</font></p>
<p>(A B C D E)是关系R的属性， AD, BC, BE, CDE, AE 是分解之后每一个关系对应的属性集</p>
<p><font color = green size = 4>填表的过程：</font></p>
<p>当横竖相交的时候，如果在分解关系中存在对应列的单个的属性（譬如第一列第一行AD与A相交的单元格，AD含有A，就填写a1），则填写a下标 ， 下标就是单元格对应所在的列号。否则填写b下标， 下标是单元格对应所在的行列号。</p>
</blockquote>
  <br/>
<p><font color = dark size = 4>2. 根据依赖关系修改原始表：</font></p>
<ol>
<li>对于依赖关系A$\rightarrow$C，看A列中有两行a1是相等的（第一行和第五行），所以在C列中对应的两行也应该相等，但是看到这两行都是b（b13，b53），所以将这个b都换成b13（上面的较小的标）</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">A</th>
<th style="text-align:center">B</th>
<th style="text-align:center">C</th>
<th style="text-align:center">D</th>
<th style="text-align:center">E</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">AD</td>
<td style="text-align:center"><font color = red >a1</font></td>
<td style="text-align:center">b12</td>
<td style="text-align:center"><font color = blue >b13</font></td>
<td style="text-align:center"><font color = red >a4</font></td>
<td style="text-align:center">b15</td>
</tr>
<tr>
<td style="text-align:center">BC</td>
<td style="text-align:center">b21</td>
<td style="text-align:center"><font color = red >a2</font></td>
<td style="text-align:center"><font color = red >a3</font></td>
<td style="text-align:center">b24</td>
<td style="text-align:center">b25</td>
</tr>
<tr>
<td style="text-align:center">BE</td>
<td style="text-align:center">b31</td>
<td style="text-align:center"><font color = red >a2</font></td>
<td style="text-align:center">b33</td>
<td style="text-align:center">b34</td>
<td style="text-align:center"><font color = red >a5</font></td>
</tr>
<tr>
<td style="text-align:center">CDE</td>
<td style="text-align:center">b41</td>
<td style="text-align:center">b42</td>
<td style="text-align:center"><font color = red >a3</font></td>
<td style="text-align:center"><font color = red >a4</font></td>
<td style="text-align:center"><font color = red >a5</font></td>
</tr>
<tr>
<td style="text-align:center">AE</td>
<td style="text-align:center"><font color = red >a1</font></td>
<td style="text-align:center">b52</td>
<td style="text-align:center"><font color = blue >b53 $\rightarrow$ b13</font></td>
<td style="text-align:center">b54</td>
<td style="text-align:center"><font color = red >a5</font></td>
</tr>
</tbody>
</table>
<br/>
<ol start="2">
<li>对于依赖B $\rightarrow$ C, 同样的道理，看B这一列中，第二行和第三行都是a2,那么对C这一列同样的操作，但是看到C这一列中第二行是a3，那么就将第三行改成a3，优先级比b要高。</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">A</th>
<th style="text-align:center">B</th>
<th style="text-align:center">C</th>
<th style="text-align:center">D</th>
<th style="text-align:center">E</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">AD</td>
<td style="text-align:center"><font color = red >a1</font></td>
<td style="text-align:center">b12</td>
<td style="text-align:center">b13</td>
<td style="text-align:center"><font color = red >a4</font></td>
<td style="text-align:center">b15</td>
</tr>
<tr>
<td style="text-align:center">BC</td>
<td style="text-align:center">b21</td>
<td style="text-align:center"><font color = red >a2</font></td>
<td style="text-align:center"><font color = red >a3</font></td>
<td style="text-align:center">b24</td>
<td style="text-align:center">b25</td>
</tr>
<tr>
<td style="text-align:center">BE</td>
<td style="text-align:center">b31</td>
<td style="text-align:center"><font color = red >a2</font></td>
<td style="text-align:center"><font color = blue >b33 $\rightarrow$ a3</font></td>
<td style="text-align:center">b34</td>
<td style="text-align:center"><font color = red >a5</font></td>
</tr>
<tr>
<td style="text-align:center">CDE</td>
<td style="text-align:center">b41</td>
<td style="text-align:center">b42</td>
<td style="text-align:center"><font color = red >a3</font></td>
<td style="text-align:center"><font color = red >a4</font></td>
<td style="text-align:center"><font color = red >a5</font></td>
</tr>
<tr>
<td style="text-align:center">AE</td>
<td style="text-align:center"><font color = red >a1</font></td>
<td style="text-align:center">b52</td>
<td style="text-align:center">b13</td>
<td style="text-align:center">b54</td>
<td style="text-align:center"><font color = red >a5</font></td>
</tr>
</tbody>
</table>
<br/>
<ol start="3">
<li>对依赖C$\rightarrow$D，C列的1，5行相等，D的1，5行也应该相等，D的第1行有a，所以b54换成a4；另外C列的2，3，4行也相等，D的2，3，4行也应该相等，D的第4行有a，所以将对应的行都换成a4。</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">A</th>
<th style="text-align:center">B</th>
<th style="text-align:center">C</th>
<th style="text-align:center">D</th>
<th style="text-align:center">E</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">AD</td>
<td style="text-align:center"><font color = red >a1</font></td>
<td style="text-align:center">b12</td>
<td style="text-align:center">b13</td>
<td style="text-align:center"><font color = red >a4</font></td>
<td style="text-align:center">b15</td>
</tr>
<tr>
<td style="text-align:center">BC</td>
<td style="text-align:center">b21</td>
<td style="text-align:center"><font color = red >a2</font></td>
<td style="text-align:center"><font color = red >a3</font></td>
<td style="text-align:center"><font color = blue >b24 $\rightarrow$ a4</font></td>
<td style="text-align:center">b25</td>
</tr>
<tr>
<td style="text-align:center">BE</td>
<td style="text-align:center">b31</td>
<td style="text-align:center"><font color = red >a2</font></td>
<td style="text-align:center"><font color = red >a3</font></td>
<td style="text-align:center"><font color = blue >b34 $\rightarrow$ a4</font></td>
<td style="text-align:center"><font color = red >a5</font></td>
</tr>
<tr>
<td style="text-align:center">CDE</td>
<td style="text-align:center">b41</td>
<td style="text-align:center">b42</td>
<td style="text-align:center"><font color = red >a3</font></td>
<td style="text-align:center"><font color = red >a4</font></td>
<td style="text-align:center"><font color = red >a5</font></td>
</tr>
<tr>
<td style="text-align:center">AE</td>
<td style="text-align:center"><font color = red >a1</font></td>
<td style="text-align:center">b52</td>
<td style="text-align:center">b13</td>
<td style="text-align:center"><font color = blue >b54 $\rightarrow$ a4</font></td>
<td style="text-align:center"><font color = red >a5</font></td>
</tr>
</tbody>
</table>
  <br/>
<ol start="4">
<li>对于DE$\rightarrow$C, DE公共的相等的行是3，4，5行，对应C的3，4，5行也应该相等，故将C列最后的b13换成a3，所以表格经过这个函数依赖关系，就是：</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">A</th>
<th style="text-align:center">B</th>
<th style="text-align:center">C</th>
<th style="text-align:center">D</th>
<th style="text-align:center">E</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">AD</td>
<td style="text-align:center"><font color = red >a1</font></td>
<td style="text-align:center">b12</td>
<td style="text-align:center">b13</td>
<td style="text-align:center"><font color = red >a4</font></td>
<td style="text-align:center">b15</td>
</tr>
<tr>
<td style="text-align:center">BC</td>
<td style="text-align:center">b21</td>
<td style="text-align:center"><font color = red >a2</font></td>
<td style="text-align:center"><font color = red >a3</font></td>
<td style="text-align:center"><font color = red >a4</font></td>
<td style="text-align:center">b25</td>
</tr>
<tr>
<td style="text-align:center">BE</td>
<td style="text-align:center">b31</td>
<td style="text-align:center"><font color = red >a2</font></td>
<td style="text-align:center"><font color = red >a3</font></td>
<td style="text-align:center"><font color = red >a4</font></td>
<td style="text-align:center"><font color = red >a5</font></td>
</tr>
<tr>
<td style="text-align:center">CDE</td>
<td style="text-align:center">b41</td>
<td style="text-align:center">b42</td>
<td style="text-align:center"><font color = red >a3</font></td>
<td style="text-align:center"><font color = red >a4</font></td>
<td style="text-align:center"><font color = red >a5</font></td>
</tr>
<tr>
<td style="text-align:center">AE</td>
<td style="text-align:center"><font color = red >a1</font></td>
<td style="text-align:center">b52</td>
<td style="text-align:center"><font color = blue >b13 $\rightarrow$ a3</font></td>
<td style="text-align:center"><font color = red >a4</font></td>
<td style="text-align:center"><font color = red >a5</font></td>
</tr>
</tbody>
</table>
<br/>
<ol start="5">
<li>对于CE$\rightarrow$A, CE的公共行是3，4，5行，所以将A的3，4，5行也对应相等，因为A列的第五行含有a1，所以将3，4行的b31,b41都换成a1</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">A</th>
<th style="text-align:center">B</th>
<th style="text-align:center">C</th>
<th style="text-align:center">D</th>
<th style="text-align:center">E</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">AD</td>
<td style="text-align:center"><font color = red >a1</font></td>
<td style="text-align:center">b12</td>
<td style="text-align:center">b13</td>
<td style="text-align:center"><font color = red >a4</font></td>
<td style="text-align:center">b15</td>
</tr>
<tr>
<td style="text-align:center">BC</td>
<td style="text-align:center">b21</td>
<td style="text-align:center"><font color = red >a2</font></td>
<td style="text-align:center"><font color = red >a3</font></td>
<td style="text-align:center"><font color = red >a4</font></td>
<td style="text-align:center">b25</td>
</tr>
<tr>
<td style="text-align:center">BE</td>
<td style="text-align:center"><font color = blue >b31 $\rightarrow$ a1</font></td>
<td style="text-align:center"><font color = red >a2</font></td>
<td style="text-align:center"><font color = red >a3</font></td>
<td style="text-align:center"><font color = red >a4</font></td>
<td style="text-align:center"><font color = red >a5</font></td>
</tr>
<tr>
<td style="text-align:center">CDE</td>
<td style="text-align:center"><font color = blue >b41 $\rightarrow$ a1</font></td>
<td style="text-align:center">b42</td>
<td style="text-align:center"><font color = red >a3</font></td>
<td style="text-align:center"><font color = red >a4</font></td>
<td style="text-align:center"><font color = red >a5</font></td>
</tr>
<tr>
<td style="text-align:center">AE</td>
<td style="text-align:center"><font color = red >a1</font></td>
<td style="text-align:center">b52</td>
<td style="text-align:center"><font color = red >a3</font></td>
<td style="text-align:center"><font color = red >a4</font></td>
<td style="text-align:center"><font color = red >a5</font></td>
</tr>
</tbody>
</table>
<br/>
<ol start="6">
<li>最终得到的表格就是：</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">A</th>
<th style="text-align:center">B</th>
<th style="text-align:center">C</th>
<th style="text-align:center">D</th>
<th style="text-align:center">E</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">AD</td>
<td style="text-align:center"><font color = red >a1</font></td>
<td style="text-align:center">b12</td>
<td style="text-align:center">b13</td>
<td style="text-align:center"><font color = red >a4</font></td>
<td style="text-align:center">b15</td>
</tr>
<tr>
<td style="text-align:center">BC</td>
<td style="text-align:center">b21</td>
<td style="text-align:center"><font color = red >a2</font></td>
<td style="text-align:center"><font color = red >a3</font></td>
<td style="text-align:center"><font color = red >a4</font></td>
<td style="text-align:center">b25</td>
</tr>
<tr>
<td style="text-align:center">BE</td>
<td style="text-align:center"><font color = red >a1</font></td>
<td style="text-align:center"><font color = red >a2</font></td>
<td style="text-align:center"><font color = red >a3</font></td>
<td style="text-align:center"><font color = red >a4</font></td>
<td style="text-align:center"><font color = red >a5</font></td>
</tr>
<tr>
<td style="text-align:center">CDE</td>
<td style="text-align:center"><font color = red >a1</font></td>
<td style="text-align:center">b42</td>
<td style="text-align:center"><font color = red >a3</font></td>
<td style="text-align:center"><font color = red >a4</font></td>
<td style="text-align:center"><font color = red >a5</font></td>
</tr>
<tr>
<td style="text-align:center">AE</td>
<td style="text-align:center"><font color = red >a1</font></td>
<td style="text-align:center">b52</td>
<td style="text-align:center"><font color = red >a3</font></td>
<td style="text-align:center"><font color = red >a4</font></td>
<td style="text-align:center"><font color = red >a5</font></td>
</tr>
</tbody>
</table>
<br/>
<p><font color = dark size = 4>3. 最后，我们从表格里看到对于BE行来说，变成a1…a5，所以得出结论，题中的分解是无损联接分解</font></p>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = green size = 4>无损分解的一个简便的判别方法（<span style="background: linear-gradient(to right, #74ebd5, #acb6e5);">适用于分解成2个关系的情况</span>）</font></p>
<blockquote>
<p>例如：</p>
<p>有关系R=ABC, 依赖关系F = {A–&gt;B}那么下面哪个是无损分解：</p>
<p>A. {R1(AB), R2(AC)}<br>
B. {R1(AB), R3(BC)}</p>
</blockquote>
  <br/>
<p><font color = brown size = 4>求解方法：</font></p>
<p><font color = blue size = 4>1. 建表法：</font></p>
<p><span style="background: linear-gradient(to right, #f2994a, #f2c94c);"><font color = green size = 4>选项A：</font></span></p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">A</th>
<th style="text-align:center">B</th>
<th style="text-align:center">C</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">AB</td>
<td style="text-align:center"><font color = red >a1</font></td>
<td style="text-align:center"><font color = red >a2</font></td>
<td style="text-align:center">b13</td>
</tr>
<tr>
<td style="text-align:center">AC</td>
<td style="text-align:center"><font color = red >a1</font></td>
<td style="text-align:center">b22</td>
<td style="text-align:center"><font color = red >a3</font></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">A</th>
<th style="text-align:center">B</th>
<th style="text-align:center">C</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">AB</td>
<td style="text-align:center"><font color = red >a1</font></td>
<td style="text-align:center"><font color = red >a2</font></td>
<td style="text-align:center">b13</td>
</tr>
<tr>
<td style="text-align:center">AC</td>
<td style="text-align:center"><font color = red >a1</font></td>
<td style="text-align:center"><font color = red >a2</font></td>
<td style="text-align:center"><font color = red >a3</font></td>
</tr>
</tbody>
</table>
<p><span style="background: linear-gradient(to right, #f2994a, #f2c94c);"><font color = green size = 4>选项B：</font></span></p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">A</th>
<th style="text-align:center">B</th>
<th style="text-align:center">C</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">AB</td>
<td style="text-align:center"><font color = red >a1</font></td>
<td style="text-align:center"><font color = red >a2</font></td>
<td style="text-align:center">b13</td>
</tr>
<tr>
<td style="text-align:center">BC</td>
<td style="text-align:center">b21</td>
<td style="text-align:center"><font color = red >a2</font></td>
<td style="text-align:center"><font color = red >a3</font></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">A</th>
<th style="text-align:center">B</th>
<th style="text-align:center">C</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">AB</td>
<td style="text-align:center"><font color = red >a1</font></td>
<td style="text-align:center"><font color = red >a2</font></td>
<td style="text-align:center">b13</td>
</tr>
<tr>
<td style="text-align:center">BC</td>
<td style="text-align:center">b21</td>
<td style="text-align:center"><font color = red >a2</font></td>
<td style="text-align:center"><font color = red >a3</font></td>
</tr>
</tbody>
</table>
<blockquote>
<p><font color = red size = 4>结论：</font><font color = green size = 4>选项A的AC一行为a1…a3，故此时为无损分解；而选项B无法化成，所以不是无损分解。</font></p>
</blockquote>
<p><font color = blue size = 4>2. 快速判别法：</font></p>
<blockquote>
<ol>
<li>
<p>首先看选项A，R1∩R2=A，R1-R2=B，R1∩ R2–&gt;(R1-R2) F+.所以它是无损分解</p>
</li>
<li>
<p>再看选项B， R1∩R2=B, R1-R2=A, R2-R1=C,</p>
</li>
<li>
<p>所以它不是无损分解</p>
</li>
</ol>
</blockquote>
<br/>
<blockquote>
<p><font color = red size = 4>快速判断无损分解的方法就是:</font></p>
<p><font color = green size = 4>1. 对两个集合先求集合的∩，然后求集合的差(2个集合有两个差的结果)<br>
如果集合的∩–&gt;集合的差（得到差结果的任意一个）$\subseteq$ F^+^ 成立，那么就是无损分解</font></p>
<p><font color = green size = 4>2. 如果R1∩R2是R1或R2的超码，则R上的分解（R1，R2）是无损分解。这是一个<font color = red>充分条件</font>，当所有的约束都是函数依赖时它才是必要条件（例如多值依赖就是一种非函数依赖的约束），不过这已经足够了。</font></p>
</blockquote>
  <br/>
</li>
</ul>
<h4 id="font-color-blue-2-保持函数依赖-font"><font color = blue>2) 保持函数依赖</font></h4>
<ul>
<li>
<p><font color = green size = 4>定义:</font></p>
<blockquote>
<p>如果F上的每一个函数依赖都在其分解后的<font color = red>某一个关系上</font>成立，则这个分解是保持依赖的（这是一个<font color = red >充分条件</font>）。如果上述判断失败，并不能断言分解不是保持依赖的，还要使用下面的通用方法来做进一步判断。</p>
</blockquote>
<br/>
<blockquote>
<p>设F是关系模式R的函数依赖集，ρ={R1&lt;U1,F1&gt;, R2&lt;U2,F2&gt;,…, Rk&lt;Uk,Fk&gt;}为R的一个分解，如果Fi=π~Ri~(F)<font color = red >(Fi为函数依赖集F在Ri上的投影)</font>的并集(F1∪F2∪…∪Fk) ≡ F（i=1,2,…,k）,则称分解ρ具有函数依赖保持性。</p>
</blockquote>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = green size = 4>保持依赖判定算法：</font></p>
<ul>
<li>
<p>对F上的每一个α→β使用下面的过程：</p>
<blockquote>
<p><font color = dark size = 4>result:=α;</font><br>
<font color = dark size = 4>while(result发生变化)do</font><br>
<font color = dark size = 4> 	for each 分解后的Ri</font><br>
<font color = dark size = 4>t=(result∩Ri)^+^∩Ri</font><br>
<font color = dark size = 4>result=result∪t</font></p>
</blockquote>
</li>
</ul>
<br/>
<ul>
<li>这里的属性闭包是在函数依赖集F下计算出来的。如果result中包含了β的所有属性，则函数依赖α→β。分解是保持依赖的当且仅当上述过程中F的所有依赖都被保持。</li>
</ul>
<br/>
<blockquote>
<p><font color = red>函数依赖保持判断方法：</font></p>
<ol>
<li><font color = green>先找到要分解的目标R~i~（U~i~），然后求出U~i~^+^；</font></li>
<li><font color = green>接着在F中找到所有包含U~i~^+^属性的关系 ；</font></li>
<li><font color = green>挑选或推导出仅含有R~i~（U~i~）中属性的关系，组成即为F~i~ ；</font></li>
</ol>
</blockquote>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = green size = 4>示例：</font></p>
<p><font color = blue size = 4>1. 将R = (ABCD，{A→B，B→C，B→D，C→A})分解为关于U1=AB，U2=ACD两个关系（<span style="background: linear-gradient(to right, #f2994a, #f2c94c);">给出U~i~，则表示求R~i~（U~i~，F~i~）</span>），求R1、R2，<br>
并检验分解的无损联接性和分解的函数依赖保持性。</font></p>
<p><font color = brown size = 4>求解方法：</font></p>
<p><font color = blue>1. 无损分解：</font></p>
<blockquote>
<p>F1 = π~R1~(F) = {A→B, B→A},<br>
F2 = π~R2~(F) = {A→C, C→A, A→D}</p>
<blockquote>
<p><font color = red>注意：</font><font color = green>Fi为仅含有Ui中元素，且在F上的所有关系（包含推导关系）</font></p>
</blockquote>
<p>R1 = (AB, {A→B, B→A})<br>
R2 = (ACD, {A→C, C→A, A→D})</p>
<p><font color = red>U1∩U2 = AB∩ACD = A, </font></p>
<p><font color = red>U1-U2 = AB-ACD = B, A→B∈F, </font></p>
<p><font color = blue>所以ρ是无损分解；</font></p>
</blockquote>
<br/>
<p><font color = blue>2. 函数依赖性：</font></p>
<blockquote>
<p><font color = red>F1UF2 = {A→B, B→A, A→C, C→A, A→D} ≡ {A→B, B→C, B→D, C→A} = F；</font></p>
<p><font color = orange>Tip：</font><font color = green>可用定理对函数依赖进行化简，观察并集是否为F；</font></p>
<p><font color = blue>所以ρ具有函数依赖保持性。</font></p>
</blockquote>
<br/>
<p><font color = blue size = 4 >2. 关系模式R(A, B, C ,D，{F}) 中函数依赖集F = {A→B, C→D}, ρ = {R1(AB，{F~1~})，R2(CD，{F~2~})}，求R1, R2 并检验分解的无损联接性和分解的函数依赖保持性。</font></p>
<br/>
<p><font color = brown size = 4>求解方法：</font></p>
<p><font color = blue>1. 无损分解：</font></p>
<blockquote>
<p>F1 = π~R1~(F) = {A→B},<br>
F2 = π~R2~(F) = {C→D}<br>
R1(AB, {A→B}),<br>
R2(CD, {C→D})<br>
<font color = red>U1∩U2 = AB∩CD = Φ,</font><br>
<font color = red>U1-U2 = AB,</font><br>
<font color = red>U2-U1 = CD,</font><br>
Φ→AB$\notin$F,<br>
Φ→CD$\notin$F,</p>
<p><font color = blue>所以ρ不是无损分解；</font></p>
</blockquote>
<br/>
<p><font color = blue>2. 函数依赖性：</font></p>
<blockquote>
<p><font color = red>F1UF2 = {A→B，C→D} = F</font></p>
<p><font color = blue>所以ρ具有函数依赖保持性。</font></p>
</blockquote>
<br/>
<p><font color = blue size = 4 >3. 已知关系模式R(CITY, ST, ZIP), F = {(CITY, ST)→ZIP, ZIP→CITY}，以及R上的一个分解ρ = {R1(U~1~，F~1~), R2(U~2~，F~2~)}, R1 = {ST, ZIP}, R2 = {CITY, ZIP}，求R1, R2 ,并检验分解的无损联接性和分解的函数依赖保持性。</font></p>
  <br/>
<p><font color = brown size = 4>求解方法：</font></p>
<p><font color = blue>1. 无损分解：</font></p>
<blockquote>
<p>F1= π~R1~(F) = {Φ},<br>
F2 = π~R2~(F) = {ZIP→CITY}</p>
<p>R1 = ({ST, ZIP}, {Φ})，</p>
<p>R2 = (CITY, ZIP, {ZIP→CITY})</p>
<p><font color = red>U1∩U2 = {ST, ZIP}∩{CITY, ZIP} = ZIP,</font></p>
<p><font color = red>U1-U2 = ST,</font><br>
<font color = red>U2-U1 = CITY，ZIP→CITY∈F,</font></p>
<p><font color = blue>所以ρ是无损分解；</font></p>
</blockquote>
<p><font color = blue>2. 函数依赖性：</font></p>
<blockquote>
<p><font color = red>F1UF2 = {ZIP→CITY}$\neq${(CITY, ST)→ZIP, ZIP→CITY} = F</font></p>
<p><font color = blue>所以ρ不具有函数依赖保持性。</font></p>
</blockquote>
</li>
</ul>
<br/>
<blockquote>
<p><font color = red size = 4>总结：</font></p>
<ol>
<li><font color = green size = 4>无损分解：R  $\underrightarrow{F(F_i)}$   R~i~ </font></li>
<li><font color = green size = 4>函数依赖：F  $\underrightarrow{R(U_i)}$   F~i~  </font></li>
<li><font color = green size = 4>函数依赖和无损分解间没有必然的联系</font></li>
</ol>
</blockquote>
<br/>
<h3 id="6-关系模式的范式-NF">6.关系模式的范式(NF)</h3>
<h4 id="font-color-green-size-4-1）定义-font"><font color = green size = 4>1）定义</font></h4>
<blockquote>
<p>范式xNF即是满足特定要求的模式，将低一级范式的关系模式通过模式分解转换为高一级范式的关系模式集合的过程叫做<font color = red>规范化</font>；</p>
<p>范式从低级到高级依次为：1NF、2NF、3NF、BCNF、4NF、5NF，高一级的范式总是低一级范式的真子集。</p>
</blockquote>
<br/>
<blockquote>
<p>根据关系模式R的不可约函数依赖集F，可以画出节点是属性或属性集，边是由被依赖节点指向依赖节点的有向图来辅助分析关系模式，叫做<font color = red>函数依赖图</font></p>
</blockquote>
<p>从范式所允许的函数依赖方面进行比较，四种范式之间的关联如下图所示。</p>
<br/>
<p><img data-src="https://image.zxkidea.top/blog/20200304/FnyH4i7YiPew.gif" alt="zxk"></p>
<br/>
<h4 id="font-color-green-size-4-2）各类范式及其说明-font"><font color = green size = 4>2）各类范式及其说明</font></h4>
<ul>
<li>
<p><font color = blue size = 4>第一范式(1NF)</font><font color = red size = 4>(确保每列保持原子性)</font></p>
<blockquote>
<p>第一范式是最基本的范式。如果数据库表中的<font color = brown>所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式。</font></p>
</blockquote>
<br/>
<blockquote>
<p>第一范式的合理遵循需要根据系统的实际需求来定。比如某些数据库系统中需要用到“地址”这个属性，本来直接将“地址”属性设计成一个数据库表的字段就行。<font color = brown>但是如果系统经常会访问“地址”属性中的“城市”部分，那么就非要将“地址”这个属性重新拆分为省份、城市、详细地址等多个部分进行存储，这样在对地址中某一部分操作的时候将非常方便。</font>这样设计才算满足了数据库的第一范式，如下表所示：</p>
</blockquote>
<br/>
<p><img data-src="https://image.zxkidea.top/1551266870484.png" alt="zxk"></p>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = blue size = 4>第二范式(2NF)</font><font color = red size = 4>(确保表中的每列都和主键相关)</font></p>
<blockquote>
<p>第二范式在第一范式的基础之上更进一层。第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。<font color = brown>也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。</font></p>
</blockquote>
<br/>
<ul>
<li>
<p><font color = green >示例1：</font></p>
<blockquote>
<p><font color = blue >设有关系模式R(学号S#,课程号C#,成绩G,任课教师TN,教师专长TS)，基于R的函数依赖集F={(S#, C#)→G, C#→TN, TN→TS},判断R是否为2NF。</font></p>
</blockquote>
<ul>
<li>
<p><font color = brown>函数依赖图：</font></p>
<p><img data-src="https://image.zxkidea.top/blog/20200304/KywgHGFgPUdl.gif" alt="zxk"></p>
</li>
<li>
<p><font color = brown>阿氏推理规则:</font></p>
<blockquote>
<p>由F可推出：(S#, C#)→{S#, C#, G, TN, TS}，即属性组合(S#, C#)是R的候选关键字(R只有这一个候选键)。(S#, C#)的一个值可惟一标识R中的一个元组(并且没有多余的属性)。</p>
<p>在R中，S#, C#是主属性；其余的属性G, TN, TS为非主属性。</p>
</blockquote>
<br/>
<blockquote>
<p>借助上面的图，我们可以看到，非主属性G对键是完全依赖：(S#, C#)→G。但非主属性TN, TS对键是部分依赖(他们仅依赖于键的真子集C#)。由于R中存在<font color = red><em>非主属性对候选键的部分依赖</em></font>，所以关系模式R不是2NF。</p>
</blockquote>
<br/>
<blockquote>
<p><font color = red>注意：</font></p>
<ol>
<li>
<p>R中存在非主属性对候选键的部分依赖，将会引起<font color = green>插入异常、删除异常、更新异常和数据冗余</font>等问题。<font color = red>可以把关系R无损联接地分解成两个2NF的关系模式：</font></p>
<p>ρ = {R1, R2}，R1 = {S#, C#, G}, R2 = {C#, TN, TS}。</p>
</li>
<li>
<p><font color = orange>具体步骤：</font></p>
<ul>
<li>找出R中所有的候选码(X…Y)，即(X…Y)^+^ = F；</li>
<li>得到非主属性，并根据2NF定义判断是否满足2NF；</li>
</ul>
</li>
</ol>
</blockquote>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = green szie = 4>示例2：</font></p>
<blockquote>
<p><font color = blue >选课关系 R（SNO，CNO，GRADE，CREDIT）其中SNO为学号， CNO为课程号，GRADEGE 为成绩，CREDIT 为学分。 </font></p>
</blockquote>
<br/>
<p><font color = brown size = 4>求解方法：</font></p>
<ul>
<li>
<p>由以上条件，关键字为组合关键字（SNO，CNO）</p>
</li>
<li>
<p><font color = brown>原因：</font>非关键字属性CREDIT仅函数依赖于CNO，也就是CREDIT部分依赖组合关键字（SNO，CNO）而不是完全依赖。</p>
</li>
<li>
<p><font color = brown>解决方法：</font>分成两个关系模式 R1（SNO，CNO，GRADE），R2（CNO，CREDIT）。新关系包括两个关系模式，它们之间通过R1中的外关键字CNO相联系，需要时再进行自然联接，恢复了原来的关系</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = blue size = 4>第三范式(3NF)</font><font color = red size = 4>(确保每列都和主键列直接相关,而不是间接相关；即去除非主属性对于候选关键字的传递依赖)</font></p>
<blockquote>
<p>如果关系模式R为2NF，并且<font color = brown>R中的每一个非主属性都不传递依赖于R的某个候选关键字</font>，则称R是第三范式的，简记为3NF。</p>
</blockquote>
  <br/>
<ul>
<li>
<p><font color = green size = 4>示例1：</font></p>
<blockquote>
<p><font color = blue >续上例R(学号S#, 课程号C#, 成绩G, 任课教师TN, 教师专长TS)，判断关系模式R1 = {S#, C#, G}, R2 = {C#, TN, TS} 是否为3NF。</font></p>
</blockquote>
<br/>
<p><font color = brown size = 4>求解方法：</font></p>
<ul>
<li>
<p>在关系模式R1={S#,C#,G}，候选关键字是(S#,C#)，主属性是S#,C#，非主属性是G，函数依赖为(S#,C#)→G。  由于R1中不存在非主属性对候选关键字的传递依赖，所以关系模式R1是3NF。</p>
</li>
<li>
<p>在关系模式R2={C#,TN,TS}，候选关键字是C#，主属性是C#，非主属性是TN,TS，函数依赖为C#→TN，TN→TS。由于R2中存在非主属性对候选关键字的传递依赖C# ,TS，所以关系模式R2不是3NF。</p>
<p><font color = red>可以把关系R2无损联接地分解成两个3NF的关系模式：</font></p>
<p>ρ={R3,R4}，R3={C#,TN}，R4={TN,TS}。</p>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = green size = 4>示例2：</font></p>
<blockquote>
<p><font color = blue >若关系模式SD（SNO，SNAME，DNO，DNAME，LOCATION） 各属性分别代表学号，<br>
姓名，所在系，系名称，系地址。 判断关系模式SD是否为3NF。</font></p>
</blockquote>
<br/>
<p><font color = brown size = 4>求解方法：</font></p>
<ul>
<li>关键字SNO决定各个属性。由于是单个关键字，没有部分依赖的问题，是2NF。
<ul>
<li><font color = brown>原因：</font>关系中存在传递依赖造成的。关键字 SNO 对 LOCATION 函数决定是通过传递依赖:SNO -&gt; DNO，及DNO -&gt; LOCATION实现的。也就是说，SNO不直接决定非主属性LOCATION，不是3NF。</li>
</ul>
</li>
<li><font color = brown>解决目的：</font>每个关系模式中不能留有传递依赖。
<ul>
<li><font color = brown>解决方法：</font>分为两个关系 S（SNO，SNAME，DNO），D（DNO，DNAME，LOCATION）</li>
</ul>
</li>
</ul>
<br/>
<blockquote>
<p><font color = red>注意：</font></p>
<ol>
<li>关系S中<span style="background: linear-gradient(to right, #f2994a, #f2c94c);">不能没有外关键字DNO</span>；否则两个关系之间失去联系；</li>
<li>分解为3NF时注意保留外关键字。</li>
</ol>
</blockquote>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = blue size = 4>Boyce-Codd范式(BCNF)</font><font color = red size = 4>(3NF基础上去除主属性对于候选关键字的传递依赖)</font></p>
<blockquote>
<p>如果关系模式R为<span style="background: linear-gradient(to right, #74ebd5, #acb6e5);">1NF</span>，并且R中的每一个函数依赖X→Y(YÏX),必有X是R的超关键字，则称R是Boyce-Codd范式的，简记为BCNF。</p>
</blockquote>
<br/>
<ul>
<li>
<p><font color = green size =4>BCNF特性：</font></p>
<blockquote>
<ol>
<li>所有非主属性对键是完全函数依赖；</li>
<li>所有主属性对不包含它的键是完全函数依赖；</li>
<li>没有属性完全函数依赖于非键的任何属性组合</li>
<li><span style="background: linear-gradient(to right, #f2994a, #f2c94c);"><font color = dark>综上即为</font></span>：<font color = green >消除了主属性对于候选关键字的部分和传递函数依赖；</font></li>
</ol>
</blockquote>
<br/>
<blockquote>
<p>与2NF,3NF的定义不同，BCNF的定义直接建立在1NF的基础上。但实质上BCNF是3NF的改进形式。3NF仅考虑了非主属性对键的依赖情况，<font color = brown>BCNF把主属性对键的依赖情况也包括进去。</font>BCNF要求满足的条件比3NF所要求的更高。<font color = brown>如果关系模式R是BCNF的，那么R必定是3NF</font>，反之，则不一定成立。</p>
</blockquote>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = green size = 4>示例1：</font></p>
<blockquote>
<p><font color = blue >续前例R（学号S#, 课程号C#, 成绩G, 任课教师TN, 教师专长TS）,判断两个3NF关系模式R3 = {C#, TN},R4 = {TN, TS}是否为BCNF。</font></p>
</blockquote>
<br/>
<p><font color = brown size = 4>求解方法：</font></p>
<ul>
<li>
<p>在关系模式R3中有函数依赖C#→TN，决定因素C#是R3的键；</p>
<p>在关系模式R4中有函数依赖TN→TS，决定因素TN是R4的键；</p>
<p>R3,R4都满足BCNF的定义，所以，这两个关系模式都是BCNF。</p>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = green size = 4>示例2：</font></p>
<blockquote>
<p><font color = blue >配件管理关系模式 WPE（WNO，PNO，ENO，QNT）分别表仓库号，配件号，职工号，数量。</font></p>
<p><font color = blue >有以下条件:</font> <br>
a.一个仓库有多个职工。<br>
b.一个职工仅在一个仓库工作。<br>
c.每个仓库里一种型号的配件由专人负责，但一个人可以管理几种配件。<br>
d.同一种型号的配件可以分放在几个仓库中。</p>
</blockquote>
<br/>
<p><font color = brown size = 4>求解方法：</font></p>
<ul>
<li>
<p><font color = brown>分析：</font></p>
<p>由以上得 PNO 不能确定QNT，由组合属性（WNO，PNO）来决定，存在函数依赖（WNO，PNO） -&gt; QNT。由于每个仓库里的一种配件由专人负责，而一个人可以管理几种配件，所以有组合属性（WNO，PNO）才能确定负责人，有<font color = red>（WNO，PNO）-&gt; ENO</font>。因为 一个职工仅在一个仓库工作，有<font color = red>ENO -&gt; WNO</font>。由于每个仓库里的一种配件由专人负责，而一个职工仅在一个仓库工作，有 <font color = red>（ENO，PNO）-&gt; QNT</font>。</p>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = brown>候选关键字:</font></p>
<p>因为（WNO，PNO） -&gt; QNT，（WNO，PNO）-&gt; ENO ，因此 （WNO，PNO）可以决定整个元组，是一个候选关键字。根据ENO-&gt;WNO，（ENO，PNO）-&gt;QNT，故（ENO，PNO）也能决定整个元组，为另一个候选关键字。<font color = red>属性ENO，WNO，PNO 均为主属性</font>，只有一个非主属性QNT。它对任何一个候选关键字都是完全函数依赖的，并且是直接依赖，所以该关系模式是3NF。</p>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = brown>主属性:</font></p>
<p>因为ENO-&gt;WNO，主属性ENO是WNO的决定因素，但是它本身不是关键字，只是组合关键字的一部分。这就造成主属性WNO对另外一个候选关键字（ENO，PNO）的部分依赖，因为（ENO，PNO）-&gt; ENO，但反过来不成立，而ENO-&gt;WNO，故（ENO，PNO）-&gt; WNO 也是传递依赖。<br>
虽然没有非主属性对候选关键字的传递依赖，但<font color = red>存在主属性对候选关键字的传递依赖</font>，同样也会带来麻烦。如一个新职工分配到仓库工作，但暂时处于实习阶段，没有独立负责对某些配件的管理任务。由于缺少关键字的一部分PNO而无法插入到该关系中去。又如某个人改成不管配件了去负责安全，则在删除配件的同时该职工也会被删除。</p>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = brown>解决办法：</font></p>
<p>分成管理EP（ENO，PNO，QNT），关键字是（ENO，PNO）；工作EW（ENO，WNO），关键字是ENO</p>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = brown>缺点：</font></p>
<p>分解后函数依赖的保持性较差。如此例中，由于分解,函数依赖（WNO，PNO）-&gt; ENO 丢失了, 因而对原来的语义有所破坏。没有体现出每个仓库里一种部件由专人负责。有可能出现 一部件由两个人或两个以上的人来同时管理。因此，分解之后的关系模式降低了部分完整性约束。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<p><span style="background: linear-gradient(to right, #74ebd5, #acb6e5);"><font color = green size = 4>总结：</font></span></p>
<p><img data-src="https://image.zxkidea.top/1551857237283.png" alt="zxk"></p>
<br/>
<blockquote>
<p><span style="background: linear-gradient(to right, #f2994a, #f2c94c);"><font color = green size = 4>化简为BCNF：</font></span></p>
<ol>
<li><font color = green >先将关系模式化简为3NF；</font></li>
<li><font color = green >再找出所有候选关键字及其主属性；</font></li>
<li><font color = green >接着根据函数依赖关系判断是否存在主属性对候选关键字的传递依赖或部分依赖；</font></li>
<li><font color = green >最后将造成传递依赖或部分依赖的关系模式分解出去；</font></li>
</ol>
</blockquote>
<br/>
<h3 id="7-关系模式分解为范式的分解算法">7.关系模式分解为范式的分解算法</h3>
<h4 id="font-color-green-size-4-1）无损连接且保持函数依赖地分解R到3NF-font"><font color = green size = 4>1）无损连接且保持函数依赖地分解R到3NF</font></h4>
<ul>
<li>
<p><font color = blue size = 4>示例1：</font></p>
<blockquote>
<p>U = (A, B, C, D, E, G),  F = {BG-&gt;C，BD-&gt;E，DG-&gt;C，ADG-&gt;BC，AG-&gt;B，B-&gt;D}   若R不是3NF，将R分解为无损且保持函数依赖的3NF。</p>
</blockquote>
<br/>
<p><font color = red size = 4>求解方法：</font></p>
<p><font color = brown>1. 先求出候选码：</font></p>
<ul>
<li>分为L类，N类，R类；</li>
<li>按求候选码规则求得候选码为AG</li>
</ul>
<br/>
<p><font color = brown>2. 再求出最小依赖集F~m~：</font></p>
<ul>
<li>将F中的所有依赖右边化为单一元素</li>
<li>去掉F各函数依赖左边的冗余属性</li>
<li>去掉F中所有冗余依赖关系</li>
<li>求得F~m~ = {B-&gt;E，DG-&gt;C，AG-&gt;B，B-&gt;D}</li>
</ul>
<br/>
<p><font color = brown>3. 左部相同原则分组：</font></p>
<ul>
<li>对F~m~按具有相同左部的原则分组，然后<font color = green>左部∪右部。</font></li>
<li>U1 = B∪DE = BDE  ;  U2 = DGC ;  U3 = AGB</li>
</ul>
<br/>
<p><font color = brown>4. 看有没有包含关系，有的话，合并吸收。</font></p>
<ul>
<li>将R分解为ρ = { R1({B, D, E}，{B-&gt;E, B-&gt;D})，R2({C, D, G}，{DG-&gt;C})，R3({A, B, G}，{AG-&gt;B}) }</li>
<li>不存在包含关系</li>
</ul>
<br/>
<p><font color = brown>5. 看分的属性组里有没有包含码，包含了，就是无损且保持函数依赖的3NF，没有包含，就不是无损且保持函数依赖的3NF，就加一个分组，把码加进去。</font></p>
<ul>
<li>因为候选键AG在U3中，所以所求分解ρ具有无损连接性，并保持函数依赖，且每个子模式为3NF。</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = blue size = 4>示例2：</font></p>
<blockquote>
<p>U=(A, B, C, D, E) ,  F = {AB-&gt;C，C-&gt;B，D-&gt;E，D-&gt;C}   若R不是3NF，将R分解为无损且保持函数依赖的3NF。</p>
</blockquote>
<br/>
<p><font color = red size = 4>求解方法：</font></p>
<p><font color = brown>1. 先求出候选码：</font></p>
<ul>
<li>分为L类，N类，R类；</li>
<li>按求候选码规则求得候选码为AD</li>
</ul>
<br/>
<p><font color = brown>2. 再求出最小依赖集F~m~：</font></p>
<ul>
<li>将F中的所有依赖右边化为单一元素</li>
<li>去掉F各函数依赖左边的冗余属性</li>
<li>去掉F中所有冗余依赖关系</li>
<li>求得F~m~ = {AB-&gt;C，C-&gt;B，D-&gt;E，D-&gt;C}</li>
</ul>
<br/>
<p><font color = brown>3. 左部相同原则分组：</font></p>
<ul>
<li>对F~m~按具有相同左部的原则分组，然后<font color = green>左部∪右部。</font></li>
<li>U1 = ABC  ;   U2 = BC  ; U3 = DCE</li>
</ul>
<br/>
<p><font color = brown>4. 看有没有包含关系，有的话，合并吸收。</font></p>
<ul>
<li>
<p>将R分解为ρ = { R1((A, B, C)，{AB-&gt;C})，R2((B, C)，{C-&gt;B})，R3((C, D, E)，{D-&gt;E, D-&gt;C}) }</p>
</li>
<li>
<p><font color = green>合并吸收：</font>ρ = { R1((A, B, C)，{AB-&gt;C, C-&gt;B})，R2((C, D, E)，{D-&gt;E, D-&gt;C}) }</p>
</li>
</ul>
<br/>
<p><font color = brown>5. 看分的属性组里有没有包含码，包含了，就是无损且保持函数依赖的3NF，没有包含，就不是无损且保持函数依赖的3NF，就加一个分组，把码加进去。</font></p>
<ul>
<li>不是无损连接，添加码。</li>
<li>R3((A, D)，{∅})</li>
<li>所以ρ = { R1((A, B, C)，{AB-&gt;C，C-&gt;B})，R2((C, D, E)，{D-&gt;E, D-&gt;C})，R3((A, D)，{∅}) }</li>
</ul>
</li>
</ul>
<br/>
<h4 id="font-color-green-size-4-2）无损联接地分解R到BCNF-font"><font color = green size = 4>2）无损联接地分解R到BCNF</font></h4>
<ul>
<li>
<p><font color = blue size = 4>示例：</font></p>
<blockquote>
<p>关系模式R&lt;U, F&gt;, 有U = {A, B, C, D, E, G}, F = {B-&gt;G, CE-&gt;B, C-&gt;A, CE-&gt;G, B-&gt;D, C-&gt;D}</p>
</blockquote>
<br/>
<p><font color = red size = 4>求解方法：</font></p>
<p><font color = brown>1. 先求出候选码：</font></p>
<ul>
<li>
<p>分为L类，N类，R类；</p>
</li>
<li>
<p>按求候选码规则求得候选码为CE</p>
</li>
</ul>
<br/>
<p><font color = brown>2. 再求出最小依赖集F~m~：</font></p>
<ul>
<li>F~m~ = {B-&gt;G, CE-&gt;B, C-&gt;A, B-&gt;D, C-&gt;D}。</li>
</ul>
<br/>
<p><font color = brown>3. 循环分解函数依赖集：</font></p>
<ul>
<li>开始找左部不包含CE的关系模式，第一个为B-&gt;G，</li>
<li>将其分为R1 = {(BG), {B-&gt;G}} 与R2 = {(ABCDE), {CE-&gt;B, C-&gt;A, B-&gt;D, C-&gt;D}}。</li>
<li>注意G不能出现在R2中，要根据与G相关的关系模式进行替代。</li>
</ul>
<br/>
<ul>
<li>求R1与R2的最小函数依赖集，步骤均是按照上述算法严格进行的。</li>
<li>R1，R2最小函数依赖集是其本身。</li>
</ul>
<br/>
<ul>
<li>然后再进行分解，R1符合BCNF，继续分解R2：</li>
<li>B-&gt;D,左部不含码，于是分解为R2={(BD), {B-&gt;D}}，R3={(ABCE)，{CE-&gt;B, C-&gt;A}}。</li>
</ul>
<br/>
<ul>
<li>R2，R3的最小函数依赖集均是其本身。</li>
</ul>
<br/>
<ul>
<li>于是BCNF分解的最后结果为{(BG), (BD), (ABCE)}。</li>
</ul>
</li>
</ul>

    </div>

    
    
    

    
    <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
    
        <div class="reward-container">
  <div>大爷，赏点？</div>
  <button disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="Rocky Zhou 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.png" alt="Rocky Zhou 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Rocky Zhou
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://blog.zxkidea.top/posts/780f9bb4.html" title="DatabaseNotes-Ch5,6">https://blog.zxkidea.top/posts/780f9bb4.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag"><i class="fa fa-tag"></i> 数据库</a>
              <a href="/tags/%E8%80%83%E7%A0%94/" rel="tag"><i class="fa fa-tag"></i> 考研</a>
              <a href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag"><i class="fa fa-tag"></i> 笔记</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/posts/928c862a.html" rel="prev" title="DatabaseNotes-Ch3,4">
      <i class="fa fa-chevron-left"></i> DatabaseNotes-Ch3,4
    </a></div>
      <div class="post-nav-item">
    <a href="/posts/6244050a.html" rel="next" title="关系模式范式分解教程（3NF与BCNF口诀）">
      关系模式范式分解教程（3NF与BCNF口诀） <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>

  
  
  



  </div>


          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Ch5-Embedded-SQL-（嵌入式SQL）"><span class="nav-text">Ch5. Embedded SQL （嵌入式SQL）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-定义"><span class="nav-text">1. 定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-特性"><span class="nav-text">2. 特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-和交互式SQL的对比"><span class="nav-text">3. 和交互式SQL的对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-宿主语言如何与数据库连接"><span class="nav-text">4. 宿主语言如何与数据库连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-如何将宿主语言的变量传递给SQL语句"><span class="nav-text">5. 如何将宿主语言的变量传递给SQL语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-SQL语句如何执行"><span class="nav-text">6. SQL语句如何执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-事务"><span class="nav-text">7. 事务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-如何将SQL检索到的结构传递回宿主程序进行处理"><span class="nav-text">8. 如何将SQL检索到的结构传递回宿主程序进行处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-数据库的删除与更新"><span class="nav-text">9. 数据库的删除与更新</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-宿主程序如何知道SQL语句的执行状态，是否发生错误"><span class="nav-text">10. 宿主程序如何知道SQL语句的执行状态，是否发生错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-动态SQL-依据条件动态构造SQL语句，但欲访问的表名和字段对编程者是已知的"><span class="nav-text">11. 动态SQL,依据条件动态构造SQL语句，但欲访问的表名和字段对编程者是已知的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-数据字典（Data-dictionary）"><span class="nav-text">12. 数据字典（Data dictionary）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Ch6-Database-Design"><span class="nav-text">Ch6. Database Design</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-E-R概念简介"><span class="nav-text">1.E-R概念简介</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#font-color-blue-size-4-1-定义：-font"><span class="nav-text">1) 定义：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#font-color-blue-size-4-2-E-R模型的基本要素-font"><span class="nav-text">2) E-R模型的基本要素: </span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#font-color-blue-size-4-3-E-R图像关系模型的转换：-font"><span class="nav-text">3) E-R图像关系模型的转换：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#font-color-blue-4）关联基数-font"><span class="nav-text">4）关联基数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#font-color-red-size-4-5-用例-将下面的E-R图转换为关系模式，关系的码用下划线标出-：-font"><span class="nav-text">5) 用例 (将下面的E-R图转换为关系模式，关系的码用下划线标出)：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-函数依赖-FD"><span class="nav-text">2.函数依赖(FD)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#font-color-blue-size-4-1）-定义-font"><span class="nav-text">1） 定义: </span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#font-color-blue-size-4-2）完全函数依赖和部分函数依赖-font"><span class="nav-text">2）完全函数依赖和部分函数依赖</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#font-color-blue-size-4-3）平凡函数依赖和非平凡函数依赖-font"><span class="nav-text">3）平凡函数依赖和非平凡函数依赖</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#font-color-blue-size-4-4）传递函数依赖-font"><span class="nav-text">4）传递函数依赖</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-多值依赖"><span class="nav-text">3.多值依赖</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#font-color-blue-size-4-1-定义-font"><span class="nav-text">1) 定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#font-color-blue-size-4-2-示例：-font"><span class="nav-text">2) 示例：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#font-color-blue-size-4-3）性质：-font"><span class="nav-text">3）性质：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-函数依赖的推理规则"><span class="nav-text">4.函数依赖的推理规则</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#font-color-blue-size-4-1-逻辑蕴涵-font"><span class="nav-text">1) 逻辑蕴涵</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#font-color-blue-size-4-2-F的闭包F-font"><span class="nav-text">2) F的闭包F^+^ </span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#font-color-blue-size-4-3-Armstrong-公理-font"><span class="nav-text">3) Armstrong 公理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#font-color-blue-size-4-4-Armstrong公理系统的有效性和完备性-font"><span class="nav-text">4) Armstrong公理系统的有效性和完备性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#font-color-blue-size-4-5-属性集的闭包-font"><span class="nav-text">5) 属性集的闭包</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#font-color-blue-size-4-6-极小函数依赖集（最小函数依赖集）-font"><span class="nav-text">6) 极小函数依赖集（最小函数依赖集）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#font-color-blue-size-4-7-超码，候选码与主码-font"><span class="nav-text">7) 超码，候选码与主码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#font-color-blue-size-4-8-求解候选码-font"><span class="nav-text">8) 求解候选码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-关系模式的分解"><span class="nav-text">5.关系模式的分解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#font-color-blue-1-无损联接-font"><span class="nav-text">1) 无损联接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#font-color-blue-2-保持函数依赖-font"><span class="nav-text">2) 保持函数依赖</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-关系模式的范式-NF"><span class="nav-text">6.关系模式的范式(NF)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#font-color-green-size-4-1）定义-font"><span class="nav-text">1）定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#font-color-green-size-4-2）各类范式及其说明-font"><span class="nav-text">2）各类范式及其说明</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-关系模式分解为范式的分解算法"><span class="nav-text">7.关系模式分解为范式的分解算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#font-color-green-size-4-1）无损连接且保持函数依赖地分解R到3NF-font"><span class="nav-text">1）无损连接且保持函数依赖地分解R到3NF</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#font-color-green-size-4-2）无损联接地分解R到BCNF-font"><span class="nav-text">2）无损联接地分解R到BCNF</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Rocky Zhou"
      src="/images/cat.jpg">
  <p class="site-author-name" itemprop="name">Rocky Zhou</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="sidebar-button motion-element">
    <a onclick="tidioChatApi.open();"><i class="fa fa-comment"></i>
    Chat
  </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Joyrocky" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Joyrocky" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:kevin009008@outlook.com" title="E-Mail → mailto:kevin009008@outlook.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/2932742182/" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;2932742182&#x2F;" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.facebook.com/profile.php?id=100011389486139" title="FB Page → https:&#x2F;&#x2F;www.facebook.com&#x2F;profile.php?id&#x3D;100011389486139" rel="noopener" target="_blank"><i class="fa fa-fw fa-facebook"></i>FB Page</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-fw fa-rss"></i>RSS</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        
  <div class="beian"><a href="http://www.beian.miit.gov.cn/" rel="noopener" target="_blank">苏ICP备19021225号 </a>
  </div>

<div class="copyright">
  
  &copy; 2018 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Rocky Zhou</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">146k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">2:13</span>
</div>
  <div class="addthis_inline_share_toolbox">
    <script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e19b902cd7cfa55" async="async"></script>
  </div>

        
<div class="busuanzi-count">
  <script pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.getAttribute('pjax') !== null) {
      element.setAttribute('pjax', '');
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="/js/local-search.js"></script>






  <script src="//code.tidio.co/wzwxqvlketmhjegc6hongvrouugosmo5.js"></script>







    <div id="pjax">
  

  
      
<script type="text/x-mathjax-config">
    MathJax.Ajax.config.path['mhchem'] = '//cdn.jsdelivr.net/npm/mathjax-mhchem@3';

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        extensions: ['[mhchem]/mhchem.js'],
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
</script>
<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML', () => {
    MathJax.Hub.Typeset();
  }, window.MathJax);
</script>

    

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el: '#valine-comments',
      verify: false,
      notify: false,
      appId: 'lovislz0MGuQcCOyeHoO0dsC-gzGzoHsz',
      appKey: 'sGUVwBk9sdrntxYQJaP0gw6G',
      placeholder: "Just go go",
      avatar: 'mp',
      meta: guest,
      pageSize: '10' || 10,
      visitor: false,
      lang: 'zh-cn' || 'zh-cn',
      path: location.pathname,
      recordIP: false,
      serverURLs: ''
    });
  }, window.Valine);
});
</script>

    </div>

  <script type="text/javascript" src="/lib/clipboard/clipboard.js"></script>
<script type="text/javascript" src="/js/custom.js"></script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":220,"height":325,"hOffset":-20,"vOffset":-30},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.2}});</script></body>
</html>
