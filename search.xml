<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CentOS7安装使用VNC远程桌面</title>
    <url>/posts/64145778.html</url>
    <content><![CDATA[<h1>CentOS7安装使用VNC远程桌面</h1>
<h2 id="1-在Linux服务器上安装配置VNC-server">1.在Linux服务器上安装配置VNC-server</h2>
<h3 id="1-1-配置vnc-server">1.1 配置vnc-server</h3>
<h4 id="1-1-1-安装VNC服务端并设置VNC连接密码">1.1.1 安装VNC服务端并设置VNC连接密码</h4>
<p>首先安装vnc的server（若没有安装的话）；需要root权限</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">su</span><br><span class="line">yum install tigervnc tigervnc-server</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>登录非root用户，如admin；设置vncpassword</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vncpasswd </span><br><span class="line"><span class="comment">#Password:!d0802</span></span><br><span class="line"><span class="comment">#Verify:!d0802</span></span><br><span class="line"><span class="comment"># 注意：would you like to enter a viwer-only password(y/n)? y</span></span><br></pre></td></tr></table></figure>
<h4 id="1-1-2-拷贝并修改配置文件">1.1.2 拷贝并修改配置文件</h4>
<p>安装完成后开始配置, 将模板配置文件拷贝至配置文件目录下<code>/etc/systemmd/system/</code>, 如果是多用户，则每个用户拷贝一份，其中<code>@:1.service</code>中的数字<code>1</code>对应VNC服务端口<code>5901</code>，数字<code>2</code>对应端口<code>5902</code>根据自己的需求设置即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 复制配置模板文件</span></span><br><span class="line"><span class="comment"># 需要root权限</span></span><br><span class="line">su</span><br><span class="line">cp /lib/systemd/system/vncserver@.service /etc/systemd/system/vncserver@:1.service</span><br><span class="line"><span class="comment"># 编辑配置文件</span></span><br><span class="line">vi /etc/systemd/system/vncserver@:1.service</span><br></pre></td></tr></table></figure>
<p>进入service文件，按下面图片的方式更改：</p>
<p><img data-src="https://image.zxkidea.top/blog/20201122/r7GNK8BpVt5H.png?imageslim" alt="zxk"></p>
<h4 id="1-1-3-重新加载配置文件">1.1.3 重新加载配置文件</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重新加载systemctl文件</span></span><br><span class="line">systemctl deamon-reload</span><br></pre></td></tr></table></figure>
<h4 id="1-1-4-启动VNC并设置开机启动">1.1.4 启动VNC并设置开机启动</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动VNC服务</span></span><br><span class="line">systemctl start vncserver@:1.service</span><br><span class="line"><span class="comment"># 设置开机启动</span></span><br><span class="line">systemctl <span class="built_in">enable</span> vncserver@:1.service</span><br></pre></td></tr></table></figure>
<h4 id="1-1-5-添加防火墙例外">1.1.5 添加防火墙例外</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加 VNC 服务例外</span></span><br><span class="line">firewall-cmd --permanent --add-service vnc-server</span><br><span class="line"><span class="comment"># 添加 5901 端口例外</span></span><br><span class="line">firewall-cmd --permanent --add-port=5901/tcp</span><br><span class="line"><span class="comment"># 重启防火墙</span></span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>
<h4 id="1-1-6-创建VNC-service">1.1.6 创建VNC service</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定1920x1080分辨率的窗口</span></span><br><span class="line">vncserver -geometry 1920x1080</span><br><span class="line"><span class="comment"># 查看vnc-server的状态</span></span><br><span class="line">vncserver -list</span><br></pre></td></tr></table></figure>
<h2 id="2-在Windows下安装配置VNC服务">2. 在Windows下安装配置VNC服务</h2>
<p>在https://www.realvnc.com/en/connect/download/viewer/windows/下下载Windows的客户端，然后按照指示完成安装：</p>
<p><img data-src="https://image.zxkidea.top/blog/20201122/8Hh59fFehsCx.png?imageslim" alt="zxk"></p>
<h2 id="3-在Windows下远程连接服务器">3. 在Windows下远程连接服务器</h2>
<ol>
<li>
<p>打开VNC-Viewer，Files——&gt;New Connection，输入VNC Server的IP地址，一个服务器上可以开启多个VNC服务，使用数字来标识，我们要连接第一个那就要输入例如：10.10.65.1:1，加密方式默认就可以了，Name的名字随意取即可。</p>
<p><img data-src="https://image.zxkidea.top/blog/20201122/eLysVDsuNfsT.png?imageslim" alt="zxk"></p>
</li>
<li>
<p>双击小电脑即可进行连接，弹出对话框，输入之前vncpasswd设置的密码即可；点击连接，就可以远程连接CentOS桌面，再输入系统密码进入，如下图所示：</p>
<p><img data-src="https://image.zxkidea.top/blog/20201122/5ItrB5WfdnSE.png?imageslim" alt="zxk"></p>
</li>
<li>
<p>若远程桌面模糊，在Properties中设置Picture quality为Medium即可，此时需要较为稳定的网速，不然容易出现卡顿！</p>
</li>
</ol>
<h2 id="4-VNC与Anaconda冲突问题">4. VNC与Anaconda冲突问题</h2>
<p><font color = red>问题：</font>Could not make bus activated clients aware of XDG_CURRENT_DESKTOP=GNOME environment variable: Could not connect: Connection refused</p>
<blockquote>
<p>查看用户services启动的错误日志：如，cat /root/.vnc/kevin:1.log</p>
<p>** (process:31798): WARNING **: 21:56:03.861: Could not make bus activated clients aware of XDG_CURRENT_DESKTOP=GNOME environment variable:<br>
Could not connect: Connection refused</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">原因：dbus-daemon存在冲突。</span><br><span class="line">因为root系统环境中装有anaconda，它的bin目录中的dbus-daemon会与系统自带的dbus-daemon冲突。</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@kevin ~]<span class="comment"># find / -name "dbus-daemon"</span></span><br><span class="line">/usr/bin/dbus-daemon</span><br><span class="line">/data/anaconda3/bin/dbus-daemon</span><br><span class="line">/data/anaconda3/pkgs/dbus-1.13.6-h746ee38_0/bin/dbus-daemon</span><br></pre></td></tr></table></figure>
<p><font color=red>解决办法：</font>vnc和anaconda冲突解决方法：could not make bus activated clients aware of XDG_CURRENT_DESKTOP=GNOME envi；</p>
<p>1、注释掉~/.bashrc中anaconda相关的环境变量设置；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># &gt;&gt;&gt; conda initialize &gt;&gt;&gt;</span></span><br><span class="line"><span class="comment"># !! Contents within this block are managed by 'conda init' !!</span></span><br><span class="line">__conda_setup=<span class="string">"<span class="variable">$('/usr/local/anaconda3/bin/conda' 'shell.bash' 'hook' 2&gt; /dev/null)</span>"</span></span><br><span class="line"><span class="keyword">if</span> [ $? -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">eval</span> <span class="string">"<span class="variable">$__conda_setup</span>"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span> [ -f <span class="string">"/usr/local/anaconda3/etc/profile.d/conda.sh"</span> ]; <span class="keyword">then</span></span><br><span class="line">        . <span class="string">"/usr/local/anaconda3/etc/profile.d/conda.sh"</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">export</span> PATH=<span class="string">"/usr/local/anaconda3/bin:<span class="variable">$PATH</span>"</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">unset</span> __conda_setup</span><br><span class="line"><span class="comment"># &lt;&lt;&lt; conda initialize &lt;&lt;&lt;</span></span><br></pre></td></tr></table></figure>
<p>2.执行source ~/.bashrc</p>
<p>3.重启一个xshell连接，启动VNC</p>
<p>4.还原~/.bashrc中的注释掉的anaconda相关的环境变量</p>
<p>5.再次执行source ~/.bashrc</p>
]]></content>
      <categories>
        <category>CentOS配置</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>资料整理</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL语句技巧</title>
    <url>/posts/8343e966.html</url>
    <content><![CDATA[<h2 id="一、常用函数大全">一、常用函数大全</h2>
<h3 id="1-数学函数">1. 数学函数</h3>
<ul>
<li><code>ABS(x)</code>  返回x的绝对值</li>
<li><code>BIN(x)</code>  返回x的二进制（OCT返回八进制，HEX返回十六进制）</li>
<li><code>CEILING(x)</code>  返回大于x的最小整数值——<span style="background: linear-gradient(to right, #74ebd5, #acb6e5);">向上取整</span></li>
<li><code>EXP(x) </code> 返回值e（自然对数的底）的x次方</li>
</ul>
<a id="more"></a>
<ul>
<li><code>FLOOR(x)</code>  返回小于x的最大整数值——<span style="background: linear-gradient(to right, #74ebd5, #acb6e5);">向下取整</span></li>
<li><code>GREATEST(x1,x2,...,xn)</code>返回集合中最大的值</li>
<li><code>LEAST(x1,x2,...,xn) </code>   返回集合中最小的值</li>
<li><code>LN(x)  </code>         返回x的自然对数</li>
<li><code>LOG(x,y)</code>返回x的以y为底的对数</li>
<li><code>MOD(x,y) </code>        返回x/y的模（余数）</li>
<li><code>PI()</code>返回pi的值（圆周率）</li>
<li><code>RAND()</code>返回０到１内的随机值,可以通过提供一个参数(种子)使RAND()随机数生成器生成一个指定的值。</li>
<li><code>ROUND(x,y)</code>返回参数x的<span style="background: linear-gradient(to right, #f2994a, #f2c94c);">四舍五入的有y位小数</span>的值</li>
<li><code>SIGN(x) </code>返回代表数字x的符号的值</li>
<li><code>SQRT(x) </code>返回一个数的平方根</li>
<li><code>POWER(Value,N)</code>— <span style="background: linear-gradient(to right, #f2994a, #f2c94c);">返回Value的N次方</span>；<code>POWER(Value,1/N)</code>— <span style="background: linear-gradient(to right, #f2994a, #f2c94c);">返回Value的N次方</span></li>
<li><code>TRUNCATE(x,y) </code>      返回数字x截短为y位小数的结果</li>
</ul>
<br/>
<h3 id="2-聚合函数-常用于GROUP-BY从句的SELECT查询中">2. 聚合函数(常用于GROUP BY从句的SELECT查询中)</h3>
<ul>
<li><code>AVG(col)</code>返回指定列的平均值</li>
<li><code>COUNT(col)</code>返回指定列中非NULL值的个数</li>
<li><code>MIN(col)</code>返回指定列的最小值</li>
<li><code>MAX(col)</code>返回指定列的最大值</li>
<li><code>SUM(col)</code>返回指定列的所有值之和</li>
<li><code>GROUP_CONCAT(col) </code>返回由属于一组的列值连接组合而成的结果</li>
</ul>
<br/>
<h3 id="3-字符串函数">3. 字符串函数</h3>
<ul>
<li><code>ASCII(char)</code>返回字符的ASCII码值</li>
<li><code>BIT_LENGTH(str)</code>返回字符串的比特长度</li>
<li><code>CONCAT(s1,s2...,sn)</code>将s1,s2…,sn连接成字符串</li>
<li><code>CONCAT_WS(sep,s1,s2...,sn)</code>将s1,s2…,sn连接成字符串，并用sep字符间隔</li>
<li><code>INSERT(str,x,y,instr) </code>将字符串str从第x位置开始，y个字符长的子串替换为字符串instr，返回结果</li>
<li><code>FIND_IN_SET(str,list)</code>分析逗号分隔的list列表，如果发现str，返回str在list中的位置</li>
<li><code>LCASE(str)或LOWER(str) </code>返回将字符串str中所有字符改变为小写后的结果</li>
<li><code>LEFT(str,x)</code>返回字符串str中最左边的x个字符</li>
<li><code>LENGTH(s)</code>返回字符串str中的字符数</li>
<li><code>LTRIM(str) </code>从字符串str中切掉开头的空格</li>
<li><code>POSITION(substr,str)</code> 返回子串substr在字符串str中第一次出现的位置</li>
<li><code>QUOTE(str) </code>用反斜杠转义str中的单引号</li>
<li><code>REPEAT(str,srchstr,rplcstr)</code>返回字符串str重复x次的结果</li>
<li><code>REVERSE(str) </code>返回颠倒字符串str的结果</li>
<li><code>RIGHT(str,x) </code>返回字符串str中最右边的x个字符</li>
<li><code>RTRIM(str)</code> 返回字符串str尾部的空格</li>
<li><code>STRCMP(s1,s2)</code>比较字符串s1和s2</li>
<li><code>TRIM(str)</code>去除字符串首部和尾部的所有空格</li>
<li><code>UCASE(str)</code>或<code>UPPER(str) </code>返回将字符串str中所有字符转变为大写后的结果</li>
</ul>
<br/>
<h3 id="4-日期和时间函数">4. 日期和时间函数</h3>
<ul>
<li><code>CURDATE()</code>或<code>CURRENT_DATE() </code>返回当前的日期</li>
<li><code>CURTIME()</code>或<code>CURRENT_TIME() </code>返回当前的时间</li>
<li><code>DATE_ADD(date,INTERVAL int keyword)</code>返回日期date加上间隔时间int的结果(int必须按照关键字进行格式化), <span style="background: linear-gradient(to right, #74ebd5, #acb6e5);">keyword可为任意时间间隔类型</span>；如：<code>SELECT DATE_ADD(CURRENT_DATE,INTERVAL 6 MONTH);</code></li>
<li><code>DATE_FORMAT(date,fmt) </code> 依照指定的fmt格式格式化日期date值，fmt格式；常用：’%Y-%m-%d’ , 年-月-日</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">格式</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">%a</td>
<td style="text-align:left">缩写星期名</td>
</tr>
<tr>
<td style="text-align:left">%b</td>
<td style="text-align:left">缩写月名</td>
</tr>
<tr>
<td style="text-align:left">%c</td>
<td style="text-align:left">月，数值</td>
</tr>
<tr>
<td style="text-align:left">%D</td>
<td style="text-align:left">带有英文前缀的月中的天</td>
</tr>
<tr>
<td style="text-align:left">%d</td>
<td style="text-align:left">月的天，数值(00-31)</td>
</tr>
<tr>
<td style="text-align:left">%e</td>
<td style="text-align:left">月的天，数值(0-31)</td>
</tr>
<tr>
<td style="text-align:left">%f</td>
<td style="text-align:left">微秒</td>
</tr>
<tr>
<td style="text-align:left">%H</td>
<td style="text-align:left">小时 (00-23)</td>
</tr>
<tr>
<td style="text-align:left">%h</td>
<td style="text-align:left">小时 (01-12)</td>
</tr>
<tr>
<td style="text-align:left">%I</td>
<td style="text-align:left">小时 (01-12)</td>
</tr>
<tr>
<td style="text-align:left">%i</td>
<td style="text-align:left">分钟，数值(00-59)</td>
</tr>
<tr>
<td style="text-align:left">%j</td>
<td style="text-align:left">年的天 (001-366)</td>
</tr>
<tr>
<td style="text-align:left">%k</td>
<td style="text-align:left">小时 (0-23)</td>
</tr>
<tr>
<td style="text-align:left">%l</td>
<td style="text-align:left">小时 (1-12)</td>
</tr>
<tr>
<td style="text-align:left">%M</td>
<td style="text-align:left">月名</td>
</tr>
<tr>
<td style="text-align:left">%m</td>
<td style="text-align:left">月，数值(00-12)</td>
</tr>
<tr>
<td style="text-align:left">%p</td>
<td style="text-align:left">AM 或 PM</td>
</tr>
<tr>
<td style="text-align:left">%r</td>
<td style="text-align:left">时间，12-小时（hh:mm:ss AM 或 PM）</td>
</tr>
<tr>
<td style="text-align:left">%S</td>
<td style="text-align:left">秒(00-59)</td>
</tr>
<tr>
<td style="text-align:left">%s</td>
<td style="text-align:left">秒(00-59)</td>
</tr>
<tr>
<td style="text-align:left">%T</td>
<td style="text-align:left">时间, 24-小时 (hh:mm:ss)</td>
</tr>
<tr>
<td style="text-align:left">%U</td>
<td style="text-align:left">周 (00-53) 星期日是一周的第一天</td>
</tr>
<tr>
<td style="text-align:left">%u</td>
<td style="text-align:left">周 (00-53) 星期一是一周的第一天</td>
</tr>
<tr>
<td style="text-align:left">%V</td>
<td style="text-align:left">周 (01-53) 星期日是一周的第一天，与 %X 使用</td>
</tr>
<tr>
<td style="text-align:left">%v</td>
<td style="text-align:left">周 (01-53) 星期一是一周的第一天，与 %x 使用</td>
</tr>
<tr>
<td style="text-align:left">%W</td>
<td style="text-align:left">星期名</td>
</tr>
<tr>
<td style="text-align:left">%w</td>
<td style="text-align:left">周的天 （0=星期日, 6=星期六）</td>
</tr>
<tr>
<td style="text-align:left">%X</td>
<td style="text-align:left">年，其中的星期日是周的第一天，4 位，与 %V 使用</td>
</tr>
<tr>
<td style="text-align:left">%x</td>
<td style="text-align:left">年，其中的星期一是周的第一天，4 位，与 %v 使用</td>
</tr>
<tr>
<td style="text-align:left">%Y</td>
<td style="text-align:left">年，4 位</td>
</tr>
<tr>
<td style="text-align:left">%y</td>
<td style="text-align:left">年，2 位</td>
</tr>
</tbody>
</table>
<ul>
<li><code>DATE_SUB(date,INTERVAL int keyword)</code>返回日期date减去间隔时间int的结果(int必须按照关键字进行格式化), <span style="background: linear-gradient(to right, #74ebd5, #acb6e5);">keyword可为任意时间间隔类型</span>；如：<code>SELECT DATE_SUB(CURRENT_DATE,INTERVAL 6 MONTH);</code></li>
<li><code>DAYOFWEEK(date)</code>  返回date所代表的一星期中的第几天(1~7)</li>
<li><code>DAYOFMONTH(date) </code> 返回date是一个月的第几天(1~31)</li>
<li><code>DAYOFYEAR(date)</code>  返回date是一年的第几天(1~366)</li>
<li><code>DAYNAME(date)</code>  返回date的<span style="background: linear-gradient(to right, #74ebd5, #acb6e5);">星期名</span>(Sun…)，如：<code>SELECT DAYNAME(CURRENT_DATE);</code></li>
<li><code>FROM_UNIXTIME(ts,fmt) </code> 根据指定的fmt格式，格式化UNIX时间戳ts</li>
<li><code>HOUR(time) </code> 返回time的小时值(0~23)</li>
<li><code>MINUTE(time) </code> 返回time的分钟值(0~59)</li>
<li><code>MONTH(date) </code> 返回date的月份值(1~12)</li>
<li><code>MONTHNAME(date) </code> 返回date的<span style="background: linear-gradient(to right, #74ebd5, #acb6e5);">月份名</span>(Jan…)，如：<code>SELECT MONTHNAME(CURRENT_DATE);</code></li>
<li><code>NOW() </code>  返回当前的日期和时间</li>
<li><code>QUARTER(date) </code> 返回date在一年中的季度(1~4)，如<code>SELECT QUARTER(CURRENT_DATE);</code></li>
<li><code>WEEK(date) </code> 返回日期date为一年中第几周(0~53)</li>
<li><code>YEAR(date) </code> 返回日期date的年份(1000~9999)</li>
<li><code>EXTRACT(date) </code> Extract() 函数除了没有date(),time() 的功能外，其他功能一应具全。</li>
<li><code>period_add(P,N) </code>日期加/减去N月。</li>
<li><code>period_diff(P1,P2)</code> 日期 P1-P2，返回 N 个月</li>
<li><code>datediff(date1,date2)</code> 两个日期相减 date1 - date2，返回天数</li>
<li><code>TIMEDIFF(time1,time2)</code> 两个日期相减 time1 - time2，返回 TIME 差值</li>
<li><code>TIMESTAMPDIFF(DAY/MONTH/YEAR/WEEK/MINUTE,time1,time2)</code> 两个日期相减 time1 - time2，<span style="background: linear-gradient(to right, #f2994a, #f2c94c);">返回相应日期类型</span>的差值</li>
<li><code>TO_DAYS(date)</code> 给出一个日期 date，返回一个天数(从 0 年开始的天数)</li>
<li><code>FROM_DAYS(N)</code> 给出一个天数 N，返回一个 DATE 值</li>
</ul>
<br/>
<p><font color = green size = 4>一些示例：</font></p>
<p><font color = blue>1. 返回两个日期值之间的差值(月数)：</font></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT PERIOD_DIFF(200302,199802);</span><br></pre></td></tr></table></figure>
<br/>
<p><font color = blue>2. 在Mysql中计算年龄：</font></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT DATE_FORMAT(FROM_DAYS(TO_DAYS(NOW())-TO_DAYS(birthday)),&#39;%Y&#39;)+0 AS age FROM employee;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><font color = red>注：</font><font color = green>此处利用to_days()将年龄转换为从0年经过的时间，再用date_format求出年份即为年龄。</font></p>
</blockquote>
<br/>
<p><font color = blue>3. EXTRACT()提取函数</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">EXTRACT</span>(<span class="keyword">YEAR</span> <span class="keyword">FROM</span> <span class="string">'2017-05-15 10:37:14.123456'</span>); <span class="comment">-- 年</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">EXTRACT</span>(<span class="keyword">MONTH</span> <span class="keyword">FROM</span> <span class="string">'2017-05-15 10:37:14.123456'</span>); <span class="comment">-- 月</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">EXTRACT</span>(YEAR_MONTH <span class="keyword">FROM</span> <span class="string">'2017-05-15 10:37:14.123456'</span>); <span class="comment">-- 年月</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">EXTRACT</span>(DAY_HOUR <span class="keyword">FROM</span> <span class="string">'2017-05-15 10:37:14.123456'</span>); <span class="comment">-- 日时</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">EXTRACT</span>(DAY_MINUTE <span class="keyword">FROM</span> <span class="string">'2017-05-15 10:37:14.123456'</span>);<span class="comment">-- 151037(日时分)</span></span><br></pre></td></tr></table></figure>
<br/>
<h3 id="5-控制流函数">5. 控制流函数</h3>
<ul>
<li><code>CASE WHEN[test1] THEN [result1]...ELSE [default] END</code>如果testN是真，则返回resultN，否则返回default</li>
<li><code>CASE [test] WHEN[val1] THEN [result]...ELSE [default]END </code> 如果test和valN相等，则返回resultN，否则返回default</li>
<li><code>IF(test,t,f) </code> 如果test是真，返回t；否则返回f</li>
<li><code>IFNULL(arg1,arg2) </code>如果arg1不是空，返回arg1，否则返回arg2</li>
<li><code>NULLIF(arg1,arg2) </code>如果arg1=arg2返回NULL；否则返回arg1</li>
</ul>
<br/>
<p>这些函数的第一个是<code>IFNULL()</code>，它有两个参数，并且对第一个参数进行判断。如果第一个参数不是NULL，函数就会向调用者返回第一个参数；如果是NULL,将返回第二个参数。</p>
<p>如：<code>SELECT IFNULL(1,2), IFNULL(NULL,10),IFNULL(4*NULL,'false');</code></p>
<br/>
<p>NULLIF()函数将会检验提供的两个参数是否相等，如果相等，则返回NULL，如果不相等，就返回第一个参数。</p>
<p>如：<code>SELECT NULLIF(1,1),NULLIF('A','B'),NULLIF(2+3,4+1);</code></p>
<br/>
<p>和许多脚本语言提供的<code>IF()</code>函数一样，MySQL的IF()函数也可以建立一个简单的条件测试，这个函数有三个参数，第一个是要被判断的表达式，如果表达式为真，IF()将会返回第二个参数，如果为假，IF()将会返回第三个参数。</p>
<p>如：<code>SELECT IF(1&lt;10,2,3),IF(56&gt;100,'true','false');</code></p>
<p><code>IF()</code>函数在只有两种可能结果时才适合使用。然而，在现实世界中，我们可能发现在条件测试中会需要多个分支。在这种情况下，MySQL提供了CASE函数，它和PHP及Perl语言的<code>switch-case</code>条件例程一样。</p>
<br/>
<p><font color = green size = 4>IFNULL(arg1, arg2)解决Mysql聚合函数count(1) sum(1)结果返回0和NULL</font></p>
<ul>
<li>
<p><font color = blue>count(1)</font></p>
<ul>
<li>
<p>返回为0</p>
<blockquote>
<p>如果所查询的表或者where条件筛选后得到的结果集为空，则 count(1)返回为 0<br>
如：<br>
select count(id) from test;<br>
select count(id) from test where id &lt; 0;</p>
</blockquote>
</li>
<li>
<p>返回为NULL</p>
<blockquote>
<p>如果所查询的表或者where条件筛选后得到的结果集为空且当前层查询中使用了group by ，则 count(1)返回为 NULL<br>
如：<br>
select count(id) from test group by id;<br>
select count(id) from test where id &lt; 0 group by id;</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = blue>sum(1)</font></p>
<ul>
<li>
<p>返回为NULL</p>
<blockquote>
<p>如果所查询的表或者where条件筛选后得到的结果集为空 ，则 sum(1)返回为 NULL<br>
如：<br>
select sum(id) from test;<br>
select sum(id) from test where id &lt; 0;</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<br/>
<blockquote>
<p><font color = red>注：</font></p>
<p>如果想NULL转为0返回，可以使用<font color = dark>IFNULL（expression_1，expression_2）</font>；表示如果expression_1不为NULL，则IFNULL函数返回expression_1；否则返回expression_2的结果。<span style="background: linear-gradient(to right, #74ebd5, #acb6e5);">如IFNULL（sum（id），0）</span></p>
</blockquote>
<br/>
<p><font color = green size = 4>CASE函数的格式有些复杂，通常如下所示：</font></p>
<p><font color = blue>1. 类似于java中点switch语句，一般用于实现等值判断</font></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CASE [expression to be evaluated]</span><br><span class="line">WHEN [val 1] THEN [result 1]</span><br><span class="line">WHEN [val 2] THEN [result 2]</span><br><span class="line">WHEN [val 3] THEN [result 3]</span><br><span class="line">......</span><br><span class="line">WHEN [val n] THEN [result n]</span><br><span class="line">ELSE [default result]</span><br><span class="line">END</span><br></pre></td></tr></table></figure>
<br/>
<p><font color = blue>2. 类似于java中的多重if语句，一般用于实现区间判断</font></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CASE</span><br><span class="line">WHEN [conditional test 1] THEN [result 1]</span><br><span class="line">WHEN [conditional test 2] THEN [result 2]</span><br><span class="line">ELSE [default result]</span><br><span class="line">END</span><br></pre></td></tr></table></figure>
<br/>
<p><font color = blue>3. 例子</font></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 数值判断</span><br><span class="line">SELECT</span><br><span class="line">    t.NAME,</span><br><span class="line">    (</span><br><span class="line">        CASE t.sex</span><br><span class="line">        WHEN 1 THEN</span><br><span class="line">            &#39;男&#39;</span><br><span class="line">        WHEN 2 THEN</span><br><span class="line">            &#39;女&#39;</span><br><span class="line">        ELSE</span><br><span class="line">            &#39;未知&#39;</span><br><span class="line">        END</span><br><span class="line">    ) 性别</span><br><span class="line">FROM</span><br><span class="line">    t_customer t</span><br><span class="line">    </span><br><span class="line">-- 条件判断    </span><br><span class="line">SELECT</span><br><span class="line">    t.NAME,</span><br><span class="line">    (</span><br><span class="line">        CASE </span><br><span class="line">        WHEN t.sex&#x3D;1 THEN</span><br><span class="line">            &#39;男&#39;</span><br><span class="line">        WHEN t.sex&#x3D;2 THEN</span><br><span class="line">            &#39;女&#39;</span><br><span class="line">        ELSE</span><br><span class="line">            &#39;未知&#39;</span><br><span class="line">        END</span><br><span class="line">    ) 性别</span><br><span class="line">FROM</span><br><span class="line">    t_customer t</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- IF()函数</span><br><span class="line">select t.name,if(t.weight&lt;80,&#39;正常&#39;,&#39;肥胖&#39;) 体重 from t_customer t</span><br><span class="line"></span><br><span class="line">-- IFNULL(value1,value2)函数,这个函数一般用来替换NULL值的</span><br><span class="line">-- 把emp员工表的员工的提成给加100</span><br><span class="line">update emp set comm  &#x3D; IFNULL(comm,0)+100</span><br></pre></td></tr></table></figure>
<br/>
<h3 id="6-格式化函数">6. 格式化函数</h3>
<ul>
<li><code>DATE_FORMAT(date,fmt) </code> 依照字符串fmt格式化日期date值</li>
<li><code>FORMAT(x,y) </code> 把x格式化为以逗号隔开的数字序列，y是结果的小数位数</li>
<li><code>INET_ATON(ip) </code> 返回IP地址的数字表示</li>
<li><code>INET_NTOA(num) </code> 返回数字所代表的IP地址</li>
<li><code>TIME_FORMAT(time,fmt) </code> 依照字符串fmt格式化时间time值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT FORMAT(34234.34323432,3);</span><br><span class="line">SELECT DATE_FORMAT(NOW(),&#39;%W,%D %M %Y %r&#39;);</span><br><span class="line">SELECT DATE_FORMAT(NOW(),&#39;%Y-%m-%d&#39;);</span><br><span class="line">SELECT DATE_FORMAT(19990330,&#39;%Y-%m-%d&#39;);</span><br><span class="line">SELECT DATE_FORMAT(NOW(),&#39;%h:%i %p&#39;);</span><br><span class="line">SELECT INET_ATON(&#39;10.122.89.47&#39;);</span><br><span class="line">SELECT INET_NTOA(175790383);</span><br></pre></td></tr></table></figure>
<br/>
<hr>
<h2 id="二、存储过程">二、存储过程</h2>
<h3 id="1-创建存储过程">1. 创建存储过程</h3>
<blockquote>
<p>创建存储过程的语句为 CREATE PROCEDURE，创建存储函数的语句为CREATE FUNCTION。</p>
<p>调用存储过程的语句为CALL。</p>
<p>调用存储函数的形式就像调用MySQL内部函数一样。</p>
</blockquote>
<p><font color = green size = 4>1. 创建存储过程示例</font></p>
<ul>
<li>
<p><font color = blue>1. 创建存储过程简单示例：</font></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELIMITER &#x2F;&#x2F;</span><br><span class="line">CREATE PROCEDURE ccgc()</span><br><span class="line">BEGIN</span><br><span class="line">SELECT * FROM TEXT;</span><br><span class="line">SELECT * FROM s_user;</span><br><span class="line">END</span><br><span class="line">&#x2F;&#x2F;DELIMITER ;</span><br><span class="line"></span><br><span class="line">-- 调用</span><br><span class="line">CALL ccgc()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = blue>2. 创建带参数的存储过程：</font></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELIMITER &#x2F;&#x2F;</span><br><span class="line">CREATE PROCEDURE ccgc2(IN c_name VARCHAR(32))</span><br><span class="line">BEGIN</span><br><span class="line">    SELECT * FROM TEXT WHERE NAME &#x3D; c_name;</span><br><span class="line">    SELECT * FROM s_user;</span><br><span class="line">END</span><br><span class="line">&#x2F;&#x2F;DELIMITER ;</span><br><span class="line"></span><br><span class="line">-- 调用</span><br><span class="line">CALL ccgc2(参数)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = blue>3. 创建输出参数存储过程</font></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELIMITER &#x2F;&#x2F;</span><br><span class="line">CREATE PROCEDURE ccgc3(OUT c_name VARCHAR(32))</span><br><span class="line">BEGIN</span><br><span class="line">    SET c_name &#x3D; &#39;666&#39;;</span><br><span class="line">    SELECT c_name;</span><br><span class="line">END</span><br><span class="line">&#x2F;&#x2F;DELIMITER ;</span><br><span class="line"></span><br><span class="line">-- 调用</span><br><span class="line">CALL ccgc3(@c_name)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = blue>4. 输入输出和变量</font></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELIMITER &#x2F;&#x2F;</span><br><span class="line">CREATE PROCEDURE ccgc7(INOUT c_name VARCHAR(32))</span><br><span class="line">BEGIN</span><br><span class="line">    DECLARE hh VARCHAR(32) DEFAULT &#39;1111111111&#39;;</span><br><span class="line">    SELECT * FROM TEXT WHERE NAME &#x3D; hh;</span><br><span class="line">END</span><br><span class="line">&#x2F;&#x2F;DELIMITER ;</span><br><span class="line"></span><br><span class="line">CALL ccgc7(@c_name)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = green>5. 对变量的定义和赋值</font></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 定义</span><br><span class="line">select @变量名  或者 select @变量名:&#x3D; 字段名 from 表名 where 过滤语句;</span><br><span class="line">set @变量名;</span><br><span class="line"></span><br><span class="line">-- 赋值 @num为变量名，value为值</span><br><span class="line">set @num&#x3D;value;或select @num:&#x3D;value;</span><br><span class="line"></span><br><span class="line">-- 混合使用</span><br><span class="line">    declare i int;                      #申明变量</span><br><span class="line">    set i &#x3D; 0;                          #变量赋值</span><br><span class="line"></span><br><span class="line">-- 局部变量（只在begin...end之间有效）</span><br><span class="line">declare var_name [, var_name]... data_type [ DEFAULT value ];</span><br><span class="line"></span><br><span class="line">-- Select into进行赋值</span><br><span class="line">select col_name[,...] into var_name[,...] table_expr [where...];</span><br></pre></td></tr></table></figure>
<br/>
<ul>
<li>
<p><font color = green>在MySQL存储过程中使用SELECT …INTO语句为变量赋值：用来将查询返回的一行的各个列值保存到局部变量中。</font></p>
<p><span style="background: linear-gradient(to right, #74ebd5, #acb6e5);">要求：查询的结果集中只能有1行。</span></p>
<ul>
<li>
<p><font color = blue>1、单一变量赋值</font></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 创建过程，得到指定球员的所有罚款总额</span><br><span class="line">delimiter $$</span><br><span class="line">create procedure total_penalties_player(in p_playerno int,out total_penalties dec(8,2))</span><br><span class="line">begin</span><br><span class="line">select sum(amount)</span><br><span class="line">into total_penalties</span><br><span class="line">from PENALTIES</span><br><span class="line">where playerno&#x3D;p_playerno;</span><br><span class="line">end $$</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line">call total_penalties_player(27,@total);</span><br><span class="line">select @total;</span><br><span class="line">+--------+</span><br><span class="line">| @total |</span><br><span class="line">+--------+</span><br><span class="line">| 175.00 |</span><br><span class="line">+--------+</span><br></pre></td></tr></table></figure>
<br/>
</li>
<li>
<p><font color = blue>2、多变量赋值</font></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 创建过程，得到一个给定球员的地址</span><br><span class="line">DELIMITER $$</span><br><span class="line">CREATE  PROCEDURE get_address(IN p_playerno SMALLINT,OUT p_street VARCHAR(30),</span><br><span class="line">OUT p_houseno VARCHAR(4),OUT p_town VARCHAR(30),OUT p_postcode VARCHAR(6))  </span><br><span class="line">BEGIN    </span><br><span class="line">SELECT street, houseno, town, postcode</span><br><span class="line">INTO p_street, p_houseno, p_town, p_postcode</span><br><span class="line">FROM PLAYERS</span><br><span class="line">WHERE playerno &#x3D; p_playerno;           </span><br><span class="line">END $$</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line">call get_address(27,@s,@h,@t,@p);</span><br><span class="line">select @s,@h,@t,@p;</span><br><span class="line">+------------+------+--------+--------+</span><br><span class="line">| @s         | @h   | @t     | @p     |</span><br><span class="line">+------------+------+--------+--------+</span><br><span class="line">| Long Drive | 804  | Eltham | 8457DK |</span><br><span class="line">+------------+------+--------+--------+</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p><font color = red>注意：</font></p>
<p>在使用SELECT …INTO语句时，变量名和数据表中的字段名不能相同，否则会出错。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<br/>
<blockquote>
<p><font color = red>总结：</font></p>
<ol>
<li>如果仅仅想把数据传给MySQL存储过程，那就用in类型参数；</li>
<li>如果仅仅从MySQL存储过程返回值，那就用out类型参数；</li>
<li>如果需要把数据传给MySQL存储过程经过计算再传回给我们，那就用inout类型参数</li>
</ol>
</blockquote>
<br/>
<ul>
<li><font color = blue>5. 其他存储过程方法</font></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 查看存储过程;</span><br><span class="line">SHOW CREATE PROCEDURE proc_name;</span><br><span class="line"></span><br><span class="line">-- 查看函数:</span><br><span class="line">SHOW CREATE FUNCTION func_name;</span><br><span class="line"></span><br><span class="line">-- 删除存储过程:</span><br><span class="line">DROP PROCEDURE proc_name;</span><br><span class="line"></span><br><span class="line">-- 删除函数:</span><br><span class="line">DROP FUNCTION func_nmae;</span><br></pre></td></tr></table></figure>
<br/>
<p><font color = green size = 4>2. 存储过程实践</font></p>
<p><font color = blue>1. 定义一个根据ID查询学生记录的存储过程。</font></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP PROCEDURE IF EXISTS getStuById;</span><br><span class="line"> </span><br><span class="line">DELIMITER &#x2F;&#x2F;  -- 定义存储过程结束符号为&#x2F;&#x2F;</span><br><span class="line">-- IN表示输入参数的存储过程；OUT表示输出参数的存储过程（可用@变量的方式调用）</span><br><span class="line">CREATE PROCEDURE getStuById(IN stuId INT(11),OUT stuName VARCHAR(255),OUT stuAge INT(11)) </span><br><span class="line">-- 定义输入与输出参数</span><br><span class="line">BEGIN</span><br><span class="line">   -- 利用输出变量返回自定义的多列数据</span><br><span class="line">   SELECT name ,age INTO stuName , stuAge FROM t_student WHERE id &#x3D; stuId; -- 分号要加</span><br><span class="line">END &#x2F;&#x2F; -- 结束符要加</span><br><span class="line">DELIMITER ;  -- 重新定义存储过程结束符为分号</span><br></pre></td></tr></table></figure>
<br/>
<p><font color = blue>2. 查看刚才创建的存储过程。</font></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW PROCEDURE STATUS LIKE &#39;g%&#39;;</span><br></pre></td></tr></table></figure>
<br/>
<p><font color = blue>3. 下面是调用存储过程。对于存储过程提供的临时变量而言，MySQL规定要加上@开头。</font></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># study是当前数据库名称</span><br><span class="line"> </span><br><span class="line">CALL study.getStuById(1,@name,@age);</span><br><span class="line"> </span><br><span class="line">SELECT @name AS stuName,@age AS stuAge;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://image.zxkidea.top/blog/20200310/HYGfjyJT6mQF.png?imageslim" alt="zxk"></p>
<br/>
<h3 id="2-创建存储函数">2. 创建存储函数</h3>
<p><font color = green size = 4>1. 创建存储函数</font></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP FUNCTION IF EXISTS getStuNameById;</span><br><span class="line"> </span><br><span class="line">DELIMITER &#x2F;&#x2F;</span><br><span class="line">-- 默认是IN，但是不能写上去。stuId视为输入的临时变量</span><br><span class="line">CREATE FUNCTION getStuNameById(stuId INT)  </span><br><span class="line">RETURNS VARCHAR(255)   -- 指明返回值类型</span><br><span class="line">RETURN  (SELECT name FROM t_student WHERE id &#x3D; stuId); &#x2F;&#x2F;  </span><br><span class="line">-- 指明SQL语句,并使用结束标记。注意分号位置</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>
<br/>
<p><font color = green size = 4>2. 使用存储函数</font></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT getStuNameById(1);</span><br></pre></td></tr></table></figure>
<br/>
<blockquote>
<p><font color = red>总结：</font> <font color = green>从上述存储函数的写法上来看，存储函数有一定的缺点。首先与存储过程一样，只能返回一条结果记录。另外就是存储函数只能指明<span style="background: linear-gradient(to right, #f2994a, #f2c94c);">一列数据</span>作为结果，而存储过程能够指明<span style="background: linear-gradient(to right, #f2994a, #f2c94c);">多列数据</span>作为结果。</font></p>
</blockquote>
<br/>
<hr>
<h2 id="三、循环语句">三、循环语句</h2>
<h3 id="1-while循环">1. while循环</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delimiter &#x2F;&#x2F;                            #定义标识符为双斜杠</span><br><span class="line">drop procedure if exists test;          #如果存在test存储过程则删除</span><br><span class="line">create procedure test()                 #创建无参存储过程,名称为test</span><br><span class="line">begin</span><br><span class="line">    declare i int;                      #申明变量</span><br><span class="line">    set i &#x3D; 0;                          #变量赋值</span><br><span class="line">    while i &lt; 10 do                     #结束循环的条件: 当i大于10时跳出while循环</span><br><span class="line">        insert into test values (i);    #往test表添加数据</span><br><span class="line">        set i &#x3D; i + 1;                  #循环一次,i加一</span><br><span class="line">    end while;                          #结束while循环</span><br><span class="line">    select * from test;                 #查看test表数据</span><br><span class="line">end</span><br><span class="line">&#x2F;&#x2F;                                      #结束定义语句</span><br><span class="line">call test();                            #调用存储过程</span><br></pre></td></tr></table></figure>
<br/>
<h3 id="2-repeat循环">2.repeat循环</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delimiter &#x2F;&#x2F;                            #定义标识符为双斜杠</span><br><span class="line">drop procedure if exists test;          #如果存在test存储过程则删除</span><br><span class="line">create procedure test()                 #创建无参存储过程,名称为test</span><br><span class="line">begin</span><br><span class="line">    declare i int;                      #申明变量</span><br><span class="line">    set i &#x3D; 0;                          #变量赋值</span><br><span class="line">    repeat</span><br><span class="line">        insert into test values (i);    #往test表添加数据</span><br><span class="line">        set i &#x3D; i + 1;                  #循环一次,i加一</span><br><span class="line">    until i &gt; 10 end repeat;            #结束循环的条件: 当i大于10时跳出repeat循环</span><br><span class="line">    select * from test;                 #查看test表数据</span><br><span class="line">end</span><br><span class="line">&#x2F;&#x2F;                                      #结束定义语句</span><br><span class="line">call test();                            #调用存储过程</span><br></pre></td></tr></table></figure>
<br/>
<h3 id="3-loop循环">3. loop循环</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delimiter &#x2F;&#x2F;                            #定义标识符为双斜杠</span><br><span class="line">drop procedure if exists test;          #如果存在test存储过程则删除</span><br><span class="line">create procedure test()                 #创建无参存储过程,名称为test</span><br><span class="line">begin</span><br><span class="line">    declare i int;                      #申明变量</span><br><span class="line">    set i &#x3D; 0;                          #变量赋值</span><br><span class="line">    lp : loop                           #lp为循环体名,可随意 loop为关键字</span><br><span class="line">        insert into test values (i);    #往test表添加数据</span><br><span class="line">        set i &#x3D; i + 1;                  #循环一次,i加一</span><br><span class="line">        if i &gt; 10 then                  #结束循环的条件: 当i大于10时跳出loop循环</span><br><span class="line">            leave lp;</span><br><span class="line">        end if; </span><br><span class="line">    end loop;</span><br><span class="line">    select * from test;                 #查看test表数据</span><br><span class="line">end</span><br><span class="line">&#x2F;&#x2F;                                      #结束定义语句</span><br><span class="line">call test();                            #调用存储过程</span><br></pre></td></tr></table></figure>
<br/>
<hr>
<h2 id="四、Limit详解">四、Limit详解</h2>
<h3 id="1-作用">1. 作用</h3>
<p><font color = green>Limit子句可以被用于强制 SELECT 语句返回指定的记录数。Limit接受一个或两个数字参数。参数必须是一个整数常量。如果给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目。</font></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 初始记录行的偏移量是 0(而不是 1);</span><br><span class="line">SELECT * FROM table LIMIT 5,10; -- 检索记录行6-15</span><br><span class="line"></span><br><span class="line">-- 为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为 -1;</span><br><span class="line">SELECT * FROM table LIMIT 95,-1; -- 检索记录行 96-last</span><br><span class="line"></span><br><span class="line">-- 如果只给定一个参数，它表示返回最大的记录行数目。换句话说，LIMIT n 等价于 LIMIT 0,n：</span><br><span class="line">SELECT * FROM table LIMIT 5;     -- 检索前 5 个记录行</span><br></pre></td></tr></table></figure>
<br/>
<h3 id="2-Limit效率">2. Limit效率</h3>
<p><font color = red size = 4>1. Limit高效率的原理是：</font><font color = green size = 4>避免全表扫描，提高查询效率。</font></p>
<blockquote>
<p>在一种情况下，使用limit效率低，那就是：只使用limit来查询语句，并且<font color = blue>偏移量特别大</font>的情况</p>
<p>所以应当先使用where等查询语句，配合limit使用，效率才高</p>
<p>PS：在sql语句中，limit关键字是最后才用到的。以下条件的出现顺序一般是：where-&gt;group by-&gt;having-order by-&gt;limit</p>
</blockquote>
<br/>
<p><font color = green size = 4>2. 与OFFSET搭配</font></p>
<p><font color = blue>比较下面两句SQL语句</font></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 从数据库中第三条开始查询，取一条数据，即第三条数据读取，一二条跳过</span><br><span class="line">select * from testtable limit 2,1;</span><br><span class="line"></span><br><span class="line">-- 从数据库中的第二条数据开始查询两条数据，即第二条和第三条。</span><br><span class="line">select * from testtable limit 2 offset 1;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><font color = red>注意：</font></p>
<ol>
<li>数据库数据计算是从0开始的</li>
<li>Offset X是跳过X个数据，limit Y是选取Y个数据</li>
<li>Limit  X,Y  中X表示跳过X个数据，读取Y个数据</li>
</ol>
</blockquote>
<br/>
<h3 id="3-Order-by多个字段">3. Order by多个字段</h3>
<blockquote>
<p>orderby多个字段时，用逗号分隔每一个字段，如果字段不指明排序方式，默认是增序。排序的方法是先按第一个字段排序，如果有相同的再按后续的字段依次排序。</p>
</blockquote>
<img data-src="https://image.zxkidea.top/blog/20200325/BCiqjNz10RXL.png?imageslim" alt="zxk" style="zoom:72%;" />
<img data-src="http://image.zxkidea.top/blog/20200325/3WTkJinFFu78.png?imageslim" alt="mark" style="zoom:60%;" />
<img data-src="http://image.zxkidea.top/blog/20200325/BVGxUxNmOxCB.png?imageslim" alt="mark" style="zoom:67%;" />
<br/>
<hr>
<h2 id="五、生成自增序列">五、生成自增序列</h2>
<h3 id="1-作用-2">1. 作用</h3>
<p><font color = green size = 4>对记录按照某种顺序进行排列后，通过序号来进行进一步筛选</font></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select (@i:&#x3D;@i+1) as rownum, surname, personal_name from student, (select @i:&#x3D;0) as init;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://image.zxkidea.top/blog/20200310/xG1IugBQWj6H.png?imageslim" alt="zxk"></p>
<br/>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select (@i:&#x3D;@i+5) as rownum, surname, personal_name from student, (select @i:&#x3D;100) as init;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://image.zxkidea.top/blog/20200310/NEyjruN4tjA9.png?imageslim" alt="zxk"></p>
<br/>
<p><font color = blue> 如果是多表联查，跟上述sql类似，连查完后定义一个初始化序列号即可：</font></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select (@i:&#x3D;@i+1) as rownum, A.surname, B.uname from student A</span><br><span class="line"></span><br><span class="line">left join user B on CONCAT(A.surname,A.personal_name) &#x3D; B.uname, (select @i:&#x3D;0) as init;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://image.zxkidea.top/blog/20200310/6a6hYrVUqpOX.png?imageslim" alt="zxk"></p>
<br/>
<h3 id="2-中位数运算">2. 中位数运算</h3>
<ul>
<li><font color = green size = 4>定义：</font>一串数字，按从小到大排列，当总数是奇数时，取最中间的数；当总数是偶数时，取最中间两个数的平均数。</li>
</ul>
<br/>
<ul>
<li><font color = green size = 4>解决思路：</font>按定义来，先排列，找出最中间的数，再取平均值。</li>
</ul>
<br/>
<ul>
<li>
<p><font color = green size = 4>准备表如下：</font></p>
<p><font color = blue>学生表，含姓名和分数</font></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table student (</span><br><span class="line">	id varchar(32) primary key,</span><br><span class="line">	value int</span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">insert into student (id,value) values (&#39;A&#39;,40);</span><br><span class="line">insert into student (id,value) values (&#39;B&#39;,50);</span><br><span class="line">insert into student (id,value) values (&#39;C&#39;,60);</span><br><span class="line">insert into student (id,value) values (&#39;D&#39;,70);</span><br><span class="line">insert into student (id,value) values (&#39;E&#39;,80);</span><br><span class="line">insert into student (id,value) values (&#39;F&#39;,90);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = green size = 4>最终sql如下：</font></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select group_concat(id) gcid, avg(value) avgv from ( #最外层开始</span><br><span class="line">	select id, value from ( #第二层开始</span><br><span class="line">		select id, @index:&#x3D;@index+1 as myindex, value from student, (select @index:&#x3D;0) AS initvar order by value #最内层</span><br><span class="line">	) as t where floor(@index&#x2F;2+1)&#x3D;myindex or ceil(@index&#x2F;2)&#x3D;myindex #第二层结束</span><br><span class="line">) as x  #最外层结束</span><br></pre></td></tr></table></figure>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = green size = 4>解释：</font></p>
<ul>
<li>
<p>SQL分三层：最内层，第二层和最外层。</p>
<p>最内层是对成绩排序，并标注出名次，只执行最内层时结果如下：</p>
<p>对@变量不熟悉的同学自行百度，效果类似rownum。<font color = red>注意：执行完最内层时，@index的值就是总行数</font></p>
</li>
</ul>
<p><img data-src="https://image.zxkidea.top/blog/20200310/ijiuhW0KtKic.png?imageslim" alt="zxk"></p>
<ul>
<li>
<p>第二层取出最中间的两个值，</p>
<p><font color = red>注意：floor和ceil的顺序：</font></p>
<p><font color = green>当@index是奇数时，floor(@index/2+1)和ceil(@index/2)的值一样的，@index=7时，floor(4.5) = ceil(3.5) = 4</font></p>
<p><font color = green>当@index是偶数时，floor(@index/2+1)和ceil(@index/2)的值不一样，@index=6时，floor(4) = 4，ceil(3) = 3</font></p>
<p><font color = green>这就解决了中位数定义中如果总个数是奇数只取一位，总个数是偶数取中间两个的平均数的问题。</font></p>
<br/>
<p>第二层执行完的结果如下：</p>
<p><img data-src="https://image.zxkidea.top/blog/20200310/d7Q25OfCYKax.png?imageslim" alt="zxk"></p>
<p><font color = red>注：如果总个数是奇数，第二层执行完只会出来一行记录</font></p>
</li>
</ul>
<br/>
<ul>
<li>
<p>最外层就简单了，取个平均数就行了。group_concat(id)只是用来看下中位数的学生是谁，可去掉。</p>
<table>
<thead>
<tr>
<th style="text-align:center">gcid</th>
<th style="text-align:center">avgv</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">C, D</td>
<td style="text-align:center">65</td>
</tr>
</tbody>
</table>
<br/>
<ul>
<li>
<p><font color = blue>group_concat()：</font></p>
<p><img data-src="https://image.zxkidea.top/blog/20200310/UrcNY0cP6S4D.png?imageslim" alt="zxk"></p>
<blockquote>
<p>有没有更直观的方法，既让每个名字都只出现一次，又能够显示所有的名字相同的人的id呢？<font color = green>——使用group_concat()</font></p>
</blockquote>
<br/>
<ul>
<li><font color = blue>group_concat()用法：</font></li>
</ul>
<blockquote>
<p>1、功能：将group by产生的同一个分组中的值连接起来，返回一个字符串结果。</p>
<p>2、语法：group_concat( [distinct] 要连接的字段 [order by 排序字段 asc/desc ] [separator ‘分隔符’] )</p>
<p>说明：通过使用distinct可以排除重复值；如果希望对结果中的值进行排序，可以使用order by子句；separator是一个字符串值，缺省为一个逗号。</p>
</blockquote>
<br/>
<ul>
<li>
<p><font color = blue>示例：</font>使用group_concat()和group by显示相同名字的人的id号：</p>
<p><img data-src="https://image.zxkidea.top/blog/20200310/rFgh9TE088g7.png?imageslim" alt="zxk"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>考研</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>DatabaseNotes-Ch10</title>
    <url>/posts/7755ff13.html</url>
    <content><![CDATA[<h2 id="Ch10-Update-Transaction">Ch10.  Update Transaction</h2>
<h3 id="1-事务及其特性：">1. 事务及其特性：</h3>
<p><font color = green size = 4>事务：</font>是访问和更新数据库的程序执行单元；事务中可能包含一个或多个SQL语句，这些语句要么都执行，要么都不执行。</p>
<br/>
<p><font color = green size = 4>事务的四大特性：ACID</font></p>
<a id="more"></a>
<ul>
<li>
<p><font color = blue>原子性（Atomicity）</font></p>
<blockquote>
<p>原子性是指一个事务是一个不可分割的工作单位，其中的操作要么都做，要么都不做；如果事务中一个SQL语句执行失败，则已执行的语句也必须回滚，数据库退回到事务前的状态。</p>
<p><font color = red>注：</font><font color = green>MySQL 使用 undo log 来保证事务的原子性。</font></p>
</blockquote>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = blue>持久性（Durability）</font></p>
<blockquote>
<p>持久性是指事务一旦提交，它对数据库的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。</p>
<p><font color = red>注：</font><font color = green>MySQL 使用 redo log 来保证事务的持久性。</font></p>
</blockquote>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = blue>隔离性（Isolation）</font></p>
<blockquote>
<p>与原子性、持久性侧重于研究事务本身不同，隔高性研究的是不同事务之间的相互影响。隔离性是指，事务内部的操作与其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p>
<p><font color = red>注：</font><font color = green>MySQL 通过锁机制来保证事务的隔离性。</font></p>
</blockquote>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = blue>一致性（Consistency）</font></p>
<blockquote>
<p>一致性是指事务执行结束后，数据库的完整性约束没有被破坏，事务执行的前后都是合法的数据状态；</p>
<p>数据库的完整性约束包括但不限于：实体完整性（如行的主键存在且唯一）、列完整性（如字段的类型、大小、长度要符合要求）、外键约束、用户自定义完整性（如转账前后，两个账户余额的和应该不变）。</p>
</blockquote>
</li>
</ul>
<br/>
<h3 id="2-事务操作：">2. 事务操作：</h3>
<p><font color = green size = 4>典型的事务操作：</font></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">……  # 一条或多条sql语句</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其中start transaction标识事务开始，commit提交事务，将执行结果写入到数据库。如果SQL语句执行出现问题，会调用rollback，回滚所有已经执行成功的SQL语句。当然，也可以在事务中直接使用rollback语句进行回滚。</p>
</blockquote>
<br/>
<p><font color = green size = 4>特殊操作：</font></p>
<blockquote>
<p>在MySQL中，存在一些特殊的命令，如果在事务中执行了这些命令，会马上强制执行commit提交事务；如DDL语句(create table/drop table/alter/table)、lock tables语句等等。</p>
</blockquote>
<p><font color = brown>不过，常用的select、insert、update和delete命令，都不会强制提交事务。</font></p>
<br/>
<h3 id="3-事务的实现">3. 事务的实现</h3>
<h4 id="1-undo-log（回滚日志）">1. undo log（回滚日志）</h4>
<ul>
<li>
<p><font color = green size = 4>InnoDB实现回滚，靠的是undo log：</font></p>
<blockquote>
<p>当事务对数据库进行修改时，InnoDB会生成对应的undo log；如果事务执行失败或调用了rollback，导致事务需要回滚，便可以利用undo log中的信息将数据回滚到修改之前的样子。</p>
</blockquote>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = green size = 4>undo log属于逻辑日志，它记录的是SQL执行相关的信息：</font></p>
<blockquote>
<p>当发生回滚时，InnoDB会根据undo log的内容做与之前相反的工作：对于每个insert，回滚时会执行delete；对于每个delete，回滚时会执行insert；对于每个update，回滚时会执行一个相反的update，把数据改回去。</p>
</blockquote>
</li>
</ul>
<p><img data-src="https://image.zxkidea.top/blog/20200308/EjXsxnPSPXiV.png?imageslim" alt="zxk"></p>
<br/>
<h4 id="2-redo-log（重做日志）">2. redo log（重做日志）</h4>
<ul>
<li>
<p><font color = green size = 4>更新流程</font></p>
<p><img data-src="https://image.zxkidea.top/blog/20200308/Py2TYgYapShW.png?imageslim" alt="zxk"></p>
<ul>
<li>执行update操作。</li>
<li>先将原始数据从磁盘读取到内存，修改内存中的数据。</li>
<li>生成一条重做日志写入redo log buffer，记录数据被修改后的值。</li>
<li>当事务提交时，需要将redo log buffer中的内容刷新到redo log file。</li>
<li>事务提交后，也会将内存中修改数据的值写入磁盘。</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = green size = 4>恢复机制</font></p>
<blockquote>
<p>于是，redo log被引入来解决这个问题：当数据修改时，除了修改缓冲区中的数据，还会在redo log记录这次操作；当事务提交时，会调用fsync接口对redo log进行刷盘。如果MySQL宕机，重启时可以读取redo log中的数据，对数据库进行恢复。</p>
</blockquote>
<br/>
<p><span style="background: linear-gradient(to right, #74ebd5, #acb6e5);">redo log实现事务的原子性和持久性：</span></p>
<ul>
<li>原子性，是redo log记录了事务期间操作的物理日志，事务提交之前，并没有写入磁盘，保存在内存里，如果事务失败，数据库磁盘不会有影响，回滚掉事务内存部分即可。</li>
<li>持久性，redo log 会在事务提交时将日志存储到磁盘redo log file，保证日志的持久性。</li>
</ul>
</li>
</ul>
<br/>
<h3 id="4-事务的隔离级别">4. 事务的隔离级别</h3>
<p><img data-src="https://image.zxkidea.top/blog/20200308/EK19I1B5Ynqm.png?imageslim" alt="zxk"></p>
<br/>
<h4 id="1-READ-UNCOMMITTED">1. READ-UNCOMMITTED</h4>
<p><font color = green>READ-UNCOMMITTED 中文叫未提交读，即一个事务读到了另一个未提交事务修改过的数据，整个过程如下图:</font></p>
<p><img data-src="https://image.zxkidea.top/blog/20200308/Y48xImrVT3X2.png?imageslim" alt="zxk"></p>
<blockquote>
<p>如上图，SessionA和SessionB分别开启一个事务，SessionB中的事务先将id为1的记录的name列更新为’lisi’，然后SessionA中的事务再去查询这条id为1的记录，那么在未提交读的隔离级别下，查询结果由’zhangsan’变成了’lisi’，也就是说某个事务读到了另一个未提交事务修改过的记录。但是如果SessionB中的事务稍后进行了回滚，那么SessionA中的事务相当于读到了一个不存在的数据，这种现象也称为<span style="background: linear-gradient(to right, #f2994a, #f2c94c);">脏读</span>。</p>
</blockquote>
<br/>
<h4 id="2-READ-COMMITTED">2. READ COMMITTED</h4>
<p><font color = green>READ COMMITTED 中文叫已提交读，或者叫不可重复读。即一个事务能读到另一个已经提交事务修改后的数据，如果其他事务均对该数据进行修改并提交，该事务也能查询到最新值。如下图:</font></p>
<p><img data-src="https://image.zxkidea.top/blog/20200308/PMYGTQlwvl1b.png?imageslim" alt="zxk"></p>
<blockquote>
<p>在SessionA中先后两次读取同一个数据，两次读取的结果不一样；在第4步 SessionB 修改后，如果未提交，SessionA是读不到，但SessionB一旦提交后，SessionA即可读到SessionB修改的内容。</p>
</blockquote>
<br/>
<h4 id="3-REPEATABLE-READ">3. REPEATABLE READ</h4>
<p><font color = green>REPEATABLE READ 中文叫可重复读，即事务能读到另一个已经提交的事务修改过的数据，但是第一次读过某条记录后，即使后面其他事务修改了该记录的值并且提交，该事务之后再读该条记录时，读到的仍是第一次读到的值，而不是每次都读到不同的数据。如下图:</font></p>
<p><img data-src="https://image.zxkidea.top/blog/20200308/qPMDkMLIGmDm.png?imageslim" alt="zxk"></p>
<blockquote>
<p>InnoDB<span style="background: linear-gradient(to right, #f2994a, #f2c94c);">默认</span>是这种隔离级别，SessionB无论怎么修改id=1的值，SessionA读到依然是自己开启事务第一次读到的内容；但是可能会出现<span style="background: linear-gradient(to right, #74ebd5, #acb6e5);">幻读现象</span>。</p>
</blockquote>
<br/>
<h4 id="4-SERIALIZABLE">4. SERIALIZABLE</h4>
<p><font color = green>SERIALIZABLE 叫串行化， 上面三种隔离级别可以进行 读-读 或者 读-写、写-读三种并发操作，而SERIALIZABLE不允许读-写，写-读的并发操作。 如下图:</font></p>
<p><img data-src="https://image.zxkidea.top/blog/20200308/rpRJ6Pp9pWcL.png?imageslim" alt="zxk"></p>
<blockquote>
<p>SessionB 对 id=1 进行修改的时候，SessionA 读取id=1则需要等待 SessionB 提交事务。可以理解SessionB在更新的时候加了X锁。</p>
</blockquote>
<br/>
<ul>
<li>
<p><font color = red size = 4>幻读：</font></p>
<p><font color = green>在事务A中按照某个条件先后两次查询数据库，两次查询结果的条数不同，这种现象称为幻读。不可重复读与幻读的区别可以通俗的理解为：前者是数据变了，后者是数据的行数变了。</font></p>
<p><img data-src="https://image.zxkidea.top/blog/20200308/O6gfdeqVrpXI.png?imageslim" alt="zxk"></p>
</li>
</ul>
<br/>
<h4 id="5-隔离级别与读问题的关系">5. 隔离级别与读问题的关系</h4>
<p><img data-src="https://image.zxkidea.top/blog/20200308/ExlJ4uV9oYI2.png?imageslim" alt="zxk"></p>
<blockquote>
<p>在实际应用中，读未提交在并发时会导致很多问题，而性能相对于其他隔离级别提高却很有限，因此使用较少。可串行化强制事务串行，并发效率很低，只有当对数据一致性要求极高且可以接受没有并发时使用，因此使用也较少。因此在大多数数据库系统中，默认的隔离级别是读已提交(如Oracle)或可重复读。</p>
</blockquote>
<br/>
<h3 id="5-锁机制">5. 锁机制</h3>
<p><font color = green size = 4>锁机制使得在对数据库进行并发访问时，可以保障数据的完整性和一致性。</font></p>
<blockquote>
<p><font color = red size = 4>基本原理：</font></p>
<p>事务在修改数据之前，需要先获得相应的锁；获得锁之后，事务便可以修改数据；该事务操作期间，这部分数据是锁定的，其他事务如果需要修改数据，需要等待当前事务提交或回滚后释放锁。</p>
</blockquote>
<br/>
<h4 id="1-锁的类型">1. 锁的类型</h4>
<ul>
<li>
<p><font color = green>共享锁（也称为 S 锁）：</font>允许事务读取一行数据。</p>
<blockquote>
<p>共享锁又称为读锁。若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁为止。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 手动加S锁</span><br><span class="line">select * from tableName where … lock in share mode;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = green>排他锁（也称为 X 锁）：</font>允许事务删除或更新一行数据。</p>
<blockquote>
<p>排他锁又称为写锁。若事务T对数据对象A加上X锁，则只允许T读取和修改A，其他任何事务都不能再对A加任何类型的锁，直到T释放A上的锁为止。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 手动加 X 锁</span><br><span class="line">select * from tableName where … for update;</span><br></pre></td></tr></table></figure>
<br/>
<img data-src="https://image.zxkidea.top/blog/20200309/lUJVMrtKqSft.png?imageslim" alt="zxk" style="zoom:50%;" />
</li>
</ul>
<blockquote>
<p>S 锁和 S 锁是兼容的，X 锁和其它锁都不兼容，举个例子，事务 T1 获取了一个行 r1 的 S 锁，另外事务 T2 可以立即获得行 r1 的 S 锁，此时 T1 和 T2 共同获得行 r1 的 S 锁，此种情况称为锁兼容，但是另外一个事务 T2 此时如果想获得行 r1 的 X 锁，则必须等待 T1 对行 r 锁的释放，此种情况也成为锁冲突。</p>
</blockquote>
<br/>
<ul>
<li><font color = green>更新锁：</font>更新锁的初始化阶段用来锁定可能要被修改的资源，这可以避免使用共享锁造成的死锁现象。</li>
</ul>
<br/>
<ul>
<li>
<p><font color = green>意向锁：</font>设计目的是为了在一个事务中揭示下一步将要被请求的锁的类型，使得行锁和表锁共存。</p>
<blockquote>
<p>当一个事务在需要获取资源的锁定时，如果该资源已经被排他锁占用，则数据库会自动给该事务申请一个该表的意向锁。如果自己需要一个共享锁定，就申请一个意向共享锁。如果需要的是某行（或者某些行）的排他锁定，则申请一个意向排他锁。</p>
</blockquote>
</li>
</ul>
<br/>
<h4 id="2-锁的优化">2. 锁的优化</h4>
<p><font color = green size = 4>锁如果利用不好，会给业务造成大量的卡顿现象，在了解了锁相关的一些知识点后，我们可以有意识的去避免锁带来的一些问题。</font></p>
<ul>
<li>合理设计索引，让 InnoDB 在索引键上面加锁的时候尽可能准确，尽可能的缩小锁定范围，避免造成不必要的锁定而影响其他 Query 的执行。</li>
<li>尽可能减少基于范围的数据检索过滤条件，避免因为间隙锁带来的负面影响而锁定了不该锁定的记录。</li>
<li>尽量控制事务的大小，减少锁定的资源量和锁定时间长度</li>
<li>在业务环境允许的情况下，尽量使用较低级别的事务隔离，以减少 MySQL 因为实现事务隔离级别所带来的附加成本。</li>
</ul>
]]></content>
      <categories>
        <category>数据库基础</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>考研</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>DatabaseNotes-Ch7,8</title>
    <url>/posts/9c3362dd.html</url>
    <content><![CDATA[<h2 id="Ch7-Database-Manage-数据库管理">Ch7.  Database Manage(数据库管理)</h2>
<h3 id="1-Integrity-Constraints-完整性约束">1. Integrity Constraints (完整性约束)</h3>
<ul>
<li><font color = green size = 4>数据完整性：</font>存储在数据库中的所有数据值均正确的状态。它是应防止数据库中存在不符合语义规定的数据和防止因错误信息的输入输出造成无效操作或错误信息而提出的。</li>
</ul>
<br/>
<h4 id="1）实体完整性">1）实体完整性</h4>
<a id="more"></a>
<ul>
<li>
<p><font color = red>实体完整性是对关系中记录的唯一性，也就是主键的约束。</font>准确地说，实体完整性是指关系中的主属性值不能为Null且不能有相同值。定义表中的所有行唯一的标识，一般用主键，唯一索引unique关键字及identity属性；比如说我们的身份证号码，可以唯一标识一个人。</p>
<br/>
<ul>
<li>
<p>将Student表中的Sno属性定义为码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE Student</span><br><span class="line">	(Sno CHAR(9) PRIMARY KEY,	&#x2F;*在列级定义主码*&#x2F;</span><br><span class="line">	 Sname CHAR(20) NOT NULL,</span><br><span class="line">	 Ssex CHAR(2),</span><br><span class="line">	 Sage SMALLINT,</span><br><span class="line">	 Sdept CHAR(20)</span><br><span class="line">	);</span><br></pre></td></tr></table></figure>
<p><font color = green>或者</font></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE Student</span><br><span class="line">	(Sno CHAR(9),</span><br><span class="line">	 Sname CHAR(20) NOT NULL,	</span><br><span class="line">	 Ssex CHAR(2),</span><br><span class="line">	 Sage SMALLINT,</span><br><span class="line">	 Sdept CHAR(20),</span><br><span class="line">	 PRIMARY KEY(Sno)	&#x2F;*在表级定义主码*&#x2F;</span><br><span class="line">	);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<br/>
<ul>
<li>
<p>将SC表中的Sno，Cno属性组定义为码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE SC</span><br><span class="line">	(Sno CHAR(9) NOT NULL,</span><br><span class="line">	 Cno CHAR(4) NOT NULL,</span><br><span class="line">	 Grade SMALLINT,</span><br><span class="line">	 PRIMARY KEY(Sno,Cno)	&#x2F;*只能在表级定义主码*&#x2F;</span><br><span class="line">	);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = red>实体完整性检查和违约处理</font></p>
<blockquote>
<p>用PRIMARY KEY短语定义了关系的主码后，每当用户程序对基本表插入一条记录或者对主码列进行更新操作时，DBMS将按实体完整性规则自动进行检查。包括：<br>
<span style="background: linear-gradient(to right, #74ebd5, #acb6e5);">1.检查主码值是否唯一，如果不唯一则拒绝插入或修改。</span><br>
<span style="background: linear-gradient(to right, #74ebd5, #acb6e5);">2.检查主码的各个属性是否为空，只要有一个为空就拒绝插入或修改。</span></p>
<p>从而保证了实体完整性。</p>
</blockquote>
</li>
</ul>
<br/>
<h4 id="2）参照完整性">2）参照完整性</h4>
<ul>
<li>
<p><font color = red>参照完整性是对关系数据库中建立关联关系的数据表间数据参照引用的约束，也就是对外键的约束。</font>准确地说，参照完整性是指关系中的外键必须是另一个关系的主键有效值，或者是NULL。参考完整性维护表间数据的有效性,完整性,通常通过建立外部键联系另一表的主键实现,还可以用触发器来维护参照完整性。</p>
<br/>
<ul>
<li>
<p>关系SC中一个元组表示一个学生选修的某门课程的成绩，（Sno,Cno）是主码。Sno,Cno分别参照引用Student表的主码和Course表的主码。定义SC中参照完整性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE SC</span><br><span class="line">	(Sno CHAR(9) NOT NULL,</span><br><span class="line">	 Cno CHAR(4) NOT NULL,</span><br><span class="line">	 Grade SMALLINT ,</span><br><span class="line">	 PRIMARY KEY (Sno,Cno),				&#x2F;*在表级定义实体完整性*&#x2F;</span><br><span class="line">	 FOREIGN KEY(Sno) REFERENCES Student(Sno),	&#x2F;*在表级定义参照完整性*&#x2F;</span><br><span class="line">	 FOREIGN KEY(Cno) REFERENCES Course(Cno)	&#x2F;*在表级定义参照完整性*&#x2F;</span><br><span class="line">	);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = red>参照完整性检查和违约处理</font></p>
<p>一个参照完整性将两个表中的相应元组联系起来了。因此，对被参照表和参照表进行增删改操作时有可能破坏参照完整性，必须进行检查。</p>
<p>例如，对表SC和Student有四种可能破坏参照完整性的情况，如下表：</p>
<p><img data-src="https://image.zxkidea.top/blog/20200308/inWK7fkl2nkt.png?imageslim" alt="zxk"></p>
<br/>
<blockquote>
<p><font color = green>1.SC表中增加一个元组，该元组的Sno属性的值在表Student中找不到一个元组，其Sno属性的值与之相等。</font><br>
<font color = green>2.修改SC表中的一个元组，修改后该元组的Sno属性的值在表Student中找不到一个元组，其Sno属性的值与之相等。</font><br>
<font color = green>3.从Student表删除一个元组，造成SC表中某些元组的Sno属性的值在表Student中找不到一个元组，其Sno属性的值与之相等。</font></p>
<p><font color = green>4.修改Student表中一个元组的Sno属性，造成SC表中某些元组的Sno属性的值在表Student中找不到一个元组，其Sno属性的值与之相等。</font></p>
</blockquote>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = red>上述的不一致发生时，系统可以采用以下的策略加以处理。</font></p>
<ul>
<li><span style="background: linear-gradient(to right, #74ebd5, #acb6e5);">1.拒绝（NO ACTION）执行</span>
<ul>
<li>不允许该操作执行。该策略一般设置为默认策略。</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li><span style="background: linear-gradient(to right, #74ebd5, #acb6e5);">2.级连（CASCADE)操作</span>
<ul>
<li>当删除或修改被参照表（Student)的一个元组造成了与参照表（SC)的不一致，则删除或修改参照表中的所有造成不一致的元组。<br>
例如，删除Student表中的元组，Sno值为14042401，则从要SC表中级连删除SC.Sno=‘14042401’的所元组。</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>
<p><span style="background: linear-gradient(to right, #74ebd5, #acb6e5);">3.设置为空值</span></p>
<ul>
<li>
<p>当删除或修改被参照表的一个元组时造成了不一致，则将参照表中的所有造成不一致的元组的对应属性设置为空值。</p>
<ul>
<li>
<p><font color = green>示例：</font></p>
<blockquote>
<p>例如，有下面2个关系<br>
学生（学号，姓名，性别，专业号，年龄）<br>
专业（专业号，专业名）<br>
学生关系的“专业号”是外码，因为专业号是专业关系的主码。</p>
<p>假设专业表中某个元组被删除，专业号为12，按照设置为空值的策略，就要把学生表中专业号=12的所有元组的专业号设置为空值。这对应了这样的语义：某个专业删除了，该专业的所有学生专业未定，等待重新分配专业。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE SC</span><br><span class="line">	      (Sno CHAR(9) NOT NULL,</span><br><span class="line">	       Cno CHAR(4) NOT NULL,</span><br><span class="line">	       Grade SMALLINT,</span><br><span class="line">           &#x2F;*在表级定义实体完整性*&#x2F;</span><br><span class="line">	       PRIMARY KEY(Sno,Cno),			 </span><br><span class="line">	       &#x2F;*在表级定义参照完整性*&#x2F;</span><br><span class="line">           FOREIGN KEY(Sno) REFERENCES Student(Sno)	 </span><br><span class="line">	       &#x2F;*当删除student表中的元组时，级连删除SC表中相应的元组*&#x2F;</span><br><span class="line">           ON DELETE CASCADE	</span><br><span class="line">           &#x2F;*当更新student表中的Sno时，级连更新SC表中相应的元组*&#x2F;</span><br><span class="line">	       ON UPDATE CASCADE,    </span><br><span class="line">           &#x2F;*在表级定义参照完整性*&#x2F;</span><br><span class="line">	       FOREIGN KEY(Cno) REFERENCES Course(Cno) </span><br><span class="line">	       &#x2F;*当删除course表中的元组造成了与SC表不一致时拒绝删除*&#x2F;</span><br><span class="line">           ON DELETE NO ACTION	</span><br><span class="line">	       &#x2F;*当更新course表中的cno时，级连更新SC表中相应的元组*&#x2F;</span><br><span class="line">           ON UPDATE CASCADE,    </span><br><span class="line">	       );</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = red>示例：</font></p>
<p>std3表结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table std3 (</span><br><span class="line">     id number(6) ,</span><br><span class="line">     name varchar(200) constraint std3_name_nn not null,</span><br><span class="line">     score number(10,2) ,</span><br><span class="line">     email varchar(20) ,   -- 表级约束</span><br><span class="line">     constraint std3_email_uk unique(email) ,</span><br><span class="line">     constraint std3_id_pk primary key(id)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>std3中数据如下：</p>
<p><img data-src="https://image.zxkidea.top/blog/20200308/ge38zfuXOaq9.png?imageslim" alt="zxk"></p>
<p>std5表结构（外键级联删除）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table std5 (</span><br><span class="line">     id number(6) ,</span><br><span class="line">     name varchar(200) constraint std4_name_nn not null,</span><br><span class="line">     score number(10,2) ,</span><br><span class="line">     email varchar(20) ,</span><br><span class="line">     friend_id number(6) ,   -- 表级约束</span><br><span class="line">     constraint std5_email_uk unique(email) ,</span><br><span class="line">     constraint std5_id_pk primary key(id) ,</span><br><span class="line">     constraint std5_friend_id_fk foreign key(friend_id) references std3(id) on delete cascade</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<br/>
<p>std5中数据如下：</p>
<p><img data-src="https://image.zxkidea.top/blog/20200308/OSr7Vl9hrWdO.png?imageslim" alt="zxk"></p>
<br/>
<p>std6表结构（外键级联删除制空）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table std6 (</span><br><span class="line">     id number(6) ,</span><br><span class="line">     name varchar(200) constraint std6_name_nn not null,</span><br><span class="line">     score number(10,2) ,</span><br><span class="line">     email varchar(20) ,</span><br><span class="line">     friend_id number(6) , -- 表级约束</span><br><span class="line">     constraint std6_email_uk unique(email) ,</span><br><span class="line">     constraint std6_id_pk primary key(id) ,</span><br><span class="line">     constraint std6_friend_id_fk foreign key(friend_id) references std3(id) on delete set null</span><br><span class="line">     )</span><br></pre></td></tr></table></figure>
<p>std6中数据如下：</p>
<p><img data-src="https://image.zxkidea.top/blog/20200308/TIy5Gr4FLKoa.png?imageslim" alt="zxk"></p>
<br/>
<p><font color = green size = 4>级联操作:</font></p>
<ul>
<li>
<p>此时删除std3中‘300001’号数据以后：</p>
<p>std5表：</p>
<p><img data-src="https://image.zxkidea.top/blog/20200308/M1SrQ6xtkTU4.png?imageslim" alt="zxk"></p>
<p>std6表：</p>
<p><img data-src="https://image.zxkidea.top/blog/20200308/hQvzuhtFAqHa.png?imageslim" alt="zxk"></p>
<p><font color = green>注：级联删除会删除相关联子表中的数据，而级联制空会将子表中相关联的数据置空而不会删除</font></p>
</li>
</ul>
</li>
</ul>
<br/>
<h4 id="3）用户定义的完整性">3）用户定义的完整性</h4>
<p><font color = green >1.属性上的约束条件的定义</font></p>
<blockquote>
<p>在CREATE TABLE 中定义属性的同时可以根据应用要求，定义属性上的约束条件，即属性值限制，包括：</p>
<ol>
<li><span style="background: linear-gradient(to right, #74ebd5, #acb6e5);">列值非空（NOT NULL短语）</span></li>
<li><span style="background: linear-gradient(to right, #74ebd5, #acb6e5);">列值唯一（UNIQUE短语）</span></li>
<li><span style="background: linear-gradient(to right, #74ebd5, #acb6e5);">检查列值是否满足一个布尔表达式（CHECK语句）</span></li>
</ol>
</blockquote>
<br/>
<ul>
<li>
<p><font color = blue>不允许取空值</font></p>
<ul>
<li>
<p>在定义SC表时，说明Sno、Cno、Grade属性不允许取空值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE SC</span><br><span class="line">	(Sno CHAR(9) NOT NULL.	&#x2F;*Sno属性不允许取空值*&#x2F;</span><br><span class="line">	 Cno CHAR(4) NOT NULL,	&#x2F;*Cno属性不允许取空值*&#x2F;</span><br><span class="line">	 Grade SMALLINT NOT NULL, &#x2F;*Grade属性不允许取空值*&#x2F;</span><br><span class="line">&#x2F;*如果在表级定义实体完整性，隐含了Sno,Cno不允许取空值则在列级不允许取空值的定义就不必写了*&#x2F;</span><br><span class="line">     PRIMARY KEY(Sno,Cno), 	  </span><br><span class="line">	 ……			&#x2F;*其它语句省略*&#x2F;</span><br><span class="line">	);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = blue>列值唯一</font></p>
<ul>
<li>
<p>建立部门表DEPT,要求部门名称Dname列取值唯一，部门编号Deptno列为主码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE DEPT</span><br><span class="line">		(Deptno NUMERIC(2),</span><br><span class="line">		 Dname CHAR(9) UNIQUE,	&#x2F;*要求Dname列值唯一*&#x2F;</span><br><span class="line">		 Location CHAR(10),</span><br><span class="line">		 PRIMARY KEY(Deptno)</span><br><span class="line">		);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = blue>用CHECK短语自定列值应该满足的条件</font></p>
<ul>
<li>
<p>Student 表的Ssex只允许取“男”或“女”。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE Student</span><br><span class="line">		(Sno CHAR(9) PRIMARY KEY,		&#x2F;*在列级定义主码*&#x2F;</span><br><span class="line">		 Sname CHAR(8) NOT NULL,		&#x2F;*Sname属性不允许取空值*&#x2F;</span><br><span class="line">		 Ssex CHAR(2) CHECK(Ssex IN (&#39;男&#39;,&#39;女&#39;)),	&#x2F;*性别属性Ssex只允许取’男‘或’女‘*&#x2F;</span><br><span class="line"> 		 Sage SMALLINT,</span><br><span class="line">		 Sdept CHAR(20)</span><br><span class="line">		);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>SC表的Grade的值应该在0至100之间。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE SC</span><br><span class="line">	     (Sno CHAR(9) NOT NULL,</span><br><span class="line"> 	      Cno CHAR(4) NOT NULL,</span><br><span class="line">	      Grade SMALLINT CHECK(Grade&gt;&#x3D;0 AND Grade&lt;&#x3D;100), 	</span><br><span class="line">          PRIMARY KEY (Sno,Cno),</span><br><span class="line">	      FOREIGN KEY(Sno) REFERENCES Student(Sno),</span><br><span class="line">	      FOREIGN KEY(Cno) REFERENCES Course(Cno)</span><br><span class="line"> 	     );</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = blue>元组上的约束条件的定义：</font></p>
<blockquote>
<p>与属性上约束条件的定义类似，在CREATE TABLE语句中可以用CHECK短语定义元组上的约束条件，即元组级的限制。同属性值限制相比，元组级的限制可以设置不同属性之间的取值的相互约束条件。</p>
</blockquote>
<ul>
<li>
<p>当学生的性别是男时，其名字不能以Ms.打头。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE Student</span><br><span class="line">		   (Sno CHAR(9),</span><br><span class="line">		    Sname CHAR(8) NOT NULL,</span><br><span class="line">		    Ssex CHAR(2),</span><br><span class="line">		    Sage SMALLINT,</span><br><span class="line">		    Sdept CHAR(20),</span><br><span class="line">		    PRIMARY KEY(Sno),</span><br><span class="line">            &#x2F;*定义了元组中Sname和Ssex两个属性值之间的约束条件*&#x2F;</span><br><span class="line">		    CHECK(Ssex&#x3D;&#39;女&#39; OR Sname NOT LIKE &#39;Ms.%&#39;)	</span><br><span class="line">		   );</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<br/>
<h4 id="4）完整性约束命名子句">4）完整性约束命名子句</h4>
<ul>
<li><font color = green size = 4>定义：</font>以上讲解的完整性约束约束条件都在CHECK TABLE 语句中定义。SQL还在CHECK TABLE 语句中提供了完整性约束命名子句CONSTRAINT，用来对完整性约束条件命名。从而可以灵活地增加、删除一个完整性约束条件。</li>
</ul>
<br/>
<ul>
<li>
<p><font color = green size = 4>完整性约束条件命名子句：</font></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CONSTRAINT &lt;完整性约束条件名&gt;[PRIMARY KEY 短语|FOREIGN KEY 短语|CHECK 短语]</span><br></pre></td></tr></table></figure>
<br/>
<blockquote>
<p>建立学生登记表Student，要求学号在90000-99999之间，姓名不能取空值，年龄小于30，性别只能是’男‘或’女‘。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE Student</span><br><span class="line">		(Sno NUMERIC(6),</span><br><span class="line">  		 CONSTRAINT C1 CHECK(Sno BETWEEN 90000 AND 99999),</span><br><span class="line">		 Sname CHAR(20),</span><br><span class="line">		 CONSTRAINT C2 CHECK(Sname NOT NULL),</span><br><span class="line">		 Sage NUMERIC(3),</span><br><span class="line">		 CONSTRAINT C3 CHECK(Sage&lt;30),</span><br><span class="line">		 Ssex CHAR(2),</span><br><span class="line">		 CONSTRAINT C4 CHECK(Ssex IN(&#39;男&#39; ,&#39;女&#39;)),</span><br><span class="line">		 CONSTRAINT StudentKey PRIMARY KEY(Sno)</span><br><span class="line">		);</span><br></pre></td></tr></table></figure>
<br/>
<blockquote>
<p>建立教师表TEACHER,要求每个教师的应发工资不低于3000元；应发工资实际上就是实发工资列Sal与扣除项Deduct之和。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE TEACHER</span><br><span class="line">		(Eno NUMERIC(4) PRIMARY KEY,</span><br><span class="line">		 Ename CHAR(10),</span><br><span class="line">		 Job CHAR(8),</span><br><span class="line"> 		 Sal NUMERIC(7,2),</span><br><span class="line">		 Deduct NUMERIC(7,2),</span><br><span class="line">		 Deptno NUMERIC(2),</span><br><span class="line">		 CONSTRAINT EMPFKey FOREIGN KEY(Deptno) REFERENCES DEPT(Deptno),</span><br><span class="line">		 CONSTRAINT C1 CHECK (Sal+Deduct &gt;&#x3D; 3000)</span><br><span class="line">		);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = green size = 4>修改表中完整性限制：</font></p>
<blockquote>
<p>可以使用ALTER TABLE语句修改表中的完整性限制；去掉Student表中对性别的限制。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE Student</span><br><span class="line">DROP CONSTRAINT C4;</span><br></pre></td></tr></table></figure>
<br/>
<blockquote>
<p>修改表Student中的约束条件，要求学号改为900000-999999之间，年龄由小于30改为小于40.（<span style="background: linear-gradient(to right, #74ebd5, #acb6e5);">可以先删除原来的约束条件，再增加新的约束条件</span>）</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE Student</span><br><span class="line">DROP CONSTRAINT C1;</span><br><span class="line">ALTER TABLE Student</span><br><span class="line">ADD CONSTRAINT C1 CHECK (Sno BETWEEN 900000 AND 999999),</span><br><span class="line">ALTER TABLE Student</span><br><span class="line">DROP CONSTRAINT C3;</span><br><span class="line">ALTER TABLE Student</span><br><span class="line">ADD CONSTRAINT C3 CHECK(Sage&lt;40);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<br/>
<h4 id="5）触发器">5）触发器</h4>
<ul>
<li>
<p><font color = green size = 4>定义：</font>trigger，是指事先为某张表绑定一段代码，当表中的某些内容发生改变（增、删、改）的时候，系统会自动触发代码并执行。</p>
<br/>
<p><font color = green>触发器包含三个要素，分别为：</font></p>
<blockquote>
<p>事件类型：增删改，即insert、delete和update；</p>
<p>触发时间：事件类型前和后，即before和after；</p>
<p>触发对象：表中的每一条记录（行），即整张表。</p>
<p>每张表只能拥有一种触发时间的一种事件类型的触发器，即每张表最多可以拥有 6 种触发器。</p>
</blockquote>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = green size = 4>创建触发器：</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建触发器基本语法</span></span><br><span class="line">delimiter $  <span class="comment">-- 自定义符号;临时修改语句结束符，在后续语句中只有遇到自定义符号才会结束语句</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> + 触发器名称 + 触发器时间 + 事件类型 <span class="keyword">on</span> 表名 <span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span></span><br><span class="line"><span class="keyword">begin</span> <span class="comment">-- 代表触发器内容开始</span></span><br><span class="line"><span class="comment">-- 触发器内容主体，每行用分号结尾</span></span><br><span class="line"><span class="keyword">end</span> <span class="comment">-- 代表触发器内容结束</span></span><br><span class="line">$  <span class="comment">-- 自定义符号;用于结束语句</span></span><br><span class="line">delimiter ; <span class="comment">-- 恢复语句结束符</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>trigger_name : 触发器名称，用户自行指定<br>
trigger_time： 触发时机，取值BEFORE（之前）、AFTER（之后）<br>
trigger_event : 出发事件，INSERT、UPDATE、DELETE。（插入、更新、删除）<br>
tbl_name : 需要建立触发器的表名。<br>
trigger_stmt : 触发程序体，可以是一条SQL语句或是BEGIN和END包含的索条语句</p>
</blockquote>
<br/>
<ul>
<li>
<p><font color = blue>BEGIN…END详解：</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">[statement_list]</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><span style="background: linear-gradient(to right, #74ebd5, #acb6e5);">statement_list 使用方法：</span><br>
statement_list 代表一个或多个语句的列表，列表内的每条语句都必须用分号（;）来结尾(默认值)<br>
我们可以使用DELIMITERE指定自定义的定界符。<br>
<span style="background: linear-gradient(to right, #74ebd5, #acb6e5);">DELIMITER new_delemiter：</span><br>
new_delemiter 可以设为1个或多个长度的符号，默认的是分号（;），我们可以把它修改为其他符号，如：DELIMITER $(注意：我们修改了定界符使用完了，记得修改回来DELIMITER ；)</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line">create trigger tri_stuInsert after insert</span><br><span class="line">on student for each row</span><br><span class="line">begin</span><br><span class="line">declare c int;</span><br><span class="line">set c &#x3D; (select stucount from class where classID &#x3D; new.classID);</span><br><span class="line">update class set stucount &#x3D; c+1 where classID &#x3D; new.classID;</span><br><span class="line">end $</span><br><span class="line">DELIMITER;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = blue>NEW与OLD关键字：</font></p>
<p>该关键字，表示触发了触发器的那一行数据。</p>
<blockquote>
<p>INSERT触发器中,NEW用来表示将要(BEFORE)或已经(AFTER)插入的新数据。<br>
UPDATE触发器中，OLD用来表示将要或已经被修改的原数据，NEW用来表示将要或已经修改为的新数据。<br>
DELETE触发器中，OLD用来表示将要或已经被删除的原数据。</p>
</blockquote>
<blockquote>
<p><font color = dark>使用方法：</font></p>
<p>NEW.columnName（columnName为相应数据表某一列名）<br>
另外，OLD是只读的，而NEW则可以在触发器中使用SET赋值，这样不会再次触发触发器，造成循环调用（如每插入一个学生前，都在其学号前加&quot;2013&quot;）。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = green size = 4>具体示例：</font></p>
<p><font color = blue>1. 当在删除test表的数据时，会在对应的member对应的id中添加name字段值为world。</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> test_tt <span class="keyword">AFTER</span> <span class="keyword">DELETE</span> <span class="keyword">ON</span> <span class="string">`test`</span>  <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> s <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="string">'hello'</span>;</span><br><span class="line"><span class="keyword">SET</span> s = <span class="string">'world'</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> <span class="string">`member`</span> <span class="keyword">SET</span> <span class="string">`name`</span> = s <span class="keyword">WHERE</span> <span class="keyword">id</span> = OLD.id;</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>
<br/>
<p><font color = blue>2. 在删除test表中的一行数据时，能够把删除之前的name数据写入member表中去。</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> test_tt <span class="keyword">AFTER</span> <span class="keyword">DELETE</span> <span class="keyword">ON</span> <span class="string">`test`</span>  <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="string">`member`</span> <span class="keyword">SET</span> <span class="string">`name`</span> = old.name <span class="keyword">WHERE</span> <span class="keyword">id</span> = OLD.id;</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = green size = 4>判断值后调用触发器：</font></p>
<p><font color = blue>当插入时间小时为20时，对数据进行插入</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`ins_info`</span>;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> ins_info</span><br><span class="line"><span class="keyword">after</span> <span class="keyword">insert</span> <span class="keyword">on</span> nhfxelect <span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span> </span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">HOUR</span>(new.RecordTime)=<span class="string">'20'</span> <span class="keyword">then</span>  </span><br><span class="line">	<span class="keyword">insert</span> <span class="keyword">into</span> nhfxbyhour (UnitDepName, UnitDepCode, ElectCost, TimeJG, RecordTime)</span><br><span class="line">		<span class="keyword">values</span>( <span class="string">'数统学院'</span>, <span class="string">'1'</span>, new.USERKWH, <span class="string">'20'</span>, new.RecordTime);</span><br><span class="line">	<span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>再如更新触发器，如果设置的值为某个范围，才进行操作或性别为&quot;男&quot;或&quot;女&quot;才进行操作。</p>
<p><font color = red>基本语法：</font></p>
<p>if 判断条件 then<br>
sql语句;<br>
end if；</p>
</blockquote>
</li>
</ul>
<br/>
<h3 id="2-Create-Views-创建视图">2. Create Views(创建视图)</h3>
<h4 id="1）视图功能">1）视图功能</h4>
<ul>
<li><font color = green>视图（子查询）：</font>是从一个或多个表导出的虚拟的表，其内容由查询定义。具有普通表的结构，但是不实现数据存储。</li>
</ul>
<br/>
<ul>
<li><font color = green>对视图的修改：</font>单表视图一般用于查询和修改，会改变基本表的数据，多表视图一般用于查询，不会改变基本表的数据。</li>
</ul>
<br/>
<ul>
<li>
<p><font color = green>优点：</font></p>
<ul>
<li>
<p>简化了操作，把经常使用的数据定义为视图。</p>
<p>我们在使用查询时，<span style="background: linear-gradient(to right, #74ebd5, #acb6e5);">在很多时候我们要使用聚合函数，同时还要 显示其它字段的信息，可能还会需要关联到其它表，这时写的语句可能会很长，或如果这个动作频繁发生的话，我们可以创建视图</span>，这以后，我们只需要select * from view就可以啦，这样很方便。</p>
</li>
</ul>
<br/>
<ul>
<li>
<p>安全性，用户只能查询和修改能看到的数据。</p>
<p>因为视图是虚拟的，物理上是不存在的，只是存储了数据的集合，我们可以将基表中重要的字段信息，可以不通过视图给用户，视图是动态的数据的集合，数据是随着基表的更新而更新。同时，用户对视图不可以随意的更改和删除，可以保证数据的安全性。</p>
</li>
</ul>
<br/>
<ul>
<li>
<p>逻辑上的独立性，屏蔽了真实表的结构带来的影响。</p>
<p><font color = blue>视图可以使应用程序和数据库表在一定程度上独立。如果没有视图，应用一定是建立在表上的。有了视图之后，程序可以建立在视图之上，从而程序与数据库表被视图分割开来。</font></p>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = green>缺点: </font></p>
<ul>
<li>
<p>性能差</p>
<p>数据库必须把视图查询转化成对基本表的查询，如果这个视图是由一个复杂的多表查询所定义，那么，即使是视图的一个简单查询，数据库也要把它变成一个复杂的结合体，需要花费一定的时间。</p>
</li>
</ul>
<br/>
<ul>
<li>
<p>修改限制</p>
<p>当用户试图修改视图的某些信息时，数据库必须把它转化为对基本表的某些信息的修改，对于简单的视图来说，这是很方便的，<font color = green>但是，对于比较复杂的视图，可能是不可修改的。</font></p>
</li>
</ul>
</li>
</ul>
<br/>
<h4 id="2）创建视图">2）创建视图</h4>
<ul>
<li>
<p><font color = green size = 4>创建(或修改)视图：</font></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE VIEW 视图名(列1，列2...)</span><br><span class="line"> AS SELECT (列1，列2...)</span><br><span class="line"> FROM ...</span><br><span class="line"> [With Check Option];</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE OR REPLACE VIEW 视图名 </span><br><span class="line">AS SELECT [...] FROM [...];</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE VIEW Student（Sno，Sname，Ssex，Sage，Sdept）</span><br><span class="line">AS</span><br><span class="line">SELECT SX.Sno，SX.Sname，SY.Ssex，SX.Sage，SY.Sdept</span><br><span class="line">FROM SX，SY</span><br><span class="line">WHERE SX.Sno&#x3D;SY.Sno；</span><br></pre></td></tr></table></figure>
<br/>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 查看10号部门所有的员工信息,选择所有列则无需在view名后添加列名</span><br><span class="line">Create or replace view v_emp as select * from emp where deptno&#x3D;10;</span><br></pre></td></tr></table></figure>
<br/>
<ul>
<li><font color = dark>参数：</font>[with check  option]可选项，防止用户对数据插入、删除、更新时操作了视图范围外的基本表的数据。</li>
</ul>
<br/>
<ul>
<li>
<p><font color = blue>组成视图的属性列名或者全部省略或者全部指定，没有第三种选择。如果省略了视图的各个属性列名，则隐含该视图由子查询中SELECT子句目标列中的诸字段组成。但在下列三种情况下必须明确指定组成视图的所有列名：</font></p>
<blockquote>
<p>（1）某个目标列不是单纯的属性名，而是聚集函数或列表达式；<br>
（2）多表连接时选出了几个同名列作为视图的字段；<br>
（3）需要在视图中为某个列启用新的更合适的名字。</p>
</blockquote>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = green size = 4>示例：</font></p>
<p><font color = blue>1. 建立信息系选修了1号课程的学生的视图（包括学号、姓名、成绩）。</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> IS_SI（Sno, Sname, Grade）</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> Student.Sno, Sname，Grade </span><br><span class="line"><span class="keyword">FROM</span> Student, SC</span><br><span class="line"><span class="keyword">WHERE</span> Sdept=<span class="string">'IS'</span><span class="keyword">AND</span></span><br><span class="line">Student.Sno=SC.Sno <span class="keyword">AND</span></span><br><span class="line">SC.Cno= <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><font color = red size = 4>注意：</font></p>
<p><font color = green >由于视图IS_S1的属性列中包含了Student表与SC表的同名列Sno，所以必须在视图名后面明确说明视图的各个属性列名。</font></p>
</blockquote>
<br/>
<p><font color = blue>2. 定义一个反映学生出生年份的视图。</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> BT_S(Sno,Sname,Sbirth)</span><br><span class="line"><span class="keyword">AS</span> <span class="keyword">SELECT</span> Sno,Sname,<span class="number">2014</span>-Sage </span><br><span class="line"><span class="keyword">FROM</span> Student;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><font color = red size = 4>注意：</font></p>
<p><font color = green >这里视图BTS是一个带表达式的视图。视图中的出生年份值是通过计算得到的。</font></p>
</blockquote>
<br/>
<p><font color = blue>3. 将学生的学号及平均成绩定义为一个视图。</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> S_G（Sno, Gavg）</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> Sno, <span class="keyword">AVG</span>（Grade）</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Sno;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><font color = red size = 4>注意：</font></p>
<p><font color = green>由于AS子句中SELECT语句的目标列平均成绩是通过作用聚集函数得到的，所以CREATE VIEW中必须明确定义组成S_G视图的各个属性列名。SG是一个分组视图。</font></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = green size = 4>视图运用(查询)：</font></p>
<p><font color = blue size= 4>1. 使用视图和使用表完全一样，只需要把视图当成一张表就OK了；视图是一张虚拟表。</font></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 从视图中检索数据</span><br><span class="line">select * from v_student;</span><br></pre></td></tr></table></figure>
<br/>
<p><font color = blue size= 4>2. 从数据字典中取出视图的定义，把定义中的子查询和用户的查询结合起来，转换成等价的对基本表的查询，然后再执行修正了的查询。这一转换过程称为视图消解（view resolution）。</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 消解过程：</span></span><br><span class="line"><span class="keyword">SELECT</span> Sno,Sage</span><br><span class="line"><span class="keyword">FROM</span> IS_Student</span><br><span class="line"><span class="keyword">WHERE</span> Sage&lt;<span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 相当于</span></span><br><span class="line"><span class="keyword">SELECT</span> Sno,Sage</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sdept=<span class="string">'IS'</span> <span class="keyword">AND</span> Sage&lt;<span class="number">20</span>;</span><br></pre></td></tr></table></figure>
<br/>
<p><font color = blue size= 4>3. 在一般情况下，视图查询的转换是直截了当的。但有些情况下，这种转换不能直接进行，查询时就会出现问题。</font></p>
<ul>
<li>
<p><font color = green>在SG视图中查询平均成绩在90分以上的学生<br>
学号和平均成绩，语句为</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>*</span><br><span class="line"><span class="keyword">FROM</span> S_G</span><br><span class="line"><span class="keyword">WHERE</span> Gavg&gt;=<span class="number">90</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><font color = green>定义SG视图的子查询为</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno,<span class="keyword">AVG</span>(Grade)</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Sno;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><font color = green>将本例中的查询语句与定义SG视图的子查询结合，形成下列查询语句：</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno,<span class="keyword">AVG</span>(Grade)</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">AVG</span>(Grade)&gt;=<span class="number">90</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Sno;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><font color = red size = 4>注意：</font></p>
<p><font color = green>因为WHERE子句中是不能用聚集函数作为条件表达式的，因此执行此修正后的查询将会出现语法错误。正确转换的查询语句应该是：</font></p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno,<span class="keyword">AVG</span>(Grade)</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Sno</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">AVG</span>(Grade)&gt;=<span class="number">90</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<br/>
<h4 id="3）修改视图">3）修改视图</h4>
<ul>
<li>
<p><font color = green size = 4>视图与数据变更：</font></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO v_order(pid,pname,price) VALUES(&#39;p010&#39;,&#39;柴油&#39;,&#39;34&#39;);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*将基表的ename字段修改了*&#x2F;</span><br><span class="line">update v_emp set ename&#x3D;&#39;kitty&#39; where empno&#x3D;7839;</span><br><span class="line"></span><br><span class="line">&#x2F;*将视图包含的deptno均修改为20，在基表中修改*&#x2F;</span><br><span class="line">update v_emp set deptno &#x3D; 20;</span><br><span class="line"></span><br><span class="line">&#x2F;*结果集为空，基表中不存在10号部门了*&#x2F;</span><br><span class="line">select * from v_emp where deptno &#x3D; 10;</span><br><span class="line"></span><br><span class="line">&#x2F;*with check option保证视图查询条件不被修改，但其他字段可以修改*&#x2F;</span><br><span class="line">create view v_emp as select * from emp where deptno &#x3D; 10 with check option;</span><br></pre></td></tr></table></figure>
<br/>
<blockquote>
<p><font color = dark size = 4>With check option作用：</font></p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> IS_student</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> sno,sname,sage</span><br><span class="line"><span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">where</span> sdept=<span class="string">'IS'</span></span><br><span class="line"><span class="keyword">with</span> <span class="keyword">check</span> <span class="keyword">option</span>;   </span><br><span class="line"></span><br><span class="line"><span class="comment">--- 加上了with check option;后，不能执行以下插入操作：</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> is_student</span><br><span class="line"><span class="keyword">values</span>(<span class="string">'95100'</span>,<span class="string">'李娜'</span>,<span class="number">12</span>)</span><br></pre></td></tr></table></figure>
<br/>
<p><font color = green>什么原因？不加上with check option则可以！</font></p>
<blockquote>
<p><span style="background: linear-gradient(to right, #f2994a, #f2c94c);">with check option可以这么解释：</span></p>
<p>通过视图进行的修改，必须也能通过该视图看到修改后的结果。比如你insert，那么加的这条记录在刷新视图后必须可以看到；如果修改，修改完的结果也必须能通过该视图看到；如果删除，当然只能删除视图里有显示的记录。</p>
</blockquote>
<p><font color = green>而你只是查询出sdept='is’的纪录，你插入的根本不符合sdept='is’呀，所以就不行</font></p>
<br/>
<p><img data-src="https://image.zxkidea.top/blog/20200306/W2uyh5b4rgFC.png?imageslim" alt="zxk"></p>
<br/>
<p><font color = dark size = 4>可更新视图条件：</font></p>
<blockquote>
<p>（1）若视图是由两个以上基本表导出的，则此视图不允许更新。<br>
（2）若视图的字段来自字段表达式或常数，则不允许对此视图执行INSERT和UPDATE操作，但允许执行			DELETE操作。<br>
（3）若视图的字段来自聚集函数，则此视图不允许更新。<br>
（4）若视图定义中含有GROUP BY子句，则此视图不允许更新。<br>
（5）若视图定义中含有DISTINCT短语，则此视图不允许更新。<br>
（6）若视图定义中有嵌套查询，并且内层查询的FROM子句中涉及的表也是导出该视图的基本表，则此视			图不允许更新。</p>
</blockquote>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = green size = 4>删除视图：</font></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop view v_emp; -- 删除视图（DDL操作）</span><br></pre></td></tr></table></figure>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = red size = 4>注意事项：</font></p>
<ul>
<li>
<p>通过视图可以修改基表数据，但视图一般只做查询。</p>
</li>
<li>
<p><font color = dark>with check option</font>关键词用于保证视图的查询条件不被修改，但其他字段可以修改。</p>
</li>
</ul>
</li>
</ul>
<br/>
<h2 id="Ch8-Indexing-索引">Ch8. Indexing(索引)</h2>
<h3 id="1-定义">1. 定义</h3>
<p><font color = green size = 4>系统根据某种算法，将已有的数据（未来可能新增的数据），单独建立一个文件，这个文件能够实现快速匹配数据，并且能够快速的找到对应的记录，几乎所有的索引都是建立在字段之上的。</font></p>
<br/>
<ul>
<li>
<p><font color = green size = 4>数据库索引有多种类型，常见索引包括顺序文件上的索引、B+树索引、散列（hash）索引、位图索引等</font></p>
<blockquote>
<ol>
<li>
<p>顺序文件上的索引是针对按指定属性值升序或降序存储的关系，在该属性上建立一个顺序索引文件，索引文件由属性值和相应的元组指针组成。</p>
</li>
<li>
<p>B+树索引是将索引属性组织成B+树形式，B+树的叶结点为属性值和相应的元组指针。B+树索引具有动态平衡的优点。</p>
</li>
<li>
<p>散列索引是建立若干个桶，将索引属性按照其散列函数值映射到相应桶中，桶中存放索引属性值和相应的元组指针。散列索引具有查找速度快的特点。位图索引是用位向量记录索引属性中可能出现的值，每个位向量对应一个可能值。</p>
</li>
</ol>
</blockquote>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = green size = 4>常用的索引类型：普通索引<br>
、唯一索引<br>
、组合索引</font></p>
<blockquote>
<p>普通索引和唯一索引的创建方式有三种，分别是直接创建、修改表结构创建、创建表时同时创建，注意组合索引的组合规则是最左前缀索引</p>
</blockquote>
</li>
</ul>
<br/>
<h3 id="2-索引的意义：">2. 索引的意义：</h3>
<blockquote>
<p>提升查询数据的效率；</p>
<p>约束数据的有效性。</p>
</blockquote>
<br/>
<ul>
<li><font color = green size = 4>但是增加索引是有前提条件的，这是因为索引本身会产生索引文件（有的时候可能会比数据本身都大），因此非常耗费磁盘空间。</font></li>
<li><font color = green size = 4>如果某个字段需要作为查询的条件经常使用，可以使用索引；</font></li>
<li><font color = green size = 4>如果某个字段需要进行数据的有效性约束，也可以使用索引（主键或唯一键）。</font></li>
</ul>
<br/>
<h3 id="3-索引的类型">3. 索引的类型</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 直接创建索引</span><br><span class="line">CREATE INDEX index_name ON table(column(length))</span><br><span class="line"></span><br><span class="line">-- 创建唯一索引</span><br><span class="line">CREATE UNIQUE INDEX index_name ON table(column(length)) </span><br><span class="line"></span><br><span class="line">-- 组合索引</span><br><span class="line">ALTER TABLE article ADD INDEX index_titme_time (title(50),time(10))</span><br><span class="line"></span><br><span class="line">-- 建立这样的组合索引，其实是相当于分别建立了下面两组组合索引：</span><br><span class="line">–title,time</span><br><span class="line"></span><br><span class="line">–title</span><br><span class="line"></span><br><span class="line">-- 删除索引</span><br><span class="line">DROP INDEX index_name ON table</span><br></pre></td></tr></table></figure>
<blockquote>
<p><font color = red>注意：</font></p>
<p>为什么没有time这样的组合索引呢？这是因为MySQL组合索引“最左前缀”的结果。<br>
简单的理解就是只从最左面的开始组合。并不是只要包含这两列的查询都会用到该组合索引</p>
</blockquote>
<br/>
<h3 id="4-索引的优化">4. 索引的优化</h3>
<ul>
<li><font color = green size = 4>何时使用聚集索引或非聚集索引？</font></li>
<li><font color = green size = 4>索引不会包含有NULL值的列</font></li>
<li><font color = green size = 4>使用短索引</font></li>
<li><font color = green size = 4>索引列排序</font></li>
<li><font color = green size = 4>like语句操作</font></li>
<li><font color = green size = 4>不要在列上进行运算</font></li>
</ul>
<blockquote>
<p><font color = red>总结：</font>MySQL只对以下操作符才使用索引：&lt;,&lt;=,=,&gt;,&gt;=,between,in,以及某些时候的like(不以通配符%或_开头的情形)。</p>
</blockquote>
]]></content>
      <categories>
        <category>数据库基础</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>考研</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>关系模式范式分解教程（3NF与BCNF口诀）</title>
    <url>/posts/6244050a.html</url>
    <content><![CDATA[<p>转载自：<a href="https://www.cnblogs.com/kungfupanda/p/12362163.html" target="_blank" rel="noopener">https://www.cnblogs.com/kungfupanda/p/12362163.html</a></p>
<p>【通俗易懂】关系模式范式分解教程 3NF与BCNF口诀!小白也能看懂</p>
<hr>
<h2 id="1-在模式分解之前，首先对于1NF-2NF-3NF-BCNF做一个简明扼要的介绍。">1. 在模式分解之前，首先对于1NF,2NF,3NF,BCNF做一个简明扼要的介绍。</h2>
<p>1NF是指数据库表的每一列都是不可分割的基本数据项，即实体中的某个属性不能有多个值或者不能有重复的属性。</p>
<p>2NF要求属性完全依赖于主键，不能存在仅依赖主关键字一部分的属性。</p>
<a id="more"></a>
<p>3NF要求每一个非主属性既不部分依赖于码也不传递依赖于码。</p>
<p>BCNF消除了主属性对候选码的部分和传递函数依赖。</p>
<br/>
<blockquote>
<p><font color = red size = 4>注：</font></p>
<ol>
<li>
<p>相对于BCNF，3NF允许存在主属性对候选码的传递依赖和部分依赖。</p>
</li>
<li>
<p>BCNF比较抽象，略作解释：在学生信息表里，学号是一个候选码，学号可确定学生姓名；(班级,学生姓名）也是一组候选码，有(班级,学生姓名）-&gt; 学号，因此在主属性间形成了传递依赖。</p>
</li>
<li>
<p>若对概念不清晰，关于码、候选码、主属性、非主属性的解释可参看：</p>
<p><a href="https://blog.csdn.net/sumaliqinghua/article/details/85872446#commentBox" target="_blank" rel="noopener">https://blog.csdn.net/sumaliqinghua/article/details/85872446#commentBox</a></p>
</li>
</ol>
</blockquote>
<br/>
<h2 id="2-我们的重点是讲解范式分解：">2. 我们的重点是讲解范式分解：</h2>
<h3 id="一、3NF分解">一、3NF分解</h3>
<p>分为保持依赖和无损连接</p>
<p>为了说明求解保持依赖，我们先要会求最小依赖集</p>
<h4 id="（1）最小依赖集求法：">（1）最小依赖集求法：</h4>
<blockquote>
<p><font color = red size = 4>口诀：</font></p>
<p><font color = green>右侧先拆单，依赖依次删。</font></p>
<p><font color = green>还原即可删，再拆左非单。</font></p>
</blockquote>
<p>通过求下面的最小依赖集对口诀进行解释。</p>
 <br/>
<h4 id="（2）3NF分解：">（2）3NF分解：</h4>
<blockquote>
<p><font color = red size = 4>口诀：</font></p>
<p><font color = green>保函依赖分解题，先求最小依赖集。</font></p>
<p><font color = green>依赖两侧未出现，分成子集放一边，剩余依赖变子集。</font></p>
<p><font color = green>若要连接成无损，再添候选做子集。</font></p>
</blockquote>
<p><br/>下面通过几道例题讲解口诀：</p>
<p><font color = blue>例1.已知R(ABCDE), F = {A -&gt;D,E-&gt;D,D-&gt;B,BC-&gt;D,DC-&gt;A}，求保持函数依赖的3NF分解，和具有无损连接性及保持函数依赖的3NF分解</font></p>
<p><span style="background: linear-gradient(to right, #74ebd5, #acb6e5);">第一步</span>：保函依赖分解题，先求最小依赖集。先求出R的最小依赖集，可得F~m~ = {A -&gt;D,E-&gt;D,D-&gt;B,BC-&gt;D,DC-&gt;A}</p>
<p><span style="background: linear-gradient(to right, #74ebd5, #acb6e5);">第二步</span>：依赖两侧未出现，分成子集放一边。首先可以发现没有不出现在两侧的元素不用单独分出一个子集，“剩余依赖变子集”然后我们将各依赖分别划分为子集得到：{AD}，{ED}，{DB}，{BCD}，{DCA}，即为所求保持函数依赖的3NF分解</p>
<p><span style="background: linear-gradient(to right, #74ebd5, #acb6e5);">第三步</span>：若要连接成无损，再添候选做子集。</p>
<p>(1) 候选码的求解：所谓候选码即能决定整个关系的，我们通过找未出现在依赖右边的和两侧均未出现的元素即可求得，</p>
<p>(2) 可以发现CE未出现在右边，因此候选码为{CE}。故所求具有无损连接性及保持函数依赖的3NF分解为{AD}，{ED}，{DB}，{BCD}，{DCA}，{CE}</p>
 <br/>
<p><font color = blue>例2.关系模式R，有U={A,B,C,D,E,G}，F={B-&gt;G,CE-&gt;B,C-&gt;A,CE-&gt;G,B-&gt;D,C-&gt;D}，将关系模式分解为3NF且保持函数依赖</font></p>
<p>将关系模式分解为3NF且保持函数依赖：</p>
<p><span style="background: linear-gradient(to right, #74ebd5, #acb6e5);">第一步</span>：保函依赖分解题，先求最小依赖集。先求出R的最小依赖集，</p>
<p>假设B-&gt;G冗余，则(B)^+^ = BD，没有G故不冗余。</p>
<p>假设CE-&gt;B冗余，则(CE)^+^ = CEGDA，没有B故不冗余。</p>
<p>假设C-&gt;A冗余，则( C )^+^ = CD，故不冗余。</p>
<p>一次可以得到最小函数依赖集F~m~ = {B-&gt;G,CE-&gt;B,C-&gt;A,B-&gt;D,C-&gt;D}</p>
<p><span style="background: linear-gradient(to right, #74ebd5, #acb6e5);">第二步</span>：依赖两侧未出现，分成子集放一边，剩余依赖变子集。首先可以发现没有不出现在两侧的元素，然后我们将各依赖分别划分为子集得{BG}，{CEB}，{CA}，{BD}，{CD}，即为所求保持函数依赖的3NF分解</p>
<p><span style="background: linear-gradient(to right, #74ebd5, #acb6e5);">第三步</span>：若要连接成无损，再添候选做子集。找到R的一个候选码为{ACE}。故所求具有无损连接性及保持函数依赖的3NF分解为{BG}，{CEB}，{CA}，{BD}，{CD}，{ACE} (注：范式分解并不唯一，正确即可)</p>
 <br/>
<h3 id="二、BCNF分解：">二、BCNF分解：</h3>
<p>将关系模式R&lt;U,F&gt;分解为一个BCNF的基本步骤是：</p>
<blockquote>
<p><font color = green>1）先求最小依赖集，候码非码成子集</font></p>
<p><font color = green>2）余下左侧全候码，完成BCNF题。</font></p>
</blockquote>
<br/>
<p><font color = blue>例.关系模式R,有U={A,B,C,D,E,G}，F={B-&gt;G,CE-&gt;B,C-&gt;A,CE-&gt;G,B-&gt;D,C-&gt;D}，将关系模式分解为BCNF且保持函数依赖</font></p>
<p>将关系模式分解为BCNF且保持函数依赖：</p>
<p><span style="background: linear-gradient(to right, #74ebd5, #acb6e5);">第一步</span>：先求最小依赖集。可以发现CE-&gt;G多余，因此最小依赖集为F~m~ = {B-&gt;G,CE-&gt;B,C-&gt;A,B-&gt;D,C-&gt;D}；</p>
<p><span style="background: linear-gradient(to right, #74ebd5, #acb6e5);">第二步</span>：候码非码成子集。由于候选码为(CE)，因此将CE-&gt;B划分出子集（BCE），而B-&gt;G，B-&gt;D左侧均不含主属性C、E中的任何一个，故划分出(BG)，(BD）；</p>
<p><span style="background: linear-gradient(to right, #74ebd5, #acb6e5);">第三步</span>：此时剩余依赖F’ = {C-&gt;A，C-&gt;D}，剩余元素{A,C,D}，检查发现函数依赖左侧都是候选码（<span style="background: linear-gradient(to right, #f2994a, #f2c94c);">新的依赖F’的候选码</span>），即完成BCNF分解，如果不满足则继续分解余下的；</p>
<p>于是BCNF分解的最后结果为{(BG)，(BD)，(ACD)，(BCE)}。</p>
<br/>
<h3 id="三、总结">三、总结</h3>
<p>1.闭包</p>
<p>2.候选码</p>
<p>3.最小依赖集</p>
<p>4.3NF分解</p>
<p>5.BCNF分解</p>
]]></content>
      <categories>
        <category>数据库基础</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>考研</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>DatabaseNotes-Ch5,6</title>
    <url>/posts/780f9bb4.html</url>
    <content><![CDATA[<h2 id="Ch5-Embedded-SQL-（嵌入式SQL）">Ch5. Embedded SQL （嵌入式SQL）</h2>
<h3 id="1-定义">1. 定义</h3>
<p><font color = blue size = 4>嵌入式SQL是将SQL嵌入到某一种高级语言之中，如C/C++,Java等 这种高级语言被称为宿主语言</font></p>
<br/>
<h3 id="2-特性">2. 特性</h3>
<p>​	<font color = blue size = 4>1）继承了高级语言的过程控制性</font></p>
<a id="more"></a>
<p>​	<font color = blue size = 4>2) 结合了SQL语言的复杂结果集操作的非过程性</font></p>
<p>​	<font color = blue size = 4>3) 为数据库操作者提供了安全可靠的操作方式：通过应用程序进行操作</font></p>
<br/>
<h3 id="3-和交互式SQL的对比">3. 和交互式SQL的对比</h3>
<p><font color = blue size = 4>1) 交互式(Interactive SQL ):</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> Sname,Sage <span class="keyword">from</span> Students <span class="keyword">where</span> Sname = <span class="string">"张三"</span>；</span><br></pre></td></tr></table></figure>
<br/>
<p><font color = blue size = 4>2) 嵌入式(Embedded SQL, 此文宿主语言为C):</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">exec sql <span class="keyword">select</span> Sname,Sage <span class="keyword">into</span> :vSname,:vSage <span class="keyword">from</span> Students <span class="keyword">where</span> Sname =  <span class="string">"张三"</span>；</span><br></pre></td></tr></table></figure>
<blockquote>
<p><font color = green size  = 4>1. exec sql : 引导SQL语句，提供给C编译器,以便对SQl语句预编译成C编译器可识别的语句</font></p>
<p><font color = green size = 4>2. into 子句: 用于把SQL 语句的检索结果赋给高级语言的程序变量</font></p>
<p><font color = green size = 4>3. 用冒号开头: </font></p>
<ul>
<li><font color = green size = 4>表示高级语言的程序变量  :vsname  , :vsage</font></li>
<li><font color = green size = 4>冒号很重要, 用于区分是程序变量还是表的字段!!</font></li>
</ul>
</blockquote>
<br/>
<h3 id="4-宿主语言如何与数据库连接">4. 宿主语言如何与数据库连接</h3>
<p><span style="background: linear-gradient(to right, #f2994a, #f2c94c);"><font color = green size = 4>连接：</font></span></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">exec sql connect to target-server as connect-name user user-name;</span><br><span class="line">or</span><br><span class="line">exec sql connect to default;</span><br></pre></td></tr></table></figure>
<p><span style="background: linear-gradient(to right, #f2994a, #f2c94c);"><font color = green size = 4>断开：</font></span></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">exec sql disconnect connect-name;</span><br><span class="line">or</span><br><span class="line">exec sql disconnect current;</span><br></pre></td></tr></table></figure>
<br/>
<h3 id="5-如何将宿主语言的变量传递给SQL语句">5. 如何将宿主语言的变量传递给SQL语句</h3>
<p><span style="background: linear-gradient(to right, #f2994a, #f2c94c);"><font color = green size = 4>变量声明：</font></span></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">exec sql <span class="keyword">begin</span> <span class="keyword">declare</span> <span class="keyword">section</span>;</span><br><span class="line">     char vSname[10],specName[10]="张三"</span><br><span class="line">     int vSage;</span><br><span class="line">exec sql <span class="keyword">end</span> <span class="keyword">declare</span> <span class="keyword">section</span>;</span><br></pre></td></tr></table></figure>
<br/>
<p><span style="background: linear-gradient(to right, #f2994a, #f2c94c);"><font color = green size = 4>变量使用：</font></span></p>
<ul>
<li><font color = green size = 4>变量可传递给SQL语句的where等字句，以便SQL语言能够按照指定的要求进行检索</font></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">exec sql <span class="keyword">select</span> Sname,Sage <span class="keyword">into</span> </span><br><span class="line"><span class="comment">--宿主程序的变量</span></span><br><span class="line">:vSname.:vSage <span class="keyword">from</span> Student <span class="keyword">where</span> Sname=:specName;</span><br></pre></td></tr></table></figure>
<br/>
<h3 id="6-SQL语句如何执行">6. SQL语句如何执行</h3>
<p><font color = blue size = 4>1) SQL语句在执行过程中，必须有提交和撤销语句才能确认其操作结果 </font></p>
<p><span style="background: linear-gradient(to right, #f2994a, #f2c94c);"><font color = green size = 4>提交：</font></span></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">exec sql <span class="keyword">commit</span> <span class="keyword">work</span></span><br></pre></td></tr></table></figure>
<p><span style="background: linear-gradient(to right, #f2994a, #f2c94c);"><font color = green size = 4>撤销：</font></span></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">exec sql <span class="keyword">rollback</span> <span class="keyword">work</span></span><br></pre></td></tr></table></figure>
<br/>
<h3 id="7-事务">7. 事务</h3>
<p><font color = blue size = 4>1) 定义: </font></p>
<ul>
<li><font color = green size = 4>事务是一个存取或改变数据库内容的程序的一次执行，或者说一条或多条SQL语句的一次执行被看做一个事务，一般由应用程序提出，有开始和结束，结束前需要提交或撤销</font></li>
</ul>
<br/>
<p><font color = blue size = 4>2) 事务的ACID 特性</font></p>
<ul>
<li><font color = red size = 4>原子性Atoomicity：</font>DBMS能够保证事务的一组更新操作是原子不可分的，要么全做，要么全不做</li>
<li><font color = red size = 4>一致性Consistency: </font> DBMS保证事务的操作状态是正确的</li>
<li><font color = red size = 4>隔离性Isolation:</font> DBMS保证并发的多个事务之间相互不受影响</li>
<li><font color = red size = 4>持久性Durability：</font>DBMS保证已提交事务的影响是持久的，被撤销事务的影响是可恢复的</li>
</ul>
<br/>
<h3 id="8-如何将SQL检索到的结构传递回宿主程序进行处理">8. 如何将SQL检索到的结构传递回宿主程序进行处理</h3>
<p><font color = blue size = 4>1) 单行结果处理</font></p>
<ul>
<li>
<p><font color = green size = 4>检索单行结果，可以将结果直接传到==宿主程序的变量==中</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">exec sql <span class="keyword">select</span> [<span class="keyword">ALL</span>|<span class="keyword">DISTINCT</span>] expression [,expression...]</span><br><span class="line">     <span class="keyword">INTO</span> host-<span class="keyword">variable</span>,[host-<span class="keyword">variable</span>,...]</span><br><span class="line">     <span class="keyword">From</span> tableref [corr_name][,tableref[corr_name]...]</span><br><span class="line">     <span class="keyword">Where</span> search_condition;</span><br></pre></td></tr></table></figure>
<p><font color = green size = 4>Eg：</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">exec sql <span class="keyword">select</span> Sname,Sage <span class="keyword">into</span> :vSname,:vSage <span class="keyword">from</span> Student <span class="keyword">where</span> Sname=:specName;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<br/>
<p><font color = blue size = 4>2) 多行结果处理</font></p>
<p><font color = red size = 4>游标(Cursor)</font></p>
<blockquote>
<p><font color = green size  = 4>1. 游标是指向某检索记录集的指针，通过这个指针的移动，每次读一行，处理一行，再读一行，直到处理完毕 ;</font></p>
<p><font color = green size  = 4>2. 读一行的操作是通过Fetch…into实现的，每一次Fetch，都是先向下移动指针，然后再读取，记录集有结束表示EOF,用来标记后面已经没有记录了 ;</font></p>
<p><font color = green size  = 4>3. 游标的使用需要先定义，再打开，接着一条一条处理，最后关闭 。</font></p>
</blockquote>
<br/>
<ul>
<li>
<p><font color = green size = 4>Cursor的定义：</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXEC SQL <span class="keyword">DECLARE</span> cursor_name <span class="keyword">CURSOR</span> <span class="keyword">FOR</span></span><br><span class="line">     Subquery</span><br><span class="line">     [<span class="keyword">ORDER</span>　<span class="keyword">BY</span> result_column [<span class="keyword">ASC</span>|<span class="keyword">DESC</span>][,result_column...]]</span><br><span class="line">     [<span class="keyword">FOR</span> [<span class="keyword">READ</span> <span class="keyword">ONLY</span> |<span class="keyword">UPDATE</span> [<span class="keyword">OF</span> columnname[,columnname....]]]]</span><br></pre></td></tr></table></figure>
<p><font color = green size = 4>Eg：</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">exec sql <span class="keyword">declare</span> cur_student <span class="keyword">cursor</span> <span class="keyword">for</span></span><br><span class="line">     <span class="keyword">select</span> Sno ,Sname,Sclass <span class="keyword">from</span> Student <span class="keyword">where</span> Sclass=:vClass</span><br><span class="line">     <span class="keyword">order</span> <span class="keyword">by</span> Sno</span><br><span class="line"><span class="comment">--只读属性</span></span><br><span class="line">     <span class="keyword">for</span> <span class="keyword">read</span> <span class="keyword">only</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = green size = 4>Cursor的打开和关闭 </font></p>
<p><span style="background: linear-gradient(to right, #f2994a, #f2c94c);"><font color = green szie = 4>打开：</font></span></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">exec sql open cursor_name;</span><br></pre></td></tr></table></figure>
<p><span style="background: linear-gradient(to right, #f2994a, #f2c94c);"><font color = green size = 4>关闭：</font></span></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">exec sql close cursor_name;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = green size = 4>Cursor的数据读取（多行，并传入宿主程序变量）</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">exec sql fetch cursor_name</span><br><span class="line">     into host-variable,[host-variable,...]</span><br></pre></td></tr></table></figure>
<p><font color = green size = 4>Eg：</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">exec sql fetch cur_student into :vSno,:vSname,:vSage;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<br/>
<h3 id="9-数据库的删除与更新">9. 数据库的删除与更新</h3>
<p><font color = blue size = 4>1) 删除</font></p>
<ul>
<li>
<p><font color = green size = 4>查找删除：</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">exec sql <span class="keyword">delete</span> <span class="keyword">from</span> tablename [corr_name] <span class="keyword">where</span> search_condition</span><br></pre></td></tr></table></figure>
<p><font color = green size = 4>Eg：</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">exec sql <span class="keyword">delete</span> <span class="keyword">from</span> customers c <span class="keyword">where</span> c.city=<span class="string">'Harbin'</span> <span class="keyword">and</span> <span class="keyword">not</span> <span class="keyword">exists</span> (<span class="keyword">select</span> * <span class="keyword">from</span> orders o <span class="keyword">where</span> o.cid=c.cid)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = green size = 4>定位删除：</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">exec sql <span class="keyword">delete</span> <span class="keyword">from</span> tablename [corr_name] <span class="keyword">where</span> <span class="keyword">current</span> <span class="keyword">of</span> cursor_name</span><br></pre></td></tr></table></figure>
<p><font color = green size = 4>Eg：</font></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 声明游标</span></span><br><span class="line">exec sql <span class="keyword">declare</span> delcust <span class="keyword">cursor</span> <span class="keyword">for</span></span><br><span class="line">     <span class="keyword">select</span> cid <span class="keyword">from</span> customers c <span class="keyword">where</span> c.city=<span class="string">'harbin'</span> <span class="keyword">and</span> <span class="keyword">not</span> <span class="keyword">exists</span>(<span class="keyword">select</span> * <span class="keyword">from</span> orders o <span class="keyword">where</span> o.cid=c.cid)</span><br><span class="line"><span class="comment">-- 更新属性</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">update</span> <span class="keyword">of</span> cid;</span><br><span class="line"><span class="comment">-- 打开游标</span></span><br><span class="line">exec sql open delcust</span><br><span class="line"><span class="comment">-- 提取变量并删除</span></span><br><span class="line">while(TRUE)&#123;</span><br><span class="line"><span class="comment">-- 循环提取游标内变量到宿主程序的变量</span></span><br><span class="line">     exec sql fetch delcust into :cust_id;</span><br><span class="line"><span class="comment">-- 删除当前行</span></span><br><span class="line">     exec sql <span class="keyword">delete</span> <span class="keyword">from</span> customers <span class="keyword">where</span> <span class="keyword">current</span> <span class="keyword">of</span> delcust;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<br/>
<p><font color = blue size = 4>2) 更新</font></p>
<ul>
<li>
<p><font color = green size = 4>查找更新：</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">exec sql <span class="keyword">update</span> tablename [corr_name] <span class="keyword">SET</span> columname= expr [,columname=expr...] <span class="keyword">where</span> search_condition</span><br></pre></td></tr></table></figure>
<p><font color = green size = 4>Eg：</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">exec sql <span class="keyword">update</span> student s <span class="keyword">set</span> sclass=<span class="string">'035102'</span> <span class="keyword">where</span> s.sclass=<span class="string">'034101‘;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = green size = 4>定位更新:</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">exec sql <span class="keyword">update</span> tablename [corr_name] <span class="keyword">SET</span> columname= expr [,columname=expr...] <span class="keyword">where</span> <span class="keyword">current</span> <span class="keyword">of</span> cursor_name</span><br></pre></td></tr></table></figure>
<p><font color = green size = 4>Eg：</font></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 声明游标</span></span><br><span class="line">exec sql <span class="keyword">declare</span> stud <span class="keyword">cursor</span> <span class="keyword">for</span></span><br><span class="line">     <span class="keyword">select</span> * <span class="keyword">from</span> student s <span class="keyword">where</span> s.class=<span class="string">'034101'</span></span><br><span class="line"><span class="comment">-- 更新属性</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">update</span> <span class="keyword">of</span> sclass;</span><br><span class="line"><span class="comment">-- 打开游标</span></span><br><span class="line">exec sql open stud</span><br><span class="line">while(TRUE)&#123;</span><br><span class="line"><span class="comment">-- 循环提取游标内变量到宿主程序的变量</span></span><br><span class="line">     exec sql fetch stud into :vSno,:vSname,:vSclass;</span><br><span class="line"><span class="comment">-- 更新当前行</span></span><br><span class="line">     exec sql <span class="keyword">update</span> student  <span class="keyword">set</span> sclass=<span class="string">'035102'</span> <span class="keyword">where</span> <span class="keyword">current</span> <span class="keyword">of</span> stud;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<br/>
<h3 id="10-宿主程序如何知道SQL语句的执行状态，是否发生错误">10. 宿主程序如何知道SQL语句的执行状态，是否发生错误</h3>
<p><font color  = blue size = 4>1) 状态：</font></p>
<ul>
<li><font color = green size = 4>是指嵌入式SQL语句的执行状态，尤其指一些出错状态，有时程序需要知道这些状态并对这些状态进行处理 </font></li>
</ul>
<br/>
<p><font color = blue size = 4>2) 状态捕获及处理由三部分构成:</font></p>
<ul>
<li>
<p><font color = green size = 4>设置SQL通信区：</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">exec sql include sqlca;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其中SQLCA是一个已被声明过的具有C语言的结构形式的内存信息区，其中的成员变量用来记录SQL语句的执行状态，便于宿主程序读取与处理</p>
</blockquote>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = green size = 4>设置状态捕获语句：</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">exec sql whenever condition action;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>
<p>可设置多次</p>
</li>
<li>
<p>该语句会对所有由exec sql语句所引起的对数据库系统的调用自动检查它是否满足条件</p>
</li>
<li>
<p>condition包括 sqlerror；not found；sqlwarning ; action包括continue;goto;stop;do|call</p>
</li>
<li>
<p>状态捕获语句Whenever的作用范围是其后的所有exec sql 语句，直到程序中出现另一条相同条件的whenever为止</p>
</li>
</ol>
</blockquote>
<br/>
</li>
<li>
<p><font color = green size = 4>状态处理语句：</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">report_error:exec sql <span class="keyword">rollback</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>某一段程序以应对SQL操作的某种状态</p>
</blockquote>
</li>
</ul>
<br/>
<h3 id="11-动态SQL-依据条件动态构造SQL语句，但欲访问的表名和字段对编程者是已知的">11. 动态SQL,依据条件动态构造SQL语句，但欲访问的表名和字段对编程者是已知的</h3>
<p><font color = blue size = 4>1) 静态SQL:</font></p>
<ul>
<li>
<p><font color = green size = 4>SQL语句在程序中已经按要求写好，只需要把一些参数通过变量传送给嵌入式SQL语句即可 </font></p>
</li>
<li>
<p><font color = green size = 4>示例：</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">SpecName='张三';</span><br><span class="line">exec sql <span class="keyword">select</span> Sno,Sname,Sclass <span class="keyword">into</span> :vSno,:vSname,:vSclass <span class="keyword">from</span> Student <span class="keyword">where</span> Sname=:SpecName;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<br/>
<p><font color = blue size = 4>2) 动态SQL:</font></p>
<ul>
<li>
<p><font color = green size = 4>SQL语言可以在程序中动态构造，形成一个字符串，然后再交给DBMS执行，交给DBMS执行时仍然可以传递变量</font></p>
</li>
<li>
<p><font color = green size = 4>示例：</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">--设置SQL通信区</span></span><br><span class="line">exec sql include sqlca;</span><br><span class="line"></span><br><span class="line"><span class="comment">--变量声明</span></span><br><span class="line">exec sql <span class="keyword">begin</span> <span class="keyword">declare</span> <span class="keyword">section</span>;</span><br><span class="line">     char user_name[]="Scott"; char user_pwd[]="tiger";</span><br><span class="line">     char sqltext[]="<span class="keyword">delete</span> <span class="keyword">from</span> customers <span class="keyword">where</span> cid=\<span class="string">'c006\'</span><span class="string">";</span></span><br><span class="line"><span class="string">exec sql end declare section;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">int main()</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">--设置状态捕获语句</span></span><br><span class="line"><span class="string">     exec sql whenever sqlerror goto report_error;</span></span><br><span class="line"><span class="string">--连接数据库</span></span><br><span class="line"><span class="string">     exec sql connect :user_name identified by :user_pwd;</span></span><br><span class="line"><span class="string">--立即执行语句</span></span><br><span class="line"><span class="string">     exec sql execute  immediate :sqltext;</span></span><br><span class="line"><span class="string">--提交事务</span></span><br><span class="line"><span class="string">     exec sql commit release: return 0;</span></span><br><span class="line"><span class="string">--状态处理语句</span></span><br><span class="line"><span class="string">     report_error:print_dberror(); </span></span><br><span class="line"><span class="string">--撤销事务    </span></span><br><span class="line"><span class="string">     exec sql rollback release :return 1;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = green size = 4>动态SQL的两种执行方式：</font></p>
<ul>
<li>
<p><font color = brown>立即执行语句(构造的字符串SQL内部没有变量参数)：</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">exec sql <span class="keyword">execute</span> <span class="keyword">immediate</span>:host-<span class="keyword">variable</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><font color = blue size = 4>运行时编译并执行</font></p>
</blockquote>
<br/>
</li>
<li>
<p><font color = brown>Prepare-Execute-Using语句（构造的字符串内部有变量参数）：</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">exec sql <span class="keyword">prepare</span> sql_temp <span class="keyword">from</span> :host-<span class="keyword">variable</span>;</span><br><span class="line"><span class="comment">-----</span></span><br><span class="line">exec sql <span class="keyword">execute</span> sql_temp <span class="keyword">using</span> :cond-<span class="keyword">variable</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><font color = blue size = 4>1) Prepare语句先编译，编译后的SQL语句允许动态参数</font></p>
<p><font color = blue size = 4>2) Execute语句执行，用using语句将动态参数传送给编译好的Sql语句</font></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<br/>
<h3 id="12-数据字典（Data-dictionary）">12. 数据字典（Data dictionary）</h3>
<ul>
<li>
<p><font color = blue size = 4>定义：</font></p>
<ul>
<li><font color = green size = 4>是系统维护的一些表或视图的集合，存储了数据库中各类对象的定义，这些信息又称数据库的元数据–关于数据的数据</font></li>
</ul>
</li>
<li>
<p><font color = blue size = 4>内容：</font></p>
<ul>
<li><font color = green size = 4>与关系相关的信息；用户与账户信息；统计与描述性数据；物理文件组织信息；索引相关信息</font></li>
</ul>
</li>
</ul>
<br/>
<hr>
<h2 id="Ch6-Database-Design">Ch6. Database Design</h2>
<h3 id="1-E-R概念简介">1.E-R概念简介</h3>
<h4 id="font-color-blue-size-4-1-定义：-font"><font color = blue size = 4>1) 定义：</font></h4>
<p><font color = green size = 4>E-R(Entity-Relationship)模型即实体-联系模型, E-R模型可以成功描述数据库所存储的数据。</font></p>
<br/>
<h4 id="font-color-blue-size-4-2-E-R模型的基本要素-font"><font color = blue size = 4>2) E-R模型的基本要素: </font></h4>
<ul>
<li><font color = green size = 4>实体(Entity):</font>
<ul>
<li>实体是E-R模型的基本对象，是现实世界中各种事物的抽象，凡是可以相互区别，并可以被识别的事、物概念等均可认为是实体。</li>
</ul>
</li>
<li><font color = green size = 4>属性(Attribute):</font>
<ul>
<li>每个实体都具有各种特征，称其为实体的属性，如学生有学号，姓名，年龄等属性。实体的属性值是数据库存储的主要数据</li>
<li>可设置主键(primary key)和其他候选键(candidate key)等</li>
</ul>
</li>
<li><font color = green size = 4>联系(Relationship):</font>
<ul>
<li>实体间会存在各种关系，如人与人之间可能存在领导与雇员关系等，实体间的关系被抽象为联系。</li>
</ul>
</li>
<li><font color = green size = 4>图例: </font></li>
</ul>
<p><img data-src="https://image.zxkidea.top/1550801364139.png" alt="zxk"></p>
<br/>
<h4 id="font-color-blue-size-4-3-E-R图像关系模型的转换：-font"><font color = blue size = 4>3) E-R图像关系模型的转换：</font></h4>
<ul>
<li>
<p><font color = green size = 4>一个1：1联系可以转换成一个独立的关系模式，也可以与任意一端对应的关系模式合并。</font></p>
<p><img data-src="https://image.zxkidea.top/1550819223540.png" alt="zxk"></p>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = green size = 4>一个1：n联系可以转换为一个独立的关系模式，也可以与n端对应的关系模式合并。</font></p>
<p><img data-src="https://image.zxkidea.top/1550819281705.png" alt="zxk"></p>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = green size = 4>一个m：n联系转换为一个关系模式</font></p>
<p><img data-src="https://image.zxkidea.top/1550819339152.png" alt="zxk"></p>
</li>
</ul>
<br/>
<ul>
<li><font color = green size = 4>三个或三个以上实体间的一个多元联系可以转换为一个关系模式。</font></li>
<li><font color = green size = 4>具有相同码的关系可以合并。</font></li>
</ul>
<br/>
<h4 id="font-color-blue-4）关联基数-font"><font color = blue >4）关联基数</font></h4>
<p><img data-src="https://image.zxkidea.top/blog/20200305/hIbetOLmvo1p.png?imageslim" alt="zxk"></p>
<br/>
<blockquote>
<p><font color = red size = 4>基数表示的含义：</font></p>
<p><font color = green>1. Purchase Order右边的(1, 1)表示一个Purchase Order有且必须有一个Party </font></p>
<p><font color = green>2. Party左边的(0, n)表示一个Party可以拥有多个Purchase Order，也可以没有</font></p>
<p><font color = green>3. Purchase Order左边的(1, n)表示Purchase Order必须有一个或多个Order Line</font></p>
<p><font color = green>4. Order Line右边的(1, 1)表示每个Order Lien必须属于一个Purchase Order</font></p>
<p><font color = green>5. Order Line下面的(1, 1)和菱形符号一起表示每个Order Line要么是一个Product要么是一个Service </font></p>
<p><font color = green>6. Product和Service上面的(0, n)表示Product和Service可以属于0个或多个Order Line</font></p>
</blockquote>
<blockquote>
<p><font color = red>注意：</font></p>
<p><font color = blue>(E, R) = (x, y)中x只能为0或1；y只能为1或n</font></p>
</blockquote>
<br/>
<h4 id="font-color-red-size-4-5-用例-将下面的E-R图转换为关系模式，关系的码用下划线标出-：-font"><font color = red size = 4>5) 用例 (将下面的E-R图转换为关系模式，关系的码用下划线标出)：</font></h4>
<ul>
<li><font  color = green size = 4>用例1</font></li>
</ul>
<blockquote>
<ol>
<li>
<p>部门（部门号，部门名，经理的职工号，…）；此为部门实体对应的关系模式，该关系模式已包含了联系&quot;领导&quot;所对应的关系模式。经理的职工号是关系的候选码。</p>
</li>
<li>
<p>职工（职工号，部门号，职工名，职务，…）；此为职工实体对应的关系模式，该关系模式已包含了联系“属于”所对应的关系模式。</p>
</li>
<li>
<p>产品（产品号，产品名，产品组长的职工号，…）；此为产品实体对应的关系模式。</p>
</li>
<li>
<p>供应商(供应商号，姓名，…）；此为供应商实体对应的关系模式 。</p>
</li>
<li>
<p>零件（零件号，零件名，…）；此为零件实体对应的关系模式。</p>
</li>
<li>
<p>生产（职工号，产品号，工作天数，…）；此为联系“生产”所对应的关系模式。</p>
</li>
<li>
<p>供应（产品号，供应商号，零件号，供应量）；此为联系“联系”所对应的关系模式。</p>
</li>
</ol>
</blockquote>
  <br/>
<p><img data-src="https://image.zxkidea.top/blog/20200305/yObnKWDQl3Pw.jpg?imageslim" alt="zxk"></p>
<br/>
<ul>
<li><font color = green size = 4>用例2</font></li>
</ul>
<blockquote>
<p><font color = blue size = 4>设有一个图书借阅管理数据库，已知：</font></p>
<ol>
<li>
<p>图书的属性有书号（具有唯一性）、书名</p>
</li>
<li>
<p>读者的属性有借书证号（具有唯一性，每个读者只能有一个借书证号）、姓名、身份证号、住址、电话</p>
</li>
<li>
<p>出版社的属性有出版社名称（具有唯一性）、地址、联系电话。</p>
</li>
</ol>
<p><font color = blue size = 4>其中：</font></p>
<ol>
<li>
<p>每本图书只能有一个出版社出版发行</p>
</li>
<li>
<p>每个读者可以同时借阅多本图书，也可以在不同时候借阅同一本图书</p>
</li>
<li>
<p>系统需要记录每本图书被借阅的借阅日期和归还日期</p>
</li>
</ol>
</blockquote>
  <br/>
<p><font color = red size = 4>请用E-R模型表示该数据库系统的概念模型，并将其转换成等价的关系模式。</font></p>
<table>
<thead>
<tr>
<th><img data-src="https://image.zxkidea.top/1550972584581.png" alt="zxk"></th>
<th><img data-src="https://image.zxkidea.top/1550972612189.png" alt="zxk"></th>
<th><img data-src="https://image.zxkidea.top/1550972829882.png" alt="zxk"></th>
</tr>
</thead>
<tbody>
<tr>
<td><img data-src="https://image.zxkidea.top/1550972896178.png" alt="zxk"></td>
<td><img data-src="https://image.zxkidea.top/1550973002005.png" alt="zxk"></td>
<td><img data-src="https://image.zxkidea.top/1550973163185.png" alt="zxk"></td>
</tr>
<tr>
<td><img data-src="https://image.zxkidea.top/1550973274552.png" alt="zxk"></td>
<td><img data-src="https://image.zxkidea.top/1550973308600.png" alt="zxk"></td>
<td><img data-src="https://image.zxkidea.top/1550973358353.png" alt="zxk"></td>
</tr>
<tr>
<td><img data-src="https://image.zxkidea.top/1550973397877.png" alt="zxk"></td>
<td><img data-src="https://image.zxkidea.top/1550973473571.png" alt="zxk"></td>
<td><img data-src="https://image.zxkidea.top/1550973533008.png" alt="zxk"></td>
</tr>
</tbody>
</table>
<br/>
<h3 id="2-函数依赖-FD">2.函数依赖(FD)</h3>
<h4 id="font-color-blue-size-4-1）-定义-font"><font color = blue size = 4>1） 定义: </font></h4>
<ul>
<li><font color = green size = 4>函数依赖是数据依赖的一种，它反映属性或属性组之间相依存，互相制约的关系，即反映现实世界的约束关系。</font></li>
<li><font color = green size = 4>设R（U）是属性U上的一个关系模式，X和Y均为U={A1，A2，…，An}的子集，r为R的任一关系，如果对于r中的任意两个元组u，v，只要有u[X]=v[X]，就有u[Y]=v[Y]，则称X函数决定Y，或称Y函数依赖于X，记为X→Y。</font></li>
</ul>
<br/>
<blockquote>
<p>示例：</p>
<p>(sno-学生ID，tno-教师ID，cno-课程ID，sname-学生姓名，tname-教师姓名，cname-课程名称，grade-成绩）</p>
<ol>
<li>
<p>sno→sname, cno→cname, (sno, cno)→grade $\surd$</p>
</li>
<li>
<p>sname→sno, tno→cno, sno→tname × （不存在一一对应关系）</p>
</li>
</ol>
</blockquote>
<br/>
<p><img data-src="https://image.zxkidea.top/1551058200955.png" alt="zxk"></p>
<p><img data-src="https://image.zxkidea.top/1551058364790.png" alt="zxk"></p>
<br/>
<h4 id="font-color-blue-size-4-2）完全函数依赖和部分函数依赖-font"><font color = blue size = 4>2）完全函数依赖和部分函数依赖</font></h4>
<ul>
<li><font color = green size = 4>在完全函数依赖：R(U)中，如果X→Y，并且对于X的任何真子集X’ , 都有X’$\nrightarrow$ Y，则称Y完全依赖于X，记作X→Y；</font></li>
<li><font color = green size = 4>在部分函数依赖：如果X→Y，且X中存在一个真子集X’ ，使得X’→Y成立，则称Y部分依赖于X。</font></li>
</ul>
<br/>
<blockquote>
<p>示例:</p>
<ul>
<li>
<p><font color = blue size = 4>学生ID，学生姓名，所修课程ID，课程名称，成绩</font></p>
<p>（学生ID，所修课程ID）→成绩</p>
<p>成绩既不能单独依赖于学生ID，也不能单独依赖于所修课程ID，因此成绩完全函数依赖于关键字。</p>
<p><font color = red size = 4>(学生ID不能唯一决定成绩，所选修课程ID也不能唯一决定成绩，需要(学生ID,所选修课程ID)一起才能唯一决定一个成绩)。</font></p>
</li>
<li>
<p><font color = blue size = 4>（学生ID，所修课程ID）→学生姓名</font></p>
<p>学生ID→学生姓名</p>
<p>学生姓名可以依赖于关键字的一个主属性——学生ID，因此学生姓名部分函数依赖于（学生ID，所修课程ID）。</p>
</li>
</ul>
</blockquote>
<br/>
<h4 id="font-color-blue-size-4-3）平凡函数依赖和非平凡函数依赖-font"><font color = blue size = 4>3）平凡函数依赖和非平凡函数依赖</font></h4>
<ul>
<li><font color = green size = 4>非平凡 函数依赖: X $\rightarrow$ Y, 但是Y $\nsubseteq$ X,则称X $\rightarrow$  Y是非平凡的函数依赖。</font></li>
<li><font color = green size = 4>平凡函数依赖： X $\rightarrow$ Y, 但是Y $\subseteq$ X,则称X $\rightarrow$  Y是平凡的函数依赖。</font></li>
</ul>
<br/>
<h4 id="font-color-blue-size-4-4）传递函数依赖-font"><font color = blue size = 4>4）传递函数依赖</font></h4>
<ul>
<li><font color = green size = 4>设X,Y,Z是关系R中互不相同的属性集合，存在X→Y(Y$\nrightarrow$X), Y→Z，则称Z传递函数依赖于X。</font></li>
</ul>
<br/>
<h3 id="3-多值依赖">3.多值依赖</h3>
<h4 id="font-color-blue-size-4-1-定义-font"><font color = blue size = 4>1) 定义</font></h4>
<ul>
<li><font color = green size = 4>设R(U)是属性集U上的一个关系模式。X，Y，Z是U的子集,并且Z=U-X-Y。关系模式R(U)中多值依赖X→→Y成立，当且仅当对R(U)的任一关系R,给定的一对(X，Z)值有<span style="background: linear-gradient(to right, #f2994a, #f2c94c);">一组Y（依赖的属性集合）</span>的值，这组值仅仅决定于X值而与Z值无关；<span style="background: linear-gradient(to right, #74ebd5, #acb6e5);">即U=X+Y+Z，有（X,Z）→ Y，但Y仅由X唯一确定，此时记X→→Y，称多值依赖。</span></font></li>
</ul>
<br/>
<ul>
<li><font color = green size = 4>若X→→Y，而Z＝φ，则称X→→Y为平凡的多值依赖。否则称X→→Y为非平凡的多值依赖；多值依赖属4NF的定义范围，比函数依赖要复杂得多，很多书上都没有讲清楚。</font></li>
</ul>
<br/>
<ul>
<li><font color = red size = 4>说得简单点就是：</font><font color = green size = 4>在关系模式中，函数依赖不能表示属性值之间的一对多联系，这些属性之间有些虽然没有直接关系，但存在间接的关系，把没有直接联系、但有间接的联系称为多值依赖的数据依赖。例如，教师和学生之间没有直接联系，但教师和学生可通过系名，或任课把教师和学生联系起来。</font></li>
</ul>
<br/>
<blockquote>
<p>可以看出，如果把上面的一组改为一个，那么多值依赖就变成了函数依赖。当然一个值组成的组也是组，所以说，<font color = green>函数依赖是多值依赖的特殊情况。</font></p>
</blockquote>
<br/>
<h4 id="font-color-blue-size-4-2-示例：-font"><font color = blue size = 4>2) 示例：</font></h4>
<table>
<thead>
<tr>
<th style="text-align:left">课程C</th>
<th>教师T</th>
<th>参考书B</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">数学</td>
<td>邓军</td>
<td>数学分析</td>
</tr>
<tr>
<td style="text-align:left">数学</td>
<td>邓军</td>
<td>高等代数</td>
</tr>
<tr>
<td style="text-align:left">数学</td>
<td>邓军</td>
<td>微分方程</td>
</tr>
</tbody>
</table>
<br/>
<blockquote>
<p><font color = green >分析：</font></p>
<ol>
<li>
<p>表中，U = C+T+B，（C,T）确定一组B（依赖的属性集合），但是这组B其实<font color = red>与T无关，仅由C确定</font>，所以(C,T)-&gt;-&gt;B。又因为T不是空集，所以(C,T)-&gt;-&gt;B为<font color = red>非平凡多值依赖</font>。</p>
</li>
<li>
<p>要想消除多值依赖，可以分解为：(C,T), (C,B)即表1，表2</p>
</li>
</ol>
</blockquote>
<p><font color = green>表1：</font></p>
<table>
<thead>
<tr>
<th>课程C</th>
<th>教师T</th>
</tr>
</thead>
<tbody>
<tr>
<td>数学</td>
<td>邓军</td>
</tr>
</tbody>
</table>
<p><font color = green>表2：</font></p>
<table>
<thead>
<tr>
<th>课程C</th>
<th>参考书B</th>
</tr>
</thead>
<tbody>
<tr>
<td>数学</td>
<td>数学分析</td>
</tr>
<tr>
<td>数学</td>
<td>高等代数</td>
</tr>
<tr>
<td>数学</td>
<td>微分方程</td>
</tr>
</tbody>
</table>
<br/>
<blockquote>
<p><font color = green>结论：</font></p>
<ol>
<li>
<p>对于R中的每个非平凡多值依赖X-&gt;-&gt;Y（Y不属于X)，X都含有候选码，则R属于4NF。</p>
</li>
<li>
<p>对于每一个非平凡多值依赖X-&gt;-&gt;Y，X若含有候选码，也就是X-&gt;Y，所以4NF所允许的非平凡多值依赖是函数依赖。</p>
</li>
</ol>
</blockquote>
<br/>
<p><font color = red size = 4>实例解释:</font></p>
<blockquote>
<p>有这样一个关系 &lt;仓库管理员，仓库号，库存产品号&gt; ，假设一个产品只能放到一个仓库中，但是一个仓库可以有若干管理员，那么对应于一个 &lt;仓库管理员，库存产品号&gt;有一个仓库号，而实际上，<span style="background: linear-gradient(to right, #74ebd5, #acb6e5);">这个仓库号只与库存产品号有关，与管理员无关，就说这是多值依赖。</span></p>
</blockquote>
<blockquote>
<p>（C，B）上的一个值（物理，光学原理）对应一组T值（李平，王强，刘明），这组值仅仅决定于课程C上的值，也就是说对于（C，B）上的另一个值（物理，普通物理学），它对应的一组T值仍是（李平，王强，刘明），尽管这时参考书B的值已经改变了。因此T多值依赖于C，即C→→T。</p>
</blockquote>
<br/>
<h4 id="font-color-blue-size-4-3）性质：-font"><font color = blue size = 4>3）性质：</font></h4>
<ul>
<li><font color = green size = 4>多值依赖具有对称性；即若X→→Y，则X→→Z，其中Z＝U－X－Y。</font></li>
<li><font color = green size = 4>多值依赖具有传递性；即若X→→Y，Y→→Z，则X→→Z－Y。</font></li>
<li><font color = green size = 4>若X→→Y，X→→Z，则X→→YZ。</font></li>
<li><font color = green size = 4>若X→→Y，X→→Z，则X→→Y∩Z。</font></li>
<li><font color = green size = 4>若X→→Y，X→→Z，则X→→Y－Z，X→→Z－Y。</font></li>
</ul>
<br/>
<h3 id="4-函数依赖的推理规则">4.函数依赖的推理规则</h3>
<h4 id="font-color-blue-size-4-1-逻辑蕴涵-font"><font color = blue size = 4>1) 逻辑蕴涵</font></h4>
<p><font color = green size = 4>给定一个关系模式，只考虑给定的函数依赖是不够的，必须找出在该关系模式上成立的其他函数依赖。</font></p>
<p><font color = red size = 4>逻辑蕴含：设F是关系模式R（U）的函数依赖集合，由F出发，可以证明其他某些函数依赖也成立，我们称这些函数依赖被F逻辑蕴含。&quot;F蕴含X→Y&quot;意味着关系实例只要满足F就满足X→Y。</font></p>
<blockquote>
<p>例如，设F={ A→B，B→C }，则函数依赖A→C被F逻辑蕴含，记作：F |= A→C。即函数依赖集 F 逻辑蕴含函数依赖A→C。</p>
</blockquote>
<br/>
<h4 id="font-color-blue-size-4-2-F的闭包F-font"><font color = blue size = 4>2) F的闭包F^+^ </font></h4>
<p><font color = green size = 4>对于一个关系模式，如何由已知的函数依赖集合F，找出F逻辑蕴涵的所有函数依赖集合呢？这就是我们下面要讨论的问题。</font></p>
<p><font color = red size = 4>F的闭包F^+^：设F为一个函数依赖集，F的闭包是指F逻辑蕴涵的所有函数依赖集合。 F的闭包记作F^+^。</font></p>
<br/>
<p><span style="background: linear-gradient(to right, #f2994a, #f2c94c);"><font color = green size = 4>示例：</font></span></p>
<blockquote>
<p>给定关系模式R(A, B, C, G, H, I)，函数依赖集合F={A→B，A→C，CG→H，CG→I，B→H}。</p>
<p>可以证明函数依赖A→H被F逻辑蕴涵。</p>
</blockquote>
<p><span style="background: linear-gradient(to right, #f2994a, #f2c94c);"><font color = green size = 4>证明：</font></span></p>
<blockquote>
<p>设有元组s和t，满足s[A]=t[A]，根据函数依赖的定义，由已知的A→B，可以推出s[B]=t[B]。又根据函数依赖B→H，可以有 s[H]=t[H]。因此，已经证明对任意的两个元组s和t，只要有s[A]=t[A]，就有s[H]=t[H]。所以，函数依赖A→H被F逻辑蕴涵。</p>
</blockquote>
<br/>
<blockquote>
<p><font color = red size = 4><em>注意：</em></font><font color = green size = 4>当F很大时，计算的过程会很长。为了从已知的函数依赖推导出其它函数依赖，Armstrong 提出了一套推理规则，称为Armstrong 公理 ，通过反复使用这些规则，可以找出给定F的闭包F^+^。</font></p>
</blockquote>
<br/>
<h4 id="font-color-blue-size-4-3-Armstrong-公理-font"><font color = blue size = 4>3) Armstrong 公理</font></h4>
<p><font color = green size = 4>a. 定义：</font>从已知的一些，可以推导出另外一些函数依赖的推理规则称作“Armstrong 公理”。</p>
<br/>
<p><font color = green size = 4>b. 基本公理：</font></p>
<ul>
<li>
<p><font color = red size = 4>自反律：</font>如果 Y $\subseteq$ X$\subseteq$ U，则 X → Y 成立。（平凡函数依赖）</p>
<blockquote>
<p>证明：</p>
<p>设t1, t2是关系R中的任意两个元组(t1$\in$R, t2$\in$R), 且它们在属性集X上的值相等(t1[X] = t2[X])；</p>
<p>由于Y是X的子集，即X $\supseteq$ Y；</p>
<p>因此必有t1[Y] = t2[Y]。</p>
</blockquote>
<br/>
</li>
<li>
<p><font color = red size = 4>增广律：</font>如果 X → Y 在 R(U)  成立，且 Z$\subseteq$ U，则 XZ [^1]→ YZ成立</p>
<blockquote>
<p>证明：</p>
<p>设 t1$\in$R, t2$\in$R, 如果 t1[XZ] = t2[XZ], 则：<br>
t1[X] = t2[X] …………………………(1)<br>
t1[Z] = t2[Z] …………………………(2)；</p>
<p>由(1)及X→Y得： t1[Y] = t2[Y] …………(3)；</p>
<p>由(2)及(3)得：t1[YZ] = t2[YZ]。</p>
</blockquote>
</li>
</ul>
<p>[^1]: <font color = green size= 4>XZ表示X $\cup$ Z, YZ表示Y $\cup$ Z</font></p>
<br/>
<ul>
<li>
<p><font color = red size = 4>传递律：</font>如果 X → Y，Y → Z 成立，则 X → Z 成立。</p>
<blockquote>
<p>证明：</p>
<p>设 t1$\in$R, t2$\in$R, 如果 t1[X] = t2[X] ………………(1)；</p>
<p>由(1)及X→Y得：t1[Y] = t2[Y] ……………… (2)；</p>
<p>由(2)及Y→Z得：t1[Z] = t2[Z]。</p>
</blockquote>
<br/>
</li>
</ul>
<p><font color = green size = 4>c. 推理规则：</font></p>
<blockquote>
<p><font color = red size = 4>(合并)：</font>{X → Y，X → Z}，则 X → YZ</p>
<p><font  color = red size = 4>(分解)：</font>{X → Y，Z ∈ Y}，则 X → Z（或：X → YZ，那么 X → Y，X → Z）</p>
<p><font color = red size = 4>(伪传递)：</font>{X → Y , YW → Z}，则 WX → Z</p>
<p><font color = red size = 4>(复合)：</font>{X → Y，W → Z},则 XW → YZ</p>
<p><font color = red size = 4>(自积律)：</font>{X → YZ，Z → W}，则 X → YZW</p>
</blockquote>
<br/>
<h4 id="font-color-blue-size-4-4-Armstrong公理系统的有效性和完备性-font"><font color = blue size = 4>4) Armstrong公理系统的有效性和完备性</font></h4>
<ul>
<li>
<p><font color = green size = 4>Armstrong公理系统的有效性指的是：</font></p>
<p>由F出发根据Armstrong公理系统推导出来的每一个函数依赖一定在F^+^中。</p>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = green size = 4>Armstrong公理系统的完备性指的是：</font></p>
<p>对于F^+^所逻辑蕴含的每一函数依赖，必定可以由F出发根据Armstrong公理系统推导出来。</p>
</li>
</ul>
<br/>
<h4 id="font-color-blue-size-4-5-属性集的闭包-font"><font color = blue size = 4>5) 属性集的闭包</font></h4>
<blockquote>
<p>原则上讲，对于一个关系模式R(U, F)，根据已知的函数依赖F，反复使用前面的规则，可以计算函数依赖集合F的闭包F+。但是，利用推理规则求出其全部的函数依赖F+是非常困难的，而且也没有必要。因此，可以计算闭包的子集，即选择一个属性子集，判断该属性子集能函数决定哪些属性，这就是利用属性集闭包的概念。</p>
</blockquote>
<ul>
<li>
<p><font color = green size = 4>定义：</font></p>
<p>设F为属性集U上的函数依赖集，X∈U，即X为U的一个子集。在函数依赖集F下被X函数决定的所有属性为F^+^下属性集X的闭包，记作X^+^。即X^+^＝{ A| X→A } 。</p>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = green size = 4>计算属性集闭包X^+^的算法如下：</font></p>
<p>输入：X，F<br>
输出： X^+^</p>
<br/>
<p><span style="background: linear-gradient(to right, #f2994a, #f2c94c);"><font color = green size = 4>迭代算法的步骤：</font></span></p>
<blockquote>
<ol>
<li>
<p>选取X^+^的初始值为X ，即X^+^＝{X}；</p>
</li>
<li>
<p>计算X^+^， X^+^＝{X, Z} ，其中Z要满足如下条件：</p>
<p><span style="background: linear-gradient(to right, #74ebd5, #acb6e5);">Y是X^+^的真子集，且F中存在一函数依赖Y→Z。</span>实际上就是以X^+^中的属性子集作为函数依赖的决定因素，在F中搜索函数依赖集，找到函数依赖的被决定属性Z放到X^+^中。</p>
</li>
<li>
<p>判断：如果X^+^没有变化？或X^+^等于U？则X^+^就是所求的结果，算法终止。否则转②。</p>
</li>
<li>
<p>因为U是有穷的，所以上述迭代过程经过有限步骤之后就会终止。</p>
</li>
</ol>
</blockquote>
<br/>
</li>
<li>
<p><font color = red size = 4>示例：</font></p>
<p><img data-src="https://image.zxkidea.top/1551150366580.png" alt="zxk"></p>
</li>
</ul>
<br/>
<h4 id="font-color-blue-size-4-6-极小函数依赖集（最小函数依赖集）-font"><font color = blue size = 4>6) 极小函数依赖集（最小函数依赖集）</font></h4>
<ul>
<li>
<p><font color = green size = 4>定义：</font></p>
<p>如果函数依赖集F满足下列条件，则称F为最小函数依赖集或最小覆盖。</p>
<blockquote>
<ol>
<li>
<p>F中的任何一个函数依赖的右部仅含有一个属性；</p>
</li>
<li>
<p>F中不存在这样一个函数依赖X→A，使得F与F-{X→A}等价；</p>
</li>
<li>
<p>F中不存在这样一个函数依赖X→A，X有真子集Z使得F-{X→A}∪{Z→A}与F等价。</p>
</li>
</ol>
</blockquote>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = red size = 4>计算最小函数依赖集的算法:</font></p>
<blockquote>
<ol>
<li>将F中的所有依赖右边化为单一元素</li>
<li>去掉F各函数依赖左边的冗余属性<span style="background: linear-gradient(to right, #f2994a, #f2c94c);">（只检查左部不是单个属性的函数依赖）</span></li>
<li>去掉F中所有冗余依赖关系<span style="background: linear-gradient(to right, #74ebd5, #acb6e5);">（逐个求，在去掉某个函数依赖的F中求该函数依赖左边的闭包，如果闭包能包含右边属性，则表示这个函数依赖要去掉）</span></li>
</ol>
</blockquote>
<br/>
</li>
<li>
<p><font color = red size = 4>举例：</font></p>
<blockquote>
<p>已知关系模式R&lt;U, F&gt;，U={A, B, C, D, E, G}，F={AB→C, D→EG, C→A, BE→C, BC→D, CG→BD, ACD→B, CE→AG}，求F的最小函数依赖集。</p>
</blockquote>
<br/>
<p><font color = brown size = 4>求解步骤：</font></p>
<p><font color = green size = 4>1. 将F中的所有依赖右边化为单一元素</font></p>
<p><font color = red size = 4>F = {AB→C, D→E, D→G, C→A, BE→C, BC→D, CG→B, CG→D, ACD→B, CE→A, CE→G}</font></p>
<br/>
<p><font color = green size = 4>2. 去掉F各函数依赖左边的冗余属性(只检查左部不是单个属性的函数依赖)</font></p>
<p><font color = blue size = 4>AB→C:</font></p>
<blockquote>
<ol>
<li>去掉A, B^+^ = B, 不包含C,A不为冗余属性，所以A不能去掉</li>
<li>去掉B, A^+^ = A, 不包含C,B不为冗余属性，所以B不能去掉</li>
</ol>
</blockquote>
  <br/>
<p><font color = blue size = 4>BE→C:</font></p>
<blockquote>
<ol>
<li>去掉B, E^+^ = E, 不包含C,B不为冗余属性，所以B不能去掉</li>
<li>去掉E, B^+^ = B, 不包含C,E不为冗余属性，所以E不能去掉</li>
</ol>
</blockquote>
<br/>
<p><font color = blue size = 4>BC→D:</font></p>
<blockquote>
<ol>
<li>
<p>去掉B, C^+^ = {A,C}, 不包含D, B不为冗余属性，所以B不能去掉</p>
</li>
<li>
<p>去掉C, B^+^ = B, 不包含D, C不为冗余属性，所以C不能去掉</p>
</li>
</ol>
</blockquote>
  <br/>
<p><font color = blue size = 4>CG→B:</font></p>
<blockquote>
<ol>
<li>
<p>去掉C, G^+^ = G, 不包含B, C不为冗余属性，所以C不能去掉</p>
</li>
<li>
<p>去掉G, C^+^ = {A,C}, 不包含B, G不为冗余属性，所以G不能去掉</p>
</li>
</ol>
</blockquote>
<br/>
<p><font color = blue size = 4>ACD→B:</font></p>
<blockquote>
<ol>
<li>
<p>去掉A, (CD)^+^ = {A, B, C, D, E, G}, 包含B, A为冗余属性，所以把A去掉,则为<font color = red size = 4>CD→B</font></p>
</li>
<li>
<p>去掉C, D^+^ = {D, E, G}, 不包含B, C不为冗余属性，所以C不能去掉</p>
</li>
<li>
<p>去掉D, C^+^ = {A, C}, 不包含B, D不为冗余属性，所以D不能去掉</p>
</li>
</ol>
</blockquote>
  <br/>
<p><font color = blue size = 4>CE→A:</font></p>
<blockquote>
<ol>
<li>
<p>去掉C, E^+^ = E, 不包含A, C不为冗余属性，所以C不能去掉</p>
</li>
<li>
<p>去掉E, C^+^ = {A, C}, 包含A, E不为冗余属性，所以把E去掉,则为<font color = red size = 4>C→A</font></p>
</li>
<li>
<p>与存在依赖重复，故舍去</p>
</li>
</ol>
</blockquote>
<br/>
<p><font color = blue size = 4>CE→G:</font></p>
<blockquote>
<ol>
<li>
<p>去掉C, E^+^ = E, 不包含G, C不为冗余属性，所以C不能去掉</p>
</li>
<li>
<p>去掉E, C^+^ = {A, C}, 不包含G, E不为冗余属性，所以E不能去掉</p>
</li>
</ol>
</blockquote>
<p><font color = red size = 4>所以：F = {AB→C, D→E, D→G, C→A, BE→C, BC→D, CG→B, CG→D, CD→B, CE→G}</font></p>
<br/>
<p><font color = green size = 4>3. 去掉F中所有冗余依赖关系(逐个求，在去掉某个函数依赖的F中求闭包，如果包含右边属性，则表示这个函数依赖要去掉)</font></p>
<p><font color = blue size = 4>AB→C:</font></p>
<blockquote>
<p>(AB)^+^ = {A, B}, 不包含C, 则不用去掉</p>
</blockquote>
<br/>
<p><font color = blue size = 4>D→E:</font></p>
<blockquote>
<p>D^+^ = {D, G}, 不包含E, 则不用去掉</p>
</blockquote>
<br/>
<p><font color = blue size = 4>D→G:</font></p>
<blockquote>
<p>D^+^ = {D, E}, 不包含G, 则不用去掉</p>
</blockquote>
<br/>
<p><font color = blue size = 4>C→A:</font></p>
<blockquote>
<p>C^+^ = C, 不包含A, 则不用去掉</p>
</blockquote>
<br/>
<p><font color = blue size = 4>BE→C:</font></p>
<blockquote>
<p>(BE)^+^ = {B, E}, 不包含C, 则不用去掉</p>
</blockquote>
<br/>
<p><font color = blue size = 4>BC→D:</font></p>
<blockquote>
<p>(BC)^+^ = {A, B, C}, 不包含D, 则不用去掉</p>
</blockquote>
<br/>
<p><font color = blue size = 4>CG→B:</font></p>
<blockquote>
<p>(CG)^+^ = {A, B, C, D, E, G}, 包含B, 则<b>去掉</b></p>
</blockquote>
<br/>
<blockquote>
<p><font color = red size = 4>注意：</font><span style="background: linear-gradient(to right, #f2994a, #f2c94c);"><font color = green size = 4>此时CG→B已被去掉，函数依赖集F需要更新后再求新的函数依赖的闭包</font></span></p>
</blockquote>
<p><font color = blue size = 4>CG→D:</font></p>
<blockquote>
<p>(CG)^+^ = {A, C, G}, 不包含D, 则不用去掉</p>
</blockquote>
<br/>
<p><font color = blue size = 4>CD→B:</font></p>
<blockquote>
<p>(CD)^+^ = {A, C, D, E, G}, 不包含B, 则不用去掉</p>
</blockquote>
  <br/>
<p><font color = blue size = 4>CE→G:</font></p>
<blockquote>
<p>(CE)^+^ = {A, C, E}, 不包含G, 则不用去掉</p>
</blockquote>
<br/>
<p><font color = red size = 4>故最小依赖集为：F~m~= {AB→C, D→E, D→G, C→A, BE→C, BC→D, CG→D, CD→B, CE→G}</font></p>
</li>
</ul>
<br/>
<h4 id="font-color-blue-size-4-7-超码，候选码与主码-font"><font color = blue size = 4>7) 超码，候选码与主码</font></h4>
<ul>
<li>
<p><font color = green size = 4>关系：</font></p>
<blockquote>
<p>超码包括候选码，候选码包括主码</p>
</blockquote>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = green size = 4>超码：</font></p>
<blockquote>
<ol>
<li>
<p>是一个或多个属性的集合，这些属性可以让我们在一个实体集中地标识一个实体</p>
</li>
<li>
<p>如果K是超码，那么所有包含K的集合也是超码</p>
</li>
</ol>
</blockquote>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = green size = 4>候选码：</font></p>
<blockquote>
<ol>
<li>
<p>从超码中选出的，自然地，候选码也是一个或多个属性的集合；</p>
</li>
<li>
<p>可能大多数超码中含有多余的属性。所以我们需要候选码，<font color = red>不含有多余属性的超码称为候选码，候选码是可以标识一个元组的最少的属性集合。</font></p>
</li>
<li>
<p>关系中的一个超码，其值能标识一个元组，若从<font color = red>该超码中去掉任何一个属性，它就不具有这一性质了。</font>（即该超码不应该存在一个真子集也能标识一个元组）。这样的属性组称作候选码。</p>
</li>
<li>
<p><font color = red>候选码是最小超码</font>，它们的<font color = red>任意真子集都不能成为超码</font>。例如，如果K是超码，那么所有包含K的集合都不能是候选码；如果K，J都不是超码，那么K和J组成的集合（K，J）有可能是候选码。</p>
</li>
</ol>
</blockquote>
<br/>
</li>
<li>
<p><font color = green size = 4>主码：</font></p>
<blockquote>
<p>一个表的候选码可能有多个，从这些个候选码中选择一个做为主码，至于选择哪一个候选码，这个是无所谓的，只要是从候选码中选的就行。</p>
</blockquote>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = green size = 4>主属性：</font></p>
<blockquote>
<p>一个表可以有多个候选码，那么对于某个属性来说，如果这个属性存在于所有的候选码中，它就称之为主属性。<font color = red>简单来说，主属性是候选码属性的并集。</font></p>
</blockquote>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = green size = 4>非主属性：</font></p>
<blockquote>
<p>不包含在候选码中的属性称为非主属性。 非主属性是相对于主属性来定义的。</p>
</blockquote>
</li>
</ul>
<br/>
<blockquote>
<p><font color = dark size = 5>&lt;各类码及属性整理&gt;</font></p>
<p><a href="https://blog.csdn.net/sumaliqinghua/article/details/85872446" target="_blank" rel="noopener">https://blog.csdn.net/sumaliqinghua/article/details/85872446</a></p>
</blockquote>
<br/>
<h4 id="font-color-blue-size-4-8-求解候选码-font"><font color = blue size = 4>8) 求解候选码</font></h4>
<ul>
<li>
<p><font color = green size = 4>对于给定的关系R（A1，A2，…An）和函数依赖集F，可将其属性分为4类：</font></p>
<blockquote>
<p>L类：仅出现在函数依赖左部的属性。</p>
<p>R 类：仅出现在函数依赖右部的属性。</p>
<p>N类：在函数依赖左右两边均未出现的属性。</p>
<p>LR类：在函数依赖左右两边均出现的属性。</p>
</blockquote>
  <br/>
<blockquote>
<p><font color = red>定理1：</font>对于给定的关系模式R及其函数依赖集F，若X（X∈R）是L类属性，则X必为R的<font color = blue>任一候选码的成员。</font></p>
<p><font color = red>推论1：</font>对于给定的关系模式R及其函数依赖集F，若X（X∈R）是L类属性，且X^+^包含了R的全部属性；则X必为R的<span style="background: linear-gradient(to right, #f2994a, #f2c94c);"><font color = blue>唯一候选码。</font></span></p>
</blockquote>
<br/>
<blockquote>
<p><font color = red>定理2：</font>对于给定的关系模式R及其函数依赖集F，若X（X∈R）是R类属性，则X<font color = blue>不在任何候选码中。</font></p>
<p><font color = red>定理3：</font>对于给定的关系模式R及其函数依赖集F，若X（X∈R）是N类属性，则X<font color = blue>必包含在R的任一候选码中。</font></p>
<p><font color = red>推论2：</font>对于给定的关系模式R及其函数依赖集F，若X（X∈R）是L类和N类组成的属性集，且X^+^包含了<font color = blue>R的全部属性</font>；则X是R的<span style="background: linear-gradient(to right, #f2994a, #f2c94c);"><font color = blue>唯一候选码。</font></span></p>
</blockquote>
</li>
</ul>
<br/>
<p><font color = red size = 4>具体步骤：</font></p>
<p><strong>算法描述：</strong></p>
<blockquote>
<ol>
<li>
<p>将R 的所有属性分为L、R、LR 和N 四类，并令X 代表L、N 类，Y 代表LR 类。</p>
</li>
<li>
<p>求X^+^。若X^+^包含了R 的全部属性，则即为R 的<span style="background: linear-gradient(to right, #f2994a, #f2c94c);">唯一候选码</span>，转（5）；否则，转（3）。</p>
</li>
<li>
<p>在Y 中取一属性A，求(XA)^+^ ，若它包含了R 的全部属性，则是<span style="background: linear-gradient(to right, #74ebd5, #acb6e5);">候选码</span>，转（4）；否则，调换一属性反复进行这一过程，直到试完所有Y 中的属性。</p>
</li>
<li>
<p>如果已找出所有候选码，则转（5）；否则在Y 中依次取2 个、3 个、…，求它们的属性闭包，若其闭包包含R 的全部属性，则是<span style="background: linear-gradient(to right, #74ebd5, #acb6e5);">候选码</span>。</p>
</li>
<li>
<p>结束。</p>
</li>
</ol>
</blockquote>
<br/>
<p><font color = green size = 4>示例1：</font></p>
<blockquote>
<p>如设有关系模式R(U), 其函数依赖集为F, 其中U={A, B, C, D, E}, F={A$\rightarrow$C, C$\rightarrow$A, B$\rightarrow$AC, D$\rightarrow$AC}<br>
求R 的候选码。</p>
</blockquote>
<br/>
<p><font color = brown size = 4>求解方法：</font></p>
<p><font color = green size = 4>根据函数依赖可得：</font></p>
<blockquote>
<p>属性<font color = red>B 、D</font> 为L 类，<font color = red>E</font> 为N 类，因此属性<font color = red>B 、D 、E</font> 必为候选码的成员， 且此三个属性的闭包： <font color = blue>B^+^=ABC, (BD)^+^=ABCD, (BDE)^+^=ABCDE</font>, 根据推论2 可得BDE 是R 的唯一候选码。所以R 的候选码为BDE 。</p>
</blockquote>
<blockquote>
<p><font color = red>变式：</font>如果把例题中关系模式<font color = blue>R(U) 中的属性E</font> 去掉，那么再求R 的候选码的话可以根据推论1得出<br>
BD 为R 的唯—候选码。</p>
</blockquote>
<br/>
<p><font color = green size = 4>示例2：</font></p>
<blockquote>
<p>如设有关系模式R(U), 其函数依赖集为F, 其中U={A, B, C, D, E}, F={B$\rightarrow$A, D$\rightarrow$A, A$\rightarrow$E, AC$\rightarrow$B}<br>
求R 的候选码。</p>
</blockquote>
<p><font color = brown size = 4>求解方法：</font></p>
<p><font color = green size = 4>根据函数依赖可得：</font></p>
<blockquote>
<p>属性<font color = red>C、D</font> 为L 类，因此属性<font color = red>C、D </font> 必为候选码的成员， 且此两个属性的闭包： <font color = blue>C^+^=C, (CD) ^+^=ABCDE</font>, 根据推论1可得CD 是R 的唯一候选码。所以R 的候选码为CD 。</p>
</blockquote>
<br/>
<blockquote>
<p><font color = red size = 4>注意：</font></p>
<ul>
<li>
<p>快速求解方法适用于判断有属性是属于L 类、N 类或其中一种的情况下求解。如果有L 类和N类的属性， 则求解候选码速度非常快。</p>
</li>
<li>
<p><span style="background: linear-gradient(to right, #f2994a, #f2c94c);">简而言之：</span> L、R、N、LR 类。根据定理， L、N 类必为侯选码之一，如果L^+^包含全部R, 则L为唯一侯选。R 类不在任何侯选码中。L+N 类且(L+N)^+^包含所有R, 则L+N 为唯一侯选。(适于有L、N 类至少一种的情况。)</p>
</li>
</ul>
</blockquote>
<br/>
<h3 id="5-关系模式的分解">5.关系模式的分解</h3>
<h4 id="font-color-blue-1-无损联接-font"><font color = blue>1) 无损联接</font></h4>
<ul>
<li>
<p><font color = green size = 4>定义：</font></p>
<p>无损联接分解是将一个关系模式分解成若干个关系模式后，通过自然联接和投影等运算仍能还原到原来的关系模式，则称这种分解为无损联接分解。</p>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = green size = 4>示例：</font></p>
<blockquote>
<p>关系模式：成绩（学号，姓名，课程号，课程名，分数）</p>
<p>函数依赖：学号-&gt;姓名，课程号-&gt;课程名， （学号，课程号）-&gt;分数</p>
</blockquote>
<blockquote>
<p>若将其分解为下面三个关系模式：</p>
<p>成绩（学号，课程号，分数）</p>
<p>学生（学号，姓名）</p>
<p>课程（课程号，课程名）</p>
</blockquote>
<br/>
<p><font color = red size = 4>1. 这样的分解是无损分解吗？</font></p>
<blockquote>
<p><font color = green size = 4>$\because$ 学号-&gt;姓名</font></p>
<p><font color = green size = 4> $\therefore$  成绩（<font color = red  size = 4>学号</font>，课程号，分数，<font color = blue size = 4>姓名</font>）</font></p>
<p><font color = green size = 4>$\because$ 课程号-&gt;课程名</font></p>
<p><font color = green size = 4>$\therefore$ 成绩（学号，<font color = red size = 4>课程号</font>，分数，姓名，<font color = blue size = 4>课程名</font>）</font></p>
</blockquote>
<p><font color = red size = 4>因此这个例子是无损分解的</font></p>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = green size = 4>无损分解判定算法：</font></p>
<ol>
<li>
<p>建立一张k行n列的表来检验连接是否失真(第i行对应于Ri，第j列对应于属性Aj)；</p>
<p><img data-src="https://image.zxkidea.top/1551253082653.png" alt="zxk"></p>
</li>
<li>
<p>填表：若A属于Ri，则将第i行第j列填为aj否则填入bij；</p>
</li>
<li>
<p>修改表：逐一考察F中的函数依赖X -&gt; Y，X可能包含一个或者多个属性，如果这（个）些属性对应于表中的列的值相同，则值相等的行所对应的Y属性所有的列的值也相等。（比方说X -&gt; Y，X是A1A2所对应的属性，Y是属性A4。由第一步，如果表中第一行和第二行的值相等，那么表中A4对应的第一行和第二行的值也要修改成一样的。）如果其中有aj，则将bij改成aj；如果没有aj，就将他们都改成bij，一般来说i是值相等的行中最小的行号。</p>
</li>
<li>
<p>反复（指在前一次修改地基础上，反复进行直到表中的数据不再改变）进行（3），若发现某一行变成a1，a2，…aj，则可以得出分解p{(R1,F1)，(R2,F2)，…(Rk,Fk)}具有连接不失真性（即无损分解）</p>
</li>
</ol>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = green size = 4>具体示例：</font></p>
<p><font color = blue size = 4>设R=ABCDE, R1=AD, R2=BC, R3=BE, R4=CDE, R5=AE（<span style="background: linear-gradient(to right, #f2994a, #f2c94c);">省略F~i~，若给出U~i~，则表示求R~i~（U~i~，F~i~）</span>）, 设函数依赖：A-&gt;C, B-&gt;C, C-&gt;D, DE-&gt;C, CE-&gt;A. 判断R分解成 ρ={R1,  R2,  R3,  R4,  R5}是否无损联接分解？</font></p>
<br/>
<p><font color = dark size = 4>1. 建表:</font></p>
<table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
</tr>
</thead>
<tbody>
<tr>
<td>AD</td>
<td><font color = red >a1</font></td>
<td>b12</td>
<td>b13</td>
<td><font color = red >a4</font></td>
<td>b15</td>
</tr>
<tr>
<td>BC</td>
<td>b21</td>
<td><font color = red >a2</font></td>
<td><font color = red >a3</font></td>
<td>b24</td>
<td>b25</td>
</tr>
<tr>
<td>BE</td>
<td>b31</td>
<td><font color = red >a2</font></td>
<td>b33</td>
<td>b34</td>
<td><font color = red >a5</font></td>
</tr>
<tr>
<td>CDE</td>
<td>b41</td>
<td>b42</td>
<td><font color = red >a3</font></td>
<td><font color = red >a4</font></td>
<td><font color = red >a5</font></td>
</tr>
<tr>
<td>AE</td>
<td><font color = red >a1</font></td>
<td>b52</td>
<td>b53</td>
<td>b54</td>
<td><font color = red >a5</font></td>
</tr>
</tbody>
</table>
<br/>
<blockquote>
<p><font color = green size = 4>分析：</font></p>
<p>(A B C D E)是关系R的属性， AD, BC, BE, CDE, AE 是分解之后每一个关系对应的属性集</p>
<p><font color = green size = 4>填表的过程：</font></p>
<p>当横竖相交的时候，如果在分解关系中存在对应列的单个的属性（譬如第一列第一行AD与A相交的单元格，AD含有A，就填写a1），则填写a下标 ， 下标就是单元格对应所在的列号。否则填写b下标， 下标是单元格对应所在的行列号。</p>
</blockquote>
  <br/>
<p><font color = dark size = 4>2. 根据依赖关系修改原始表：</font></p>
<ol>
<li>对于依赖关系A$\rightarrow$C，看A列中有两行a1是相等的（第一行和第五行），所以在C列中对应的两行也应该相等，但是看到这两行都是b（b13，b53），所以将这个b都换成b13（上面的较小的标）</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">A</th>
<th style="text-align:center">B</th>
<th style="text-align:center">C</th>
<th style="text-align:center">D</th>
<th style="text-align:center">E</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">AD</td>
<td style="text-align:center"><font color = red >a1</font></td>
<td style="text-align:center">b12</td>
<td style="text-align:center"><font color = blue >b13</font></td>
<td style="text-align:center"><font color = red >a4</font></td>
<td style="text-align:center">b15</td>
</tr>
<tr>
<td style="text-align:center">BC</td>
<td style="text-align:center">b21</td>
<td style="text-align:center"><font color = red >a2</font></td>
<td style="text-align:center"><font color = red >a3</font></td>
<td style="text-align:center">b24</td>
<td style="text-align:center">b25</td>
</tr>
<tr>
<td style="text-align:center">BE</td>
<td style="text-align:center">b31</td>
<td style="text-align:center"><font color = red >a2</font></td>
<td style="text-align:center">b33</td>
<td style="text-align:center">b34</td>
<td style="text-align:center"><font color = red >a5</font></td>
</tr>
<tr>
<td style="text-align:center">CDE</td>
<td style="text-align:center">b41</td>
<td style="text-align:center">b42</td>
<td style="text-align:center"><font color = red >a3</font></td>
<td style="text-align:center"><font color = red >a4</font></td>
<td style="text-align:center"><font color = red >a5</font></td>
</tr>
<tr>
<td style="text-align:center">AE</td>
<td style="text-align:center"><font color = red >a1</font></td>
<td style="text-align:center">b52</td>
<td style="text-align:center"><font color = blue >b53 $\rightarrow$ b13</font></td>
<td style="text-align:center">b54</td>
<td style="text-align:center"><font color = red >a5</font></td>
</tr>
</tbody>
</table>
<br/>
<ol start="2">
<li>对于依赖B $\rightarrow$ C, 同样的道理，看B这一列中，第二行和第三行都是a2,那么对C这一列同样的操作，但是看到C这一列中第二行是a3，那么就将第三行改成a3，优先级比b要高。</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">A</th>
<th style="text-align:center">B</th>
<th style="text-align:center">C</th>
<th style="text-align:center">D</th>
<th style="text-align:center">E</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">AD</td>
<td style="text-align:center"><font color = red >a1</font></td>
<td style="text-align:center">b12</td>
<td style="text-align:center">b13</td>
<td style="text-align:center"><font color = red >a4</font></td>
<td style="text-align:center">b15</td>
</tr>
<tr>
<td style="text-align:center">BC</td>
<td style="text-align:center">b21</td>
<td style="text-align:center"><font color = red >a2</font></td>
<td style="text-align:center"><font color = red >a3</font></td>
<td style="text-align:center">b24</td>
<td style="text-align:center">b25</td>
</tr>
<tr>
<td style="text-align:center">BE</td>
<td style="text-align:center">b31</td>
<td style="text-align:center"><font color = red >a2</font></td>
<td style="text-align:center"><font color = blue >b33 $\rightarrow$ a3</font></td>
<td style="text-align:center">b34</td>
<td style="text-align:center"><font color = red >a5</font></td>
</tr>
<tr>
<td style="text-align:center">CDE</td>
<td style="text-align:center">b41</td>
<td style="text-align:center">b42</td>
<td style="text-align:center"><font color = red >a3</font></td>
<td style="text-align:center"><font color = red >a4</font></td>
<td style="text-align:center"><font color = red >a5</font></td>
</tr>
<tr>
<td style="text-align:center">AE</td>
<td style="text-align:center"><font color = red >a1</font></td>
<td style="text-align:center">b52</td>
<td style="text-align:center">b13</td>
<td style="text-align:center">b54</td>
<td style="text-align:center"><font color = red >a5</font></td>
</tr>
</tbody>
</table>
<br/>
<ol start="3">
<li>对依赖C$\rightarrow$D，C列的1，5行相等，D的1，5行也应该相等，D的第1行有a，所以b54换成a4；另外C列的2，3，4行也相等，D的2，3，4行也应该相等，D的第4行有a，所以将对应的行都换成a4。</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">A</th>
<th style="text-align:center">B</th>
<th style="text-align:center">C</th>
<th style="text-align:center">D</th>
<th style="text-align:center">E</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">AD</td>
<td style="text-align:center"><font color = red >a1</font></td>
<td style="text-align:center">b12</td>
<td style="text-align:center">b13</td>
<td style="text-align:center"><font color = red >a4</font></td>
<td style="text-align:center">b15</td>
</tr>
<tr>
<td style="text-align:center">BC</td>
<td style="text-align:center">b21</td>
<td style="text-align:center"><font color = red >a2</font></td>
<td style="text-align:center"><font color = red >a3</font></td>
<td style="text-align:center"><font color = blue >b24 $\rightarrow$ a4</font></td>
<td style="text-align:center">b25</td>
</tr>
<tr>
<td style="text-align:center">BE</td>
<td style="text-align:center">b31</td>
<td style="text-align:center"><font color = red >a2</font></td>
<td style="text-align:center"><font color = red >a3</font></td>
<td style="text-align:center"><font color = blue >b34 $\rightarrow$ a4</font></td>
<td style="text-align:center"><font color = red >a5</font></td>
</tr>
<tr>
<td style="text-align:center">CDE</td>
<td style="text-align:center">b41</td>
<td style="text-align:center">b42</td>
<td style="text-align:center"><font color = red >a3</font></td>
<td style="text-align:center"><font color = red >a4</font></td>
<td style="text-align:center"><font color = red >a5</font></td>
</tr>
<tr>
<td style="text-align:center">AE</td>
<td style="text-align:center"><font color = red >a1</font></td>
<td style="text-align:center">b52</td>
<td style="text-align:center">b13</td>
<td style="text-align:center"><font color = blue >b54 $\rightarrow$ a4</font></td>
<td style="text-align:center"><font color = red >a5</font></td>
</tr>
</tbody>
</table>
  <br/>
<ol start="4">
<li>对于DE$\rightarrow$C, DE公共的相等的行是3，4，5行，对应C的3，4，5行也应该相等，故将C列最后的b13换成a3，所以表格经过这个函数依赖关系，就是：</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">A</th>
<th style="text-align:center">B</th>
<th style="text-align:center">C</th>
<th style="text-align:center">D</th>
<th style="text-align:center">E</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">AD</td>
<td style="text-align:center"><font color = red >a1</font></td>
<td style="text-align:center">b12</td>
<td style="text-align:center">b13</td>
<td style="text-align:center"><font color = red >a4</font></td>
<td style="text-align:center">b15</td>
</tr>
<tr>
<td style="text-align:center">BC</td>
<td style="text-align:center">b21</td>
<td style="text-align:center"><font color = red >a2</font></td>
<td style="text-align:center"><font color = red >a3</font></td>
<td style="text-align:center"><font color = red >a4</font></td>
<td style="text-align:center">b25</td>
</tr>
<tr>
<td style="text-align:center">BE</td>
<td style="text-align:center">b31</td>
<td style="text-align:center"><font color = red >a2</font></td>
<td style="text-align:center"><font color = red >a3</font></td>
<td style="text-align:center"><font color = red >a4</font></td>
<td style="text-align:center"><font color = red >a5</font></td>
</tr>
<tr>
<td style="text-align:center">CDE</td>
<td style="text-align:center">b41</td>
<td style="text-align:center">b42</td>
<td style="text-align:center"><font color = red >a3</font></td>
<td style="text-align:center"><font color = red >a4</font></td>
<td style="text-align:center"><font color = red >a5</font></td>
</tr>
<tr>
<td style="text-align:center">AE</td>
<td style="text-align:center"><font color = red >a1</font></td>
<td style="text-align:center">b52</td>
<td style="text-align:center"><font color = blue >b13 $\rightarrow$ a3</font></td>
<td style="text-align:center"><font color = red >a4</font></td>
<td style="text-align:center"><font color = red >a5</font></td>
</tr>
</tbody>
</table>
<br/>
<ol start="5">
<li>对于CE$\rightarrow$A, CE的公共行是3，4，5行，所以将A的3，4，5行也对应相等，因为A列的第五行含有a1，所以将3，4行的b31,b41都换成a1</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">A</th>
<th style="text-align:center">B</th>
<th style="text-align:center">C</th>
<th style="text-align:center">D</th>
<th style="text-align:center">E</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">AD</td>
<td style="text-align:center"><font color = red >a1</font></td>
<td style="text-align:center">b12</td>
<td style="text-align:center">b13</td>
<td style="text-align:center"><font color = red >a4</font></td>
<td style="text-align:center">b15</td>
</tr>
<tr>
<td style="text-align:center">BC</td>
<td style="text-align:center">b21</td>
<td style="text-align:center"><font color = red >a2</font></td>
<td style="text-align:center"><font color = red >a3</font></td>
<td style="text-align:center"><font color = red >a4</font></td>
<td style="text-align:center">b25</td>
</tr>
<tr>
<td style="text-align:center">BE</td>
<td style="text-align:center"><font color = blue >b31 $\rightarrow$ a1</font></td>
<td style="text-align:center"><font color = red >a2</font></td>
<td style="text-align:center"><font color = red >a3</font></td>
<td style="text-align:center"><font color = red >a4</font></td>
<td style="text-align:center"><font color = red >a5</font></td>
</tr>
<tr>
<td style="text-align:center">CDE</td>
<td style="text-align:center"><font color = blue >b41 $\rightarrow$ a1</font></td>
<td style="text-align:center">b42</td>
<td style="text-align:center"><font color = red >a3</font></td>
<td style="text-align:center"><font color = red >a4</font></td>
<td style="text-align:center"><font color = red >a5</font></td>
</tr>
<tr>
<td style="text-align:center">AE</td>
<td style="text-align:center"><font color = red >a1</font></td>
<td style="text-align:center">b52</td>
<td style="text-align:center"><font color = red >a3</font></td>
<td style="text-align:center"><font color = red >a4</font></td>
<td style="text-align:center"><font color = red >a5</font></td>
</tr>
</tbody>
</table>
<br/>
<ol start="6">
<li>最终得到的表格就是：</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">A</th>
<th style="text-align:center">B</th>
<th style="text-align:center">C</th>
<th style="text-align:center">D</th>
<th style="text-align:center">E</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">AD</td>
<td style="text-align:center"><font color = red >a1</font></td>
<td style="text-align:center">b12</td>
<td style="text-align:center">b13</td>
<td style="text-align:center"><font color = red >a4</font></td>
<td style="text-align:center">b15</td>
</tr>
<tr>
<td style="text-align:center">BC</td>
<td style="text-align:center">b21</td>
<td style="text-align:center"><font color = red >a2</font></td>
<td style="text-align:center"><font color = red >a3</font></td>
<td style="text-align:center"><font color = red >a4</font></td>
<td style="text-align:center">b25</td>
</tr>
<tr>
<td style="text-align:center">BE</td>
<td style="text-align:center"><font color = red >a1</font></td>
<td style="text-align:center"><font color = red >a2</font></td>
<td style="text-align:center"><font color = red >a3</font></td>
<td style="text-align:center"><font color = red >a4</font></td>
<td style="text-align:center"><font color = red >a5</font></td>
</tr>
<tr>
<td style="text-align:center">CDE</td>
<td style="text-align:center"><font color = red >a1</font></td>
<td style="text-align:center">b42</td>
<td style="text-align:center"><font color = red >a3</font></td>
<td style="text-align:center"><font color = red >a4</font></td>
<td style="text-align:center"><font color = red >a5</font></td>
</tr>
<tr>
<td style="text-align:center">AE</td>
<td style="text-align:center"><font color = red >a1</font></td>
<td style="text-align:center">b52</td>
<td style="text-align:center"><font color = red >a3</font></td>
<td style="text-align:center"><font color = red >a4</font></td>
<td style="text-align:center"><font color = red >a5</font></td>
</tr>
</tbody>
</table>
<br/>
<p><font color = dark size = 4>3. 最后，我们从表格里看到对于BE行来说，变成a1…a5，所以得出结论，题中的分解是无损联接分解</font></p>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = green size = 4>无损分解的一个简便的判别方法（<span style="background: linear-gradient(to right, #74ebd5, #acb6e5);">适用于分解成2个关系的情况</span>）</font></p>
<blockquote>
<p>例如：</p>
<p>有关系R=ABC, 依赖关系F = {A–&gt;B}那么下面哪个是无损分解：</p>
<p>A. {R1(AB), R2(AC)}<br>
B. {R1(AB), R3(BC)}</p>
</blockquote>
  <br/>
<p><font color = brown size = 4>求解方法：</font></p>
<p><font color = blue size = 4>1. 建表法：</font></p>
<p><span style="background: linear-gradient(to right, #f2994a, #f2c94c);"><font color = green size = 4>选项A：</font></span></p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">A</th>
<th style="text-align:center">B</th>
<th style="text-align:center">C</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">AB</td>
<td style="text-align:center"><font color = red >a1</font></td>
<td style="text-align:center"><font color = red >a2</font></td>
<td style="text-align:center">b13</td>
</tr>
<tr>
<td style="text-align:center">AC</td>
<td style="text-align:center"><font color = red >a1</font></td>
<td style="text-align:center">b22</td>
<td style="text-align:center"><font color = red >a3</font></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">A</th>
<th style="text-align:center">B</th>
<th style="text-align:center">C</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">AB</td>
<td style="text-align:center"><font color = red >a1</font></td>
<td style="text-align:center"><font color = red >a2</font></td>
<td style="text-align:center">b13</td>
</tr>
<tr>
<td style="text-align:center">AC</td>
<td style="text-align:center"><font color = red >a1</font></td>
<td style="text-align:center"><font color = red >a2</font></td>
<td style="text-align:center"><font color = red >a3</font></td>
</tr>
</tbody>
</table>
<p><span style="background: linear-gradient(to right, #f2994a, #f2c94c);"><font color = green size = 4>选项B：</font></span></p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">A</th>
<th style="text-align:center">B</th>
<th style="text-align:center">C</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">AB</td>
<td style="text-align:center"><font color = red >a1</font></td>
<td style="text-align:center"><font color = red >a2</font></td>
<td style="text-align:center">b13</td>
</tr>
<tr>
<td style="text-align:center">BC</td>
<td style="text-align:center">b21</td>
<td style="text-align:center"><font color = red >a2</font></td>
<td style="text-align:center"><font color = red >a3</font></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">A</th>
<th style="text-align:center">B</th>
<th style="text-align:center">C</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">AB</td>
<td style="text-align:center"><font color = red >a1</font></td>
<td style="text-align:center"><font color = red >a2</font></td>
<td style="text-align:center">b13</td>
</tr>
<tr>
<td style="text-align:center">BC</td>
<td style="text-align:center">b21</td>
<td style="text-align:center"><font color = red >a2</font></td>
<td style="text-align:center"><font color = red >a3</font></td>
</tr>
</tbody>
</table>
<blockquote>
<p><font color = red size = 4>结论：</font><font color = green size = 4>选项A的AC一行为a1…a3，故此时为无损分解；而选项B无法化成，所以不是无损分解。</font></p>
</blockquote>
<p><font color = blue size = 4>2. 快速判别法：</font></p>
<blockquote>
<ol>
<li>
<p>首先看选项A，R1∩R2=A，R1-R2=B，R1∩ R2–&gt;(R1-R2) F+.所以它是无损分解</p>
</li>
<li>
<p>再看选项B， R1∩R2=B, R1-R2=A, R2-R1=C,</p>
</li>
<li>
<p>所以它不是无损分解</p>
</li>
</ol>
</blockquote>
<br/>
<blockquote>
<p><font color = red size = 4>快速判断无损分解的方法就是:</font></p>
<p><font color = green size = 4>1. 对两个集合先求集合的∩，然后求集合的差(2个集合有两个差的结果)<br>
如果集合的∩–&gt;集合的差（得到差结果的任意一个）$\subseteq$ F^+^ 成立，那么就是无损分解</font></p>
<p><font color = green size = 4>2. 如果R1∩R2是R1或R2的超码，则R上的分解（R1，R2）是无损分解。这是一个<font color = red>充分条件</font>，当所有的约束都是函数依赖时它才是必要条件（例如多值依赖就是一种非函数依赖的约束），不过这已经足够了。</font></p>
</blockquote>
  <br/>
</li>
</ul>
<h4 id="font-color-blue-2-保持函数依赖-font"><font color = blue>2) 保持函数依赖</font></h4>
<ul>
<li>
<p><font color = green size = 4>定义:</font></p>
<blockquote>
<p>如果F上的每一个函数依赖都在其分解后的<font color = red>某一个关系上</font>成立，则这个分解是保持依赖的（这是一个<font color = red >充分条件</font>）。如果上述判断失败，并不能断言分解不是保持依赖的，还要使用下面的通用方法来做进一步判断。</p>
</blockquote>
<br/>
<blockquote>
<p>设F是关系模式R的函数依赖集，ρ={R1&lt;U1,F1&gt;, R2&lt;U2,F2&gt;,…, Rk&lt;Uk,Fk&gt;}为R的一个分解，如果Fi=π~Ri~(F)<font color = red >(Fi为函数依赖集F在Ri上的投影)</font>的并集(F1∪F2∪…∪Fk) ≡ F（i=1,2,…,k）,则称分解ρ具有函数依赖保持性。</p>
</blockquote>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = green size = 4>保持依赖判定算法：</font></p>
<ul>
<li>
<p>对F上的每一个α→β使用下面的过程：</p>
<blockquote>
<p><font color = dark size = 4>result:=α;</font><br>
<font color = dark size = 4>while(result发生变化)do</font><br>
<font color = dark size = 4> 	for each 分解后的Ri</font><br>
<font color = dark size = 4>t=(result∩Ri)^+^∩Ri</font><br>
<font color = dark size = 4>result=result∪t</font></p>
</blockquote>
</li>
</ul>
<br/>
<ul>
<li>这里的属性闭包是在函数依赖集F下计算出来的。如果result中包含了β的所有属性，则函数依赖α→β。分解是保持依赖的当且仅当上述过程中F的所有依赖都被保持。</li>
</ul>
<br/>
<blockquote>
<p><font color = red>函数依赖保持判断方法：</font></p>
<ol>
<li><font color = green>先找到要分解的目标R~i~（U~i~），然后求出U~i~^+^；</font></li>
<li><font color = green>接着在F中找到所有包含U~i~^+^属性的关系 ；</font></li>
<li><font color = green>挑选或推导出仅含有R~i~（U~i~）中属性的关系，组成即为F~i~ ；</font></li>
</ol>
</blockquote>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = green size = 4>示例：</font></p>
<p><font color = blue size = 4>1. 将R = (ABCD，{A→B，B→C，B→D，C→A})分解为关于U1=AB，U2=ACD两个关系（<span style="background: linear-gradient(to right, #f2994a, #f2c94c);">给出U~i~，则表示求R~i~（U~i~，F~i~）</span>），求R1、R2，<br>
并检验分解的无损联接性和分解的函数依赖保持性。</font></p>
<p><font color = brown size = 4>求解方法：</font></p>
<p><font color = blue>1. 无损分解：</font></p>
<blockquote>
<p>F1 = π~R1~(F) = {A→B, B→A},<br>
F2 = π~R2~(F) = {A→C, C→A, A→D}</p>
<blockquote>
<p><font color = red>注意：</font><font color = green>Fi为仅含有Ui中元素，且在F上的所有关系（包含推导关系）</font></p>
</blockquote>
<p>R1 = (AB, {A→B, B→A})<br>
R2 = (ACD, {A→C, C→A, A→D})</p>
<p><font color = red>U1∩U2 = AB∩ACD = A, </font></p>
<p><font color = red>U1-U2 = AB-ACD = B, A→B∈F, </font></p>
<p><font color = blue>所以ρ是无损分解；</font></p>
</blockquote>
<br/>
<p><font color = blue>2. 函数依赖性：</font></p>
<blockquote>
<p><font color = red>F1UF2 = {A→B, B→A, A→C, C→A, A→D} ≡ {A→B, B→C, B→D, C→A} = F；</font></p>
<p><font color = orange>Tip：</font><font color = green>可用定理对函数依赖进行化简，观察并集是否为F；</font></p>
<p><font color = blue>所以ρ具有函数依赖保持性。</font></p>
</blockquote>
<br/>
<p><font color = blue size = 4 >2. 关系模式R(A, B, C ,D，{F}) 中函数依赖集F = {A→B, C→D}, ρ = {R1(AB，{F~1~})，R2(CD，{F~2~})}，求R1, R2 并检验分解的无损联接性和分解的函数依赖保持性。</font></p>
<br/>
<p><font color = brown size = 4>求解方法：</font></p>
<p><font color = blue>1. 无损分解：</font></p>
<blockquote>
<p>F1 = π~R1~(F) = {A→B},<br>
F2 = π~R2~(F) = {C→D}<br>
R1(AB, {A→B}),<br>
R2(CD, {C→D})<br>
<font color = red>U1∩U2 = AB∩CD = Φ,</font><br>
<font color = red>U1-U2 = AB,</font><br>
<font color = red>U2-U1 = CD,</font><br>
Φ→AB$\notin$F,<br>
Φ→CD$\notin$F,</p>
<p><font color = blue>所以ρ不是无损分解；</font></p>
</blockquote>
<br/>
<p><font color = blue>2. 函数依赖性：</font></p>
<blockquote>
<p><font color = red>F1UF2 = {A→B，C→D} = F</font></p>
<p><font color = blue>所以ρ具有函数依赖保持性。</font></p>
</blockquote>
<br/>
<p><font color = blue size = 4 >3. 已知关系模式R(CITY, ST, ZIP), F = {(CITY, ST)→ZIP, ZIP→CITY}，以及R上的一个分解ρ = {R1(U~1~，F~1~), R2(U~2~，F~2~)}, R1 = {ST, ZIP}, R2 = {CITY, ZIP}，求R1, R2 ,并检验分解的无损联接性和分解的函数依赖保持性。</font></p>
  <br/>
<p><font color = brown size = 4>求解方法：</font></p>
<p><font color = blue>1. 无损分解：</font></p>
<blockquote>
<p>F1= π~R1~(F) = {Φ},<br>
F2 = π~R2~(F) = {ZIP→CITY}</p>
<p>R1 = ({ST, ZIP}, {Φ})，</p>
<p>R2 = (CITY, ZIP, {ZIP→CITY})</p>
<p><font color = red>U1∩U2 = {ST, ZIP}∩{CITY, ZIP} = ZIP,</font></p>
<p><font color = red>U1-U2 = ST,</font><br>
<font color = red>U2-U1 = CITY，ZIP→CITY∈F,</font></p>
<p><font color = blue>所以ρ是无损分解；</font></p>
</blockquote>
<p><font color = blue>2. 函数依赖性：</font></p>
<blockquote>
<p><font color = red>F1UF2 = {ZIP→CITY}$\neq${(CITY, ST)→ZIP, ZIP→CITY} = F</font></p>
<p><font color = blue>所以ρ不具有函数依赖保持性。</font></p>
</blockquote>
</li>
</ul>
<br/>
<blockquote>
<p><font color = red size = 4>总结：</font></p>
<ol>
<li><font color = green size = 4>无损分解：R  $\underrightarrow{F(F_i)}$   R~i~ </font></li>
<li><font color = green size = 4>函数依赖：F  $\underrightarrow{R(U_i)}$   F~i~  </font></li>
<li><font color = green size = 4>函数依赖和无损分解间没有必然的联系</font></li>
</ol>
</blockquote>
<br/>
<h3 id="6-关系模式的范式-NF">6.关系模式的范式(NF)</h3>
<h4 id="font-color-green-size-4-1）定义-font"><font color = green size = 4>1）定义</font></h4>
<blockquote>
<p>范式xNF即是满足特定要求的模式，将低一级范式的关系模式通过模式分解转换为高一级范式的关系模式集合的过程叫做<font color = red>规范化</font>；</p>
<p>范式从低级到高级依次为：1NF、2NF、3NF、BCNF、4NF、5NF，高一级的范式总是低一级范式的真子集。</p>
</blockquote>
<br/>
<blockquote>
<p>根据关系模式R的不可约函数依赖集F，可以画出节点是属性或属性集，边是由被依赖节点指向依赖节点的有向图来辅助分析关系模式，叫做<font color = red>函数依赖图</font></p>
</blockquote>
<p>从范式所允许的函数依赖方面进行比较，四种范式之间的关联如下图所示。</p>
<br/>
<p><img data-src="https://image.zxkidea.top/blog/20200304/FnyH4i7YiPew.gif" alt="zxk"></p>
<br/>
<h4 id="font-color-green-size-4-2）各类范式及其说明-font"><font color = green size = 4>2）各类范式及其说明</font></h4>
<ul>
<li>
<p><font color = blue size = 4>第一范式(1NF)</font><font color = red size = 4>(确保每列保持原子性)</font></p>
<blockquote>
<p>第一范式是最基本的范式。如果数据库表中的<font color = brown>所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式。</font></p>
</blockquote>
<br/>
<blockquote>
<p>第一范式的合理遵循需要根据系统的实际需求来定。比如某些数据库系统中需要用到“地址”这个属性，本来直接将“地址”属性设计成一个数据库表的字段就行。<font color = brown>但是如果系统经常会访问“地址”属性中的“城市”部分，那么就非要将“地址”这个属性重新拆分为省份、城市、详细地址等多个部分进行存储，这样在对地址中某一部分操作的时候将非常方便。</font>这样设计才算满足了数据库的第一范式，如下表所示：</p>
</blockquote>
<br/>
<p><img data-src="https://image.zxkidea.top/1551266870484.png" alt="zxk"></p>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = blue size = 4>第二范式(2NF)</font><font color = red size = 4>(确保表中的每列都和主键相关)</font></p>
<blockquote>
<p>第二范式在第一范式的基础之上更进一层。第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。<font color = brown>也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。</font></p>
</blockquote>
<br/>
<ul>
<li>
<p><font color = green >示例1：</font></p>
<blockquote>
<p><font color = blue >设有关系模式R(学号S#,课程号C#,成绩G,任课教师TN,教师专长TS)，基于R的函数依赖集F={(S#, C#)→G, C#→TN, TN→TS},判断R是否为2NF。</font></p>
</blockquote>
<ul>
<li>
<p><font color = brown>函数依赖图：</font></p>
<p><img data-src="https://image.zxkidea.top/blog/20200304/KywgHGFgPUdl.gif" alt="zxk"></p>
</li>
<li>
<p><font color = brown>阿氏推理规则:</font></p>
<blockquote>
<p>由F可推出：(S#, C#)→{S#, C#, G, TN, TS}，即属性组合(S#, C#)是R的候选关键字(R只有这一个候选键)。(S#, C#)的一个值可惟一标识R中的一个元组(并且没有多余的属性)。</p>
<p>在R中，S#, C#是主属性；其余的属性G, TN, TS为非主属性。</p>
</blockquote>
<br/>
<blockquote>
<p>借助上面的图，我们可以看到，非主属性G对键是完全依赖：(S#, C#)→G。但非主属性TN, TS对键是部分依赖(他们仅依赖于键的真子集C#)。由于R中存在<font color = red><em>非主属性对候选键的部分依赖</em></font>，所以关系模式R不是2NF。</p>
</blockquote>
<br/>
<blockquote>
<p><font color = red>注意：</font></p>
<ol>
<li>
<p>R中存在非主属性对候选键的部分依赖，将会引起<font color = green>插入异常、删除异常、更新异常和数据冗余</font>等问题。<font color = red>可以把关系R无损联接地分解成两个2NF的关系模式：</font></p>
<p>ρ = {R1, R2}，R1 = {S#, C#, G}, R2 = {C#, TN, TS}。</p>
</li>
<li>
<p><font color = orange>具体步骤：</font></p>
<ul>
<li>找出R中所有的候选码(X…Y)，即(X…Y)^+^ = F；</li>
<li>得到非主属性，并根据2NF定义判断是否满足2NF；</li>
</ul>
</li>
</ol>
</blockquote>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = green szie = 4>示例2：</font></p>
<blockquote>
<p><font color = blue >选课关系 R（SNO，CNO，GRADE，CREDIT）其中SNO为学号， CNO为课程号，GRADEGE 为成绩，CREDIT 为学分。 </font></p>
</blockquote>
<br/>
<p><font color = brown size = 4>求解方法：</font></p>
<ul>
<li>
<p>由以上条件，关键字为组合关键字（SNO，CNO）</p>
</li>
<li>
<p><font color = brown>原因：</font>非关键字属性CREDIT仅函数依赖于CNO，也就是CREDIT部分依赖组合关键字（SNO，CNO）而不是完全依赖。</p>
</li>
<li>
<p><font color = brown>解决方法：</font>分成两个关系模式 R1（SNO，CNO，GRADE），R2（CNO，CREDIT）。新关系包括两个关系模式，它们之间通过R1中的外关键字CNO相联系，需要时再进行自然联接，恢复了原来的关系</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = blue size = 4>第三范式(3NF)</font><font color = red size = 4>(确保每列都和主键列直接相关,而不是间接相关；即去除非主属性对于候选关键字的传递依赖)</font></p>
<blockquote>
<p>如果关系模式R为2NF，并且<font color = brown>R中的每一个非主属性都不传递依赖于R的某个候选关键字</font>，则称R是第三范式的，简记为3NF。</p>
</blockquote>
  <br/>
<ul>
<li>
<p><font color = green size = 4>示例1：</font></p>
<blockquote>
<p><font color = blue >续上例R(学号S#, 课程号C#, 成绩G, 任课教师TN, 教师专长TS)，判断关系模式R1 = {S#, C#, G}, R2 = {C#, TN, TS} 是否为3NF。</font></p>
</blockquote>
<br/>
<p><font color = brown size = 4>求解方法：</font></p>
<ul>
<li>
<p>在关系模式R1={S#,C#,G}，候选关键字是(S#,C#)，主属性是S#,C#，非主属性是G，函数依赖为(S#,C#)→G。  由于R1中不存在非主属性对候选关键字的传递依赖，所以关系模式R1是3NF。</p>
</li>
<li>
<p>在关系模式R2={C#,TN,TS}，候选关键字是C#，主属性是C#，非主属性是TN,TS，函数依赖为C#→TN，TN→TS。由于R2中存在非主属性对候选关键字的传递依赖C# ,TS，所以关系模式R2不是3NF。</p>
<p><font color = red>可以把关系R2无损联接地分解成两个3NF的关系模式：</font></p>
<p>ρ={R3,R4}，R3={C#,TN}，R4={TN,TS}。</p>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = green size = 4>示例2：</font></p>
<blockquote>
<p><font color = blue >若关系模式SD（SNO，SNAME，DNO，DNAME，LOCATION） 各属性分别代表学号，<br>
姓名，所在系，系名称，系地址。 判断关系模式SD是否为3NF。</font></p>
</blockquote>
<br/>
<p><font color = brown size = 4>求解方法：</font></p>
<ul>
<li>关键字SNO决定各个属性。由于是单个关键字，没有部分依赖的问题，是2NF。
<ul>
<li><font color = brown>原因：</font>关系中存在传递依赖造成的。关键字 SNO 对 LOCATION 函数决定是通过传递依赖:SNO -&gt; DNO，及DNO -&gt; LOCATION实现的。也就是说，SNO不直接决定非主属性LOCATION，不是3NF。</li>
</ul>
</li>
<li><font color = brown>解决目的：</font>每个关系模式中不能留有传递依赖。
<ul>
<li><font color = brown>解决方法：</font>分为两个关系 S（SNO，SNAME，DNO），D（DNO，DNAME，LOCATION）</li>
</ul>
</li>
</ul>
<br/>
<blockquote>
<p><font color = red>注意：</font></p>
<ol>
<li>关系S中<span style="background: linear-gradient(to right, #f2994a, #f2c94c);">不能没有外关键字DNO</span>；否则两个关系之间失去联系；</li>
<li>分解为3NF时注意保留外关键字。</li>
</ol>
</blockquote>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = blue size = 4>Boyce-Codd范式(BCNF)</font><font color = red size = 4>(3NF基础上去除主属性对于候选关键字的传递依赖)</font></p>
<blockquote>
<p>如果关系模式R为<span style="background: linear-gradient(to right, #74ebd5, #acb6e5);">1NF</span>，并且R中的每一个函数依赖X→Y(YÏX),必有X是R的超关键字，则称R是Boyce-Codd范式的，简记为BCNF。</p>
</blockquote>
<br/>
<ul>
<li>
<p><font color = green size =4>BCNF特性：</font></p>
<blockquote>
<ol>
<li>所有非主属性对键是完全函数依赖；</li>
<li>所有主属性对不包含它的键是完全函数依赖；</li>
<li>没有属性完全函数依赖于非键的任何属性组合</li>
<li><span style="background: linear-gradient(to right, #f2994a, #f2c94c);"><font color = dark>综上即为</font></span>：<font color = green >消除了主属性对于候选关键字的部分和传递函数依赖；</font></li>
</ol>
</blockquote>
<br/>
<blockquote>
<p>与2NF,3NF的定义不同，BCNF的定义直接建立在1NF的基础上。但实质上BCNF是3NF的改进形式。3NF仅考虑了非主属性对键的依赖情况，<font color = brown>BCNF把主属性对键的依赖情况也包括进去。</font>BCNF要求满足的条件比3NF所要求的更高。<font color = brown>如果关系模式R是BCNF的，那么R必定是3NF</font>，反之，则不一定成立。</p>
</blockquote>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = green size = 4>示例1：</font></p>
<blockquote>
<p><font color = blue >续前例R（学号S#, 课程号C#, 成绩G, 任课教师TN, 教师专长TS）,判断两个3NF关系模式R3 = {C#, TN},R4 = {TN, TS}是否为BCNF。</font></p>
</blockquote>
<br/>
<p><font color = brown size = 4>求解方法：</font></p>
<ul>
<li>
<p>在关系模式R3中有函数依赖C#→TN，决定因素C#是R3的键；</p>
<p>在关系模式R4中有函数依赖TN→TS，决定因素TN是R4的键；</p>
<p>R3,R4都满足BCNF的定义，所以，这两个关系模式都是BCNF。</p>
</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = green size = 4>示例2：</font></p>
<blockquote>
<p><font color = blue >配件管理关系模式 WPE（WNO，PNO，ENO，QNT）分别表仓库号，配件号，职工号，数量。</font></p>
<p><font color = blue >有以下条件:</font> <br>
a.一个仓库有多个职工。<br>
b.一个职工仅在一个仓库工作。<br>
c.每个仓库里一种型号的配件由专人负责，但一个人可以管理几种配件。<br>
d.同一种型号的配件可以分放在几个仓库中。</p>
</blockquote>
<br/>
<p><font color = brown size = 4>求解方法：</font></p>
<ul>
<li>
<p><font color = brown>分析：</font></p>
<p>由以上得 PNO 不能确定QNT，由组合属性（WNO，PNO）来决定，存在函数依赖（WNO，PNO） -&gt; QNT。由于每个仓库里的一种配件由专人负责，而一个人可以管理几种配件，所以有组合属性（WNO，PNO）才能确定负责人，有<font color = red>（WNO，PNO）-&gt; ENO</font>。因为 一个职工仅在一个仓库工作，有<font color = red>ENO -&gt; WNO</font>。由于每个仓库里的一种配件由专人负责，而一个职工仅在一个仓库工作，有 <font color = red>（ENO，PNO）-&gt; QNT</font>。</p>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = brown>候选关键字:</font></p>
<p>因为（WNO，PNO） -&gt; QNT，（WNO，PNO）-&gt; ENO ，因此 （WNO，PNO）可以决定整个元组，是一个候选关键字。根据ENO-&gt;WNO，（ENO，PNO）-&gt;QNT，故（ENO，PNO）也能决定整个元组，为另一个候选关键字。<font color = red>属性ENO，WNO，PNO 均为主属性</font>，只有一个非主属性QNT。它对任何一个候选关键字都是完全函数依赖的，并且是直接依赖，所以该关系模式是3NF。</p>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = brown>主属性:</font></p>
<p>因为ENO-&gt;WNO，主属性ENO是WNO的决定因素，但是它本身不是关键字，只是组合关键字的一部分。这就造成主属性WNO对另外一个候选关键字（ENO，PNO）的部分依赖，因为（ENO，PNO）-&gt; ENO，但反过来不成立，而ENO-&gt;WNO，故（ENO，PNO）-&gt; WNO 也是传递依赖。<br>
虽然没有非主属性对候选关键字的传递依赖，但<font color = red>存在主属性对候选关键字的传递依赖</font>，同样也会带来麻烦。如一个新职工分配到仓库工作，但暂时处于实习阶段，没有独立负责对某些配件的管理任务。由于缺少关键字的一部分PNO而无法插入到该关系中去。又如某个人改成不管配件了去负责安全，则在删除配件的同时该职工也会被删除。</p>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = brown>解决办法：</font></p>
<p>分成管理EP（ENO，PNO，QNT），关键字是（ENO，PNO）；工作EW（ENO，WNO），关键字是ENO</p>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = brown>缺点：</font></p>
<p>分解后函数依赖的保持性较差。如此例中，由于分解,函数依赖（WNO，PNO）-&gt; ENO 丢失了, 因而对原来的语义有所破坏。没有体现出每个仓库里一种部件由专人负责。有可能出现 一部件由两个人或两个以上的人来同时管理。因此，分解之后的关系模式降低了部分完整性约束。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>
<p><span style="background: linear-gradient(to right, #74ebd5, #acb6e5);"><font color = green size = 4>总结：</font></span></p>
<p><img data-src="https://image.zxkidea.top/1551857237283.png" alt="zxk"></p>
<br/>
<blockquote>
<p><span style="background: linear-gradient(to right, #f2994a, #f2c94c);"><font color = green size = 4>化简为BCNF：</font></span></p>
<ol>
<li><font color = green >先将关系模式化简为3NF；</font></li>
<li><font color = green >再找出所有候选关键字及其主属性；</font></li>
<li><font color = green >接着根据函数依赖关系判断是否存在主属性对候选关键字的传递依赖或部分依赖；</font></li>
<li><font color = green >最后将造成传递依赖或部分依赖的关系模式分解出去；</font></li>
</ol>
</blockquote>
<br/>
<h3 id="7-关系模式分解为范式的分解算法">7.关系模式分解为范式的分解算法</h3>
<h4 id="font-color-green-size-4-1）无损连接且保持函数依赖地分解R到3NF-font"><font color = green size = 4>1）无损连接且保持函数依赖地分解R到3NF</font></h4>
<ul>
<li>
<p><font color = blue size = 4>示例1：</font></p>
<blockquote>
<p>U = (A, B, C, D, E, G),  F = {BG-&gt;C，BD-&gt;E，DG-&gt;C，ADG-&gt;BC，AG-&gt;B，B-&gt;D}   若R不是3NF，将R分解为无损且保持函数依赖的3NF。</p>
</blockquote>
<br/>
<p><font color = red size = 4>求解方法：</font></p>
<p><font color = brown>1. 先求出候选码：</font></p>
<ul>
<li>分为L类，N类，R类；</li>
<li>按求候选码规则求得候选码为AG</li>
</ul>
<br/>
<p><font color = brown>2. 再求出最小依赖集F~m~：</font></p>
<ul>
<li>将F中的所有依赖右边化为单一元素</li>
<li>去掉F各函数依赖左边的冗余属性</li>
<li>去掉F中所有冗余依赖关系</li>
<li>求得F~m~ = {B-&gt;E，DG-&gt;C，AG-&gt;B，B-&gt;D}</li>
</ul>
<br/>
<p><font color = brown>3. 左部相同原则分组：</font></p>
<ul>
<li>对F~m~按具有相同左部的原则分组，然后<font color = green>左部∪右部。</font></li>
<li>U1 = B∪DE = BDE  ;  U2 = DGC ;  U3 = AGB</li>
</ul>
<br/>
<p><font color = brown>4. 看有没有包含关系，有的话，合并吸收。</font></p>
<ul>
<li>将R分解为ρ = { R1({B, D, E}，{B-&gt;E, B-&gt;D})，R2({C, D, G}，{DG-&gt;C})，R3({A, B, G}，{AG-&gt;B}) }</li>
<li>不存在包含关系</li>
</ul>
<br/>
<p><font color = brown>5. 看分的属性组里有没有包含码，包含了，就是无损且保持函数依赖的3NF，没有包含，就不是无损且保持函数依赖的3NF，就加一个分组，把码加进去。</font></p>
<ul>
<li>因为候选键AG在U3中，所以所求分解ρ具有无损连接性，并保持函数依赖，且每个子模式为3NF。</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>
<p><font color = blue size = 4>示例2：</font></p>
<blockquote>
<p>U=(A, B, C, D, E) ,  F = {AB-&gt;C，C-&gt;B，D-&gt;E，D-&gt;C}   若R不是3NF，将R分解为无损且保持函数依赖的3NF。</p>
</blockquote>
<br/>
<p><font color = red size = 4>求解方法：</font></p>
<p><font color = brown>1. 先求出候选码：</font></p>
<ul>
<li>分为L类，N类，R类；</li>
<li>按求候选码规则求得候选码为AD</li>
</ul>
<br/>
<p><font color = brown>2. 再求出最小依赖集F~m~：</font></p>
<ul>
<li>将F中的所有依赖右边化为单一元素</li>
<li>去掉F各函数依赖左边的冗余属性</li>
<li>去掉F中所有冗余依赖关系</li>
<li>求得F~m~ = {AB-&gt;C，C-&gt;B，D-&gt;E，D-&gt;C}</li>
</ul>
<br/>
<p><font color = brown>3. 左部相同原则分组：</font></p>
<ul>
<li>对F~m~按具有相同左部的原则分组，然后<font color = green>左部∪右部。</font></li>
<li>U1 = ABC  ;   U2 = BC  ; U3 = DCE</li>
</ul>
<br/>
<p><font color = brown>4. 看有没有包含关系，有的话，合并吸收。</font></p>
<ul>
<li>
<p>将R分解为ρ = { R1((A, B, C)，{AB-&gt;C})，R2((B, C)，{C-&gt;B})，R3((C, D, E)，{D-&gt;E, D-&gt;C}) }</p>
</li>
<li>
<p><font color = green>合并吸收：</font>ρ = { R1((A, B, C)，{AB-&gt;C, C-&gt;B})，R2((C, D, E)，{D-&gt;E, D-&gt;C}) }</p>
</li>
</ul>
<br/>
<p><font color = brown>5. 看分的属性组里有没有包含码，包含了，就是无损且保持函数依赖的3NF，没有包含，就不是无损且保持函数依赖的3NF，就加一个分组，把码加进去。</font></p>
<ul>
<li>不是无损连接，添加码。</li>
<li>R3((A, D)，{∅})</li>
<li>所以ρ = { R1((A, B, C)，{AB-&gt;C，C-&gt;B})，R2((C, D, E)，{D-&gt;E, D-&gt;C})，R3((A, D)，{∅}) }</li>
</ul>
</li>
</ul>
<br/>
<h4 id="font-color-green-size-4-2）无损联接地分解R到BCNF-font"><font color = green size = 4>2）无损联接地分解R到BCNF</font></h4>
<ul>
<li>
<p><font color = blue size = 4>示例：</font></p>
<blockquote>
<p>关系模式R&lt;U, F&gt;, 有U = {A, B, C, D, E, G}, F = {B-&gt;G, CE-&gt;B, C-&gt;A, CE-&gt;G, B-&gt;D, C-&gt;D}</p>
</blockquote>
<br/>
<p><font color = red size = 4>求解方法：</font></p>
<p><font color = brown>1. 先求出候选码：</font></p>
<ul>
<li>
<p>分为L类，N类，R类；</p>
</li>
<li>
<p>按求候选码规则求得候选码为CE</p>
</li>
</ul>
<br/>
<p><font color = brown>2. 再求出最小依赖集F~m~：</font></p>
<ul>
<li>F~m~ = {B-&gt;G, CE-&gt;B, C-&gt;A, B-&gt;D, C-&gt;D}。</li>
</ul>
<br/>
<p><font color = brown>3. 循环分解函数依赖集：</font></p>
<ul>
<li>开始找左部不包含CE的关系模式，第一个为B-&gt;G，</li>
<li>将其分为R1 = {(BG), {B-&gt;G}} 与R2 = {(ABCDE), {CE-&gt;B, C-&gt;A, B-&gt;D, C-&gt;D}}。</li>
<li>注意G不能出现在R2中，要根据与G相关的关系模式进行替代。</li>
</ul>
<br/>
<ul>
<li>求R1与R2的最小函数依赖集，步骤均是按照上述算法严格进行的。</li>
<li>R1，R2最小函数依赖集是其本身。</li>
</ul>
<br/>
<ul>
<li>然后再进行分解，R1符合BCNF，继续分解R2：</li>
<li>B-&gt;D,左部不含码，于是分解为R2={(BD), {B-&gt;D}}，R3={(ABCE)，{CE-&gt;B, C-&gt;A}}。</li>
</ul>
<br/>
<ul>
<li>R2，R3的最小函数依赖集均是其本身。</li>
</ul>
<br/>
<ul>
<li>于是BCNF分解的最后结果为{(BG), (BD), (ABCE)}。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>数据库基础</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>考研</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>DatabaseNotes-Ch3,4</title>
    <url>/posts/928c862a.html</url>
    <content><![CDATA[<h2 id="Ch3-Basic-SQL-Query-Language">Ch3:  Basic SQL Query Language</h2>
<h3 id="一-Setting-up-the-Database">一. Setting up the Database</h3>
<h4 id="1-SQL-Datatype">1. SQL  Datatype</h4>
<p><font color = blue size = 4>CHARACTER(n), CHAR(n)：</font> fixed-length character strings</p>
<p><font color = blue size = 4>CHARACTER VARYING(n), CHAR VARYING(n)：</font>variable-length character strings</p>
<p><font color = blue size = 4>NUMERIC(p, s), DECIMAL(p, s), DEC(p, s):</font></p>
<a id="more"></a>
<p><font color = blue size = 4>Precision:</font> total number of digits</p>
<p><font color = blue size = 4>Scale：</font>number of digits to the right of the decimal point</p>
<p><font color = blue size = 4>INTEGER, INT, SMALLINT</font></p>
<p><font color = blue size = 4>FLOAT§</font></p>
<p><font color = blue size = 4>REAL</font></p>
<p><font color = blue size = 4>DOUBLE PRECISION</font></p>
<br/>
<h4 id="2-Oracle-Datatype">2.Oracle  Datatype</h4>
<p><font color = blue size = 4>Character Datatype</font></p>
<blockquote>
<p>CHAR(n)：fixed-length character strings(1$\leq$ n $\leq$2000)</p>
<p>VARCHAR(n)：variable-length character strings(1$\leq$ n $\leq$ 4000)</p>
<p>LONG：variable-length character data(text data) (maximum size 2GB)</p>
</blockquote>
<br/>
<p><font color = blue size = 4>NUMBER Datatype</font></p>
<blockquote>
<p>NUMBER：fixed and floating-point numbers</p>
<p>NUMBER(precision, scale)</p>
<p>NUMBER(*, scale)</p>
<p>Precision：total number of digits</p>
<p>Scale：number of digits to the right of the decimal point(default value is zero)</p>
<p>Negative Scale：rounds the actual data to the specified number of places to the left of the decimal point</p>
</blockquote>
<br/>
<h4 id="3-SQL-Statement">3.SQL  Statement</h4>
<h5 id="1-SQL-statements-for-table-creation-for-CAP-database">1)  SQL statements for table creation for CAP database</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span>  orders (</span><br><span class="line">cid <span class="built_in">CHAR</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">cname <span class="built_in">VARCHAR</span>(<span class="number">13</span>),</span><br><span class="line">city <span class="built_in">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">discnt <span class="built_in">REAL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span>(cid) );</span><br></pre></td></tr></table></figure>
<br/>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span>  orders (</span><br><span class="line">ordno <span class="built_in">INTEGER</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="keyword">month</span> <span class="built_in">CHAR</span>(<span class="number">3</span>),</span><br><span class="line">cid <span class="built_in">CHAR</span>(<span class="number">4</span>),</span><br><span class="line">aid <span class="built_in">CHAR</span>(<span class="number">3</span>),</span><br><span class="line">pid <span class="built_in">CHAR</span>(<span class="number">3</span>),</span><br><span class="line">qty <span class="built_in">INTEGER</span>,</span><br><span class="line">dollars <span class="keyword">DOUBLE</span> <span class="keyword">PRECISION</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span>(ordno) );</span><br></pre></td></tr></table></figure>
<br/>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- MYSQL</span><br><span class="line">create table Student(</span><br><span class="line">    Sno int not null auto_increment primary key,</span><br><span class="line">    Sname varchar(10) not null,</span><br><span class="line">    Sex char(1) not null,</span><br><span class="line">    Sage tinyint(100) not null,</span><br><span class="line">    Sdept char(4) not null)comment &#x3D; &#39;学生表&#39;;</span><br></pre></td></tr></table></figure>
<br/>
<h5 id="2-Select-Statement">2) Select Statement</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  * | colname &#123; , colname ... &#125;</span><br><span class="line"><span class="keyword">FROM</span>  tablename &#123; , tablename ... &#125;</span><br><span class="line">[ <span class="keyword">WHERE</span> search_condition ]</span><br><span class="line">[ <span class="keyword">GROUP</span> <span class="keyword">BY</span> colname &#123; , colname ... &#125;</span><br><span class="line">[ <span class="keyword">HAVING</span> search_condition ] ]</span><br><span class="line">[ <span class="keyword">ORDER</span> <span class="keyword">BY</span> colname [ <span class="keyword">ASC</span> | <span class="keyword">DESC</span> ]</span><br><span class="line">&#123; , colname [ <span class="keyword">ASC</span> | <span class="keyword">DESC</span> ] ... &#125; ];</span><br></pre></td></tr></table></figure>
<br/>
<hr>
<h3 id="二-Simple-Select-Statements">二. Simple Select Statements</h3>
<h4 id="1-Relational-Algebra与SQL语法对比">1. Relational Algebra与SQL语法对比</h4>
<p><font color = blue size = 4>1. Query in relational algebra :</font></p>
<blockquote>
<p><font color = green size = 4>(R where Condition) [A$_1$, A$_2$, …, A$_m$]</font></p>
</blockquote>
<br/>
<p><font color = blue size = 4>Query in SQL:</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Select</span> A1, A2,...,Am <span class="keyword">from</span> R <span class="keyword">where</span> Condition;</span><br></pre></td></tr></table></figure>
<br/>
<p><font color = blue size = 4>2. Query in relational algebra :</font></p>
<blockquote>
<p><font color = green size = 4>((R$_1$ $\times$ R$_2$$\times$…$\times$R$_n$) where Condition) [A$_1$, A$_2$, …, A$_m$]</font></p>
</blockquote>
<br/>
<p><font color = blue size = 4>Query in SQL:</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Select</span> A1, A2,...,Am <span class="keyword">from</span> R1, R2,...,Rn <span class="keyword">where</span> Condition;</span><br></pre></td></tr></table></figure>
<br/>
<p><font color = blue size = 4>3. Query in relational algebra :</font></p>
<blockquote>
<p><font color = green size = 4>Head® = {A$_1$,…,A$_n$,B$_1$,…,B$_k$}, Head(S) = {B$_1$,…,B$_k$, C$_1$,…,C$_m$}</font></p>
<p><font color = green size = 4>((R$\infty$S) where Condition) [A$_1$, A$_2$, …, A$_m$]</font></p>
</blockquote>
<br/>
<p><font color = blue size = 4>Query in SQL:</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Select</span> A1, A2,...,Am <span class="keyword">from</span> R, S <span class="keyword">where</span> Condition <span class="keyword">and</span> R.B1 = S.B1 <span class="keyword">and</span> R2.B2 = S.B2 and...and R.Bk = S.Bk;</span><br></pre></td></tr></table></figure>
<br/>
<p><font color = blue size = 4>4. Query in relational algebra :</font></p>
<blockquote>
<p><font color = green size = 4>(R $\infty$$_{Condition}$S) [A$_1$, A$_2$, …, A$_m$]</font></p>
</blockquote>
<br/>
<p><font color = blue size = 4>Query in SQL:</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Select</span> A1, A2,...,Am <span class="keyword">from</span> R,S <span class="keyword">where</span> Condition;</span><br></pre></td></tr></table></figure>
<br/>
<p><font color = blue size = 4>5. Query in relational algebra :</font></p>
<blockquote>
<p><font color = green size = 4>(AGENTS where city = ‘New York’) [aid, aname]</font></p>
</blockquote>
<br/>
<p><font color = blue size = 4>Query in SQL:</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Select</span> aid, aname <span class="keyword">from</span> agents <span class="keyword">where</span> city = <span class="string">'New York'</span>;</span><br></pre></td></tr></table></figure>
<br/>
<p><font color = blue size = 4>6. Query in relational algebra :</font></p>
<blockquote>
<p><font color = green size = 4>(CUSTOMERS) [cid, cname, city, discnt]</font></p>
</blockquote>
<br/>
<p><font color = blue size = 4>Query in SQL:</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Select</span> * <span class="keyword">from</span> Customers;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Select</span> cid, cname, city, discnt <span class="keyword">from</span> Customers;</span><br></pre></td></tr></table></figure>
<br/>
<p><font color = blue size = 4>7. Query in relational algebra :</font></p>
<blockquote>
<p><font color = green size = 4>((C[cid, cname] $\infty$O)$\infty$A) [cname, aname]; </font></p>
<p><font color = green size = 4>((C $\infty$O $\infty$A) where C.cid = O.cid and O.aid = A.aid) [cname, aname]</font></p>
</blockquote>
<br/>
<p><font color = blue size = 4>Query in SQL:</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Select</span> <span class="keyword">distinct</span> cname, aname <span class="keyword">from</span> customers, orders, agents <span class="keyword">where</span> customers.cid = orders.cid <span class="keyword">and</span> orders.aid = agents.aid;</span><br></pre></td></tr></table></figure>
<br/>
<h4 id="2-Some-Examples">2. Some Examples</h4>
<p><font color = blue size = 4>1. Display all values of customers in table CUSTOMERS.</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  cid, cname, city, discnt  <span class="keyword">FROM</span>  customers ;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  *  <span class="keyword">FROM</span>  customers ;</span><br></pre></td></tr></table></figure>
<br/>
<p><font color = blue size = 4>2. Retrieve all (cname, aname) pairs where the customer places an order through the agent.</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  <span class="keyword">distinct</span>  cname, aname</span><br><span class="line"><span class="keyword">FROM</span>      customers, orders, agents</span><br><span class="line"><span class="keyword">WHERE</span>   customers.cid=orders.cid <span class="keyword">and</span> orders.aid=agents.aid ;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  <span class="keyword">distinct</span>  cname, aname</span><br><span class="line"><span class="keyword">FROM</span>   customers c, orders  o, agents  a  <span class="comment">-- (has alias)</span></span><br><span class="line"><span class="keyword">WHERE</span>   c.cid=o.cid  <span class="keyword">and</span>  o.aid=a.aid ;</span><br></pre></td></tr></table></figure>
<br/>
<p><font color = blue size = 4>3. Get the names of customers who order at least one product priced at $0.50.</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  cname</span><br><span class="line"><span class="keyword">FROM</span>  products  p, orders  o, customers  c</span><br><span class="line"><span class="keyword">WHERE</span>  price=<span class="number">0.50</span> <span class="keyword">and</span> p.pid=o.pid <span class="keyword">and</span></span><br><span class="line">o.cid=c.cid ;</span><br></pre></td></tr></table></figure>
<br/>
<p><font color = blue size = 4>4. Retrieve customers who place orders only through agent a03.</font></p>
<blockquote>
<p><font color = green>O [cid] - (O where aid &lt;&gt; ‘a03’) [cid]</font></p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  o1.cid</span><br><span class="line"><span class="keyword">FROM</span>    orders  o1</span><br><span class="line"><span class="keyword">WHERE</span>  o1.cid  <span class="keyword">NOT</span> <span class="keyword">IN</span>  (</span><br><span class="line">	<span class="keyword">SELECT</span> o2.cid</span><br><span class="line">	<span class="keyword">FROM</span>  orders  o2</span><br><span class="line">	<span class="keyword">WHERE</span>  o2.aid &lt;&gt; ‘a03’  ) ;</span><br></pre></td></tr></table></figure>
<br/>
<p><font color = blue size = 4>5. List all pairs of customer cids based in the same city.</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Select</span> c1.cid, c2.cid <span class="keyword">from</span> customers c1, customers c2 <span class="keyword">where</span> c1.city = c2.city <span class="keyword">and</span> c1.cid &lt; c2.cid;</span><br></pre></td></tr></table></figure>
<br/>
<h4 id="3-Table-and-column-alias">3. Table and column alias</h4>
<p><font color = blue size = 4>Table alias in FROM clause</font></p>
<blockquote>
<p><font color = green size = 4>方法1</font>：table_name  as  alias_name</p>
<p><font color = green size = 4>方法2：</font>table_name   alias_name</p>
</blockquote>
<p><font color = blue size = 4>column alias in SELECT clause</font></p>
<blockquote>
<p>column_name  as  alias_name</p>
</blockquote>
<br/>
<h4 id="4-ALL-DISTINCT">4. ALL  |  DISTINCT</h4>
<blockquote>
<p>SELECT  aid, pid  FROM  orders ;</p>
<p>SELECT  <span style="background: linear-gradient(to right, #f2994a, #f2c94c);">distinct</span>  aid, pid  FROM  orders ;</p>
</blockquote>
<br/>
<p><font color = blue size = 4>Find pids of products ordered by at least two customers.</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  <span class="keyword">distinct</span>  pid</span><br><span class="line"><span class="keyword">FROM</span>   orders  x1,  orders  x2</span><br><span class="line"><span class="keyword">WHERE</span>   x1.pid = x2.pid <span class="keyword">and</span> x1.cid &lt; x2.cid ;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  <span class="keyword">distinct</span>  pid</span><br><span class="line"><span class="keyword">FROM</span>   orders  x1,  orders  x2</span><br><span class="line"><span class="keyword">WHERE</span>   x1.pid = x2.pid <span class="keyword">and</span> x1.cid &lt;&gt; x2.cid ;</span><br></pre></td></tr></table></figure>
<br/>
<hr>
<h3 id="三-Subqueries">三. Subqueries</h3>
<h4 id="1-The-IN-Predicate">1. The IN Predicate</h4>
<p><font color = blue size = 4>1. Retrieve cids of customers who place orders with agents in Duluth or Dallas.</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span>  <span class="keyword">distinct</span>  cid</span><br><span class="line"><span class="keyword">from</span>    orders  o, agents  a</span><br><span class="line"><span class="keyword">where</span>  a.aid=o.aid  <span class="keyword">and</span></span><br><span class="line">(a.city=‘Duluth’ <span class="keyword">or</span> a.city=‘Dallas’);       <span class="comment">-- Slow</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span>  cid</span><br><span class="line"><span class="keyword">from</span>  orders</span><br><span class="line"><span class="keyword">where</span>   aid <span class="keyword">IN</span> (</span><br><span class="line"><span class="keyword">select</span>  aid</span><br><span class="line"><span class="keyword">from</span>  agents</span><br><span class="line"><span class="keyword">where</span>  city= ‘Duluth’  <span class="keyword">or</span>  city=‘Dallas’ );      <span class="comment">-- Fast</span></span><br></pre></td></tr></table></figure>
<br/>
<p><font color =blue size = 4>2. Get all information concerning agents based in Duluth or Dallas.</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  *</span><br><span class="line"><span class="keyword">FROM</span>  agents</span><br><span class="line"><span class="keyword">WHERE</span>  city <span class="keyword">IN</span> &#123; ‘Duluth’, ‘Dallas’ &#125; ;</span><br></pre></td></tr></table></figure>
<br/>
<p><font color = blue size = 4>3. Get the names and discounts of all customers who place orders through agents in Duluth or Dallas.</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  cname,  discnt</span><br><span class="line"><span class="keyword">FROM</span>      customers</span><br><span class="line"><span class="keyword">WHERE</span>  cid  <span class="keyword">IN</span> (</span><br><span class="line"><span class="keyword">SELECT</span>  o.cid</span><br><span class="line"><span class="keyword">FROM</span>      orders  o</span><br><span class="line"><span class="keyword">WHERE</span>  o.aid  <span class="keyword">IN</span> (</span><br><span class="line"><span class="keyword">SELECT</span>  a.aid</span><br><span class="line"><span class="keyword">FROM</span>      agents  a</span><br><span class="line"><span class="keyword">WHERE</span>  a.city <span class="keyword">IN</span> (‘Duluth’, ‘Dallas’))) ;</span><br></pre></td></tr></table></figure>
<br/>
<p><font color = blue size = 4>4. Find the names of customers who order product p05.</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Select</span> <span class="keyword">distinct</span> cname </span><br><span class="line"><span class="keyword">from</span> customers c, orders o </span><br><span class="line"><span class="keyword">where</span> c.cid = o.cid <span class="keyword">and</span> o.pid = <span class="string">'p05'</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Select</span> <span class="keyword">distinct</span> cname </span><br><span class="line"><span class="keyword">from</span> customers c </span><br><span class="line"><span class="keyword">where</span> <span class="string">'p05'</span> <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">Select</span> pid <span class="keyword">from</span> orders o</span><br><span class="line">	<span class="keyword">where</span> o.cid = c.id);</span><br></pre></td></tr></table></figure>
<br/>
<p><font color = blue size = 4>5. Get cids of customers who place an order through at least one agent who places an order for product p03</font></p>
<blockquote>
<p><font color = green size = 4>T~1~ := (O where pid = ‘p03’) [aid]</font></p>
<p><font color = green size = 4>T~2~ := (T~1~ $\infty $ O) [cid]</font></p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> o2.cid <span class="keyword">from</span> orders o1, orders o2</span><br><span class="line"><span class="keyword">where</span> o1.pid = <span class="string">'p03'</span> <span class="keyword">and</span> o1.aid = o2.pid;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> o2.cid <span class="keyword">from</span> orders o2 <span class="keyword">where</span> o2.aid <span class="keyword">IN</span></span><br><span class="line">(<span class="keyword">select</span> o1.aid <span class="keyword">from</span> orders o1 <span class="keyword">where</span> o1.pid = <span class="string">'p03'</span>);</span><br></pre></td></tr></table></figure>
<br/>
<p><font color = blue size = 4>6. Get cids of all customers who <span style="background: linear-gradient(to right, #f2994a, #f2c94c);">have the same discount</span> as any customer in Dallas or Boston.</font></p>
<blockquote>
<p><font color = green size = 4>T~1~ := (C where city = ‘Dallas’ or city = ‘Boston’) [discnt]</font></p>
<p><font color = green size = 4>T~2~ := (T~1~ $\infty $ C) [cid]</font></p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> c2.cid <span class="keyword">from</span> customers c1, customers c2</span><br><span class="line"><span class="keyword">where</span> (c1.city = <span class="string">'Dallas'</span> <span class="keyword">or</span> c1.city = <span class="string">'Boston'</span>) <span class="keyword">and</span> c1.discnt = c2.discnt;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> c2.cid <span class="keyword">from</span> customers c2 <span class="keyword">where</span> c2.discnt <span class="keyword">IN</span></span><br><span class="line">(<span class="keyword">select</span> c1.discnt <span class="keyword">from</span> customers c1 <span class="keyword">where</span> c1.city = <span class="string">'Dallas'</span> <span class="keyword">or</span> c1.city = <span class="string">'Boston'</span>);</span><br></pre></td></tr></table></figure>
<br/>
<p><font color = blue size = 4>7. Get pids of products not ordered by any customer living in a city whose name begin with the letter D.</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> p.pid <span class="keyword">from</span> products p <span class="keyword">where</span> p.pid <span class="keyword">NOT</span> <span class="keyword">IN</span></span><br><span class="line">(<span class="keyword">select</span> o.pid <span class="keyword">from</span> orders o, customers c <span class="keyword">where</span></span><br><span class="line">o.cid = c.cid <span class="keyword">and</span> c.city <span class="keyword">LIKE</span> <span class="string">'D%'</span>);</span><br></pre></td></tr></table></figure>
<br/>
<blockquote>
<p><font color = red size = 5>注意：IN 操作符允许您在 WHERE 子句中规定多个值。</font></p>
</blockquote>
<br/>
<p><font color = blue size = 4>4. Find ordno values for all orders placed by customers in Duluth through agents in New York.</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  ordno</span><br><span class="line"><span class="keyword">FROM</span>  orders</span><br><span class="line"><span class="keyword">WHERE</span>  (cid, aid)  <span class="keyword">IN</span>		<span class="comment">-- IN的多组值的合并判断</span></span><br><span class="line">(<span class="keyword">select</span>  cid, aid</span><br><span class="line"><span class="keyword">from</span>    customers  c,  agents  a</span><br><span class="line"><span class="keyword">where</span>   c.city=‘Duluth’ <span class="keyword">and</span> a.city=‘<span class="keyword">New</span> York’);</span><br></pre></td></tr></table></figure>
<br/>
<h4 id="2-The-Quantified-Comparison-Predicate">2. The Quantified Comparison Predicate</h4>
<p><font color = blue size = 5>expr $\Theta$ { SOME | ANY | ALL } ( subquery )</font></p>
<blockquote>
<p><font color = green size = 4>IN is =SOME，=ANY</font></p>
<p><font color = green size = 4>NOT IN is &lt;&gt;ALL</font></p>
<p><font color = red size = 4>注意：</font><font color = green size = 4>主要用于某一类属性值的比较；或用于替代IN；或求某一类属性最大/最小时的其他属性的值</font></p>
</blockquote>
<br/>
<p><font color = blue size = 4>1. Find aid values of agents with a <span style="background: linear-gradient(to right, #f2994a, #f2c94c);">minimum percent</span> commission.</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  aid</span><br><span class="line"><span class="keyword">FROM</span>  agents</span><br><span class="line"><span class="keyword">WHERE</span>  <span class="keyword">percent</span> &lt;= <span class="keyword">ALL</span> (</span><br><span class="line">		<span class="keyword">select</span> <span class="keyword">percent</span> <span class="keyword">from</span> agents  ) ;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Select</span> aid</span><br><span class="line"><span class="keyword">From</span> agents</span><br><span class="line"><span class="keyword">Where</span> <span class="keyword">percent</span> <span class="keyword">IN</span> (</span><br><span class="line">	<span class="keyword">Select</span> <span class="keyword">min</span>(<span class="keyword">percent</span>) <span class="keyword">from</span> agents );</span><br></pre></td></tr></table></figure>
<br/>
<p><font color = blue size = 4>2. Find all customers who have the same discount as that of any of the customers in Dallas or Boston.</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  cid,  cname</span><br><span class="line"><span class="keyword">FROM</span>   customers</span><br><span class="line"><span class="keyword">WHERE</span>  discnt = <span class="keyword">SOME</span> (</span><br><span class="line">		<span class="keyword">select</span>  discnt</span><br><span class="line">		<span class="keyword">from</span>   customers</span><br><span class="line">		<span class="keyword">where</span>  city=‘Dallas’  <span class="keyword">or</span>  city=‘Boston’  ) ;</span><br></pre></td></tr></table></figure>
<br/>
<p><font color = blue size = 4>3. Get cid values of customers with discnt smaller than those of any customers who live in Duluth.</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  cid,  cname</span><br><span class="line"><span class="keyword">FROM</span>   customers</span><br><span class="line"><span class="keyword">WHERE</span>  discnt &lt; <span class="keyword">ALL</span>  (</span><br><span class="line">		<span class="keyword">select</span>  discnt</span><br><span class="line">		<span class="keyword">from</span>   customers</span><br><span class="line">		<span class="keyword">where</span>  city=‘Duluth’  ) ;</span><br></pre></td></tr></table></figure>
<br/>
<p><font color = blue size = 4>4. Find cid values of customers with discnt smaller than a customer who lives in Duluth.</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  cid</span><br><span class="line"><span class="keyword">FROM</span>   customers</span><br><span class="line"><span class="keyword">WHERE</span>  discnt &lt; <span class="keyword">SOME</span> ( </span><br><span class="line">  		<span class="keyword">SELECT</span>  discnt</span><br><span class="line">		<span class="keyword">FROM</span>  customers</span><br><span class="line">		<span class="keyword">WHERE</span>  city = ‘Duluth’ ) ;</span><br></pre></td></tr></table></figure>
<br/>
<blockquote>
<p><font color = red size = 5>注意：</font></p>
<p><font color = green size = 4>1) &gt; ALL 父查询中的结果集大于子查询中每一个结果集中的值,则为真</font></p>
<p><font color = green size = 4>2) &gt; ANY, SOME 父查询中的结果集大于子查询中任意一个结果集中的值,则为真</font></p>
<p><font color = green size = 4>3) = ANY 与子查询 IN相同</font></p>
<p><font color = green size = 4>4) &lt;&gt; ANY 与 NOT IN 父查询中的结果集不等于子查询中的a或者b或者c,则为真 </font></p>
</blockquote>
<br/>
<h4 id="3-The-EXISTS-Predicate">3. The EXISTS Predicate</h4>
<p><font color = red Size = 5>实例：</font></p>
<p><font color = green size = 4>exists,not exists的使用方法示例，需要的朋友可以参考下。</font></p>
<p><font color = red size = 4>学生表：</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_student</span><br><span class="line">(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">number</span>(<span class="number">8</span>) primary <span class="keyword">key</span>,</span><br><span class="line"><span class="keyword">name</span> <span class="built_in">varchar2</span>(<span class="number">10</span>),</span><br><span class="line">deptment <span class="built_in">number</span>(<span class="number">8</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><font color = red size = 4>选课表：</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> select_course</span><br><span class="line">(</span><br><span class="line"><span class="keyword">ID</span>         <span class="built_in">NUMBER</span>(<span class="number">8</span>) primary <span class="keyword">key</span>,</span><br><span class="line">STUDENT_ID <span class="built_in">NUMBER</span>(<span class="number">8</span>) <span class="keyword">foreign</span> <span class="keyword">key</span> (COURSE_ID) <span class="keyword">references</span> course(<span class="keyword">ID</span>),</span><br><span class="line">COURSE_ID  <span class="built_in">NUMBER</span>(<span class="number">8</span>) <span class="keyword">foreign</span> <span class="keyword">key</span> (STUDENT_ID) <span class="keyword">references</span> student(<span class="keyword">ID</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><font color = red size = 4>课程表：</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> COURSE</span><br><span class="line">(</span><br><span class="line"><span class="keyword">ID</span>     <span class="built_in">NUMBER</span>(<span class="number">8</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">C_NAME <span class="built_in">VARCHAR2</span>(<span class="number">20</span>),</span><br><span class="line">C_NO   <span class="built_in">VARCHAR2</span>(<span class="number">10</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<br/>
<p><font color = blue size = 4>1.查询选修了所有课程的学生id、name:（即不存在这样一个学生，他有一门课程没有选。）</font></p>
<blockquote>
<p><font color = red>分析：</font></p>
<p>如果有一门课没有选，则此时</p>
<p>(1)select * from select_course sc，t_student ts，course c  where sc.student_id=<a href="http://ts.id" target="_blank" rel="noopener">ts.id</a> and sc.course_id=c.id存在null，<br>
这说明(2)select * from course c 的查询结果中确实有记录不存在(1查询中)，查询结果返回没有选的课程，<br>
此时select * from t_student ts 后的not exists 判断结果为false，不执行查询。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>, <span class="keyword">name</span> <span class="keyword">from</span> t_student ts <span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span></span><br><span class="line">(<span class="keyword">select</span> * <span class="keyword">from</span> course c <span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span></span><br><span class="line">(<span class="keyword">select</span> * <span class="keyword">from</span> select_course sc <span class="keyword">where</span> sc.student_id=ts.id <span class="keyword">and</span> sc.course_id=c.id));</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>, <span class="keyword">name</span> <span class="keyword">from</span> t_student ts, </span><br><span class="line">(<span class="keyword">select</span> studentid <span class="keyword">from</span> select_course sc <span class="keyword">where</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span></span><br><span class="line">(<span class="keyword">select</span> * <span class="keyword">from</span> course c <span class="keyword">where</span> c.id = sc.id)) T1 </span><br><span class="line"><span class="keyword">where</span> ts.id = T1.student_id;</span><br></pre></td></tr></table></figure>
<br/>
<p><font color = blue size = 4>2.查询没有选择所有课程的学生，即没有全选的学生。（存在这样的一个学生，他至少有一门课没有选）</font></p>
<blockquote>
<p><font color = red>分析：</font></p>
<p>只要有一个门没有选，即</p>
<p>select * from select_course sc，t_student ts，courses c where student_id=t_student.id and courses_id=<a href="http://courses.id" target="_blank" rel="noopener">courses.id</a> 有一条为空，</p>
<p>即not exists null 为true,此时select * from courses有查询结果（<a href="http://xn--idcourses-rl6noey88nng8ai15bi81d.id" target="_blank" rel="noopener">id为子查询中的courses.id</a> ），<br>
因此select id,name from t_student 将执行查询（id为子查询中t_student.id ）。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,<span class="keyword">name</span> <span class="keyword">from</span> t_student <span class="keyword">where</span> <span class="keyword">exists</span></span><br><span class="line">(<span class="keyword">select</span> * <span class="keyword">from</span> course <span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span></span><br><span class="line">(<span class="keyword">select</span> * <span class="keyword">from</span> select_course sc <span class="keyword">where</span> student_id=t_student.id <span class="keyword">and</span> course_id=course.id));</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">name</span> <span class="keyword">from</span> t_student <span class="keyword">where</span> (<span class="keyword">id</span> ,<span class="keyword">name</span>) <span class="keyword">NOT</span> <span class="keyword">IN</span> </span><br><span class="line">(<span class="keyword">select</span> <span class="keyword">id</span>, <span class="keyword">name</span> <span class="keyword">from</span> t_student ts, </span><br><span class="line">(<span class="keyword">select</span> studentid <span class="keyword">from</span> select_course sc <span class="keyword">where</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span></span><br><span class="line">(<span class="keyword">select</span> * <span class="keyword">from</span> course c <span class="keyword">where</span> c.id = sc.id)) T1 </span><br><span class="line"><span class="keyword">where</span> ts.id = T1.student_id) T2;</span><br></pre></td></tr></table></figure>
<br/>
<p><font color = blue size = 4>3.查询一门课也没有选的学生。（不存这样的一个学生，他至少选修一门课程）</font></p>
<blockquote>
<p><font color = red>分析：</font></p>
<p>如果他选修了一门select * from course结果集不为空，not exists 判断结果为false;<br>
select id,name from t_student 不执行查询。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,<span class="keyword">name</span> <span class="keyword">from</span> t_student <span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span></span><br><span class="line">(<span class="keyword">select</span> * <span class="keyword">from</span> course <span class="keyword">where</span> <span class="keyword">exists</span></span><br><span class="line">(<span class="keyword">select</span> * <span class="keyword">from</span> select_course sc <span class="keyword">where</span> student_id=t_student.id <span class="keyword">and</span> course_id=course.id));</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>, <span class="keyword">name</span> <span class="keyword">from</span> t_student <span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">NOT</span> <span class="keyword">IN</span></span><br><span class="line">(<span class="keyword">select</span> student_id <span class="keyword">from</span> select_course );</span><br></pre></td></tr></table></figure>
<br/>
<p><font color = blue size = 4>4.查询至少选修了一门课程的学生。（存在这样的一个学生，他至少选修一门课程）</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,<span class="keyword">name</span> <span class="keyword">from</span> t_student <span class="keyword">where</span> <span class="keyword">exists</span></span><br><span class="line">(<span class="keyword">select</span> * <span class="keyword">from</span> course <span class="keyword">where</span>  <span class="keyword">exists</span></span><br><span class="line">(<span class="keyword">select</span> * <span class="keyword">from</span> select_course sc <span class="keyword">where</span> student_id=t_student.id <span class="keyword">and</span> course_id=course.id));</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>, <span class="keyword">name</span> <span class="keyword">from</span> t_student <span class="keyword">where</span> (<span class="keyword">id</span>, <span class="keyword">name</span>) <span class="keyword">NOT</span> <span class="keyword">IN</span></span><br><span class="line">(<span class="keyword">select</span> <span class="keyword">id</span>, <span class="keyword">name</span> <span class="keyword">from</span> t_student <span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">NOT</span> <span class="keyword">IN</span></span><br><span class="line">(<span class="keyword">select</span> studentid <span class="keyword">from</span> select_course));</span><br></pre></td></tr></table></figure>
<br/>
<blockquote>
<p><font color = red>注意：</font><font color = green>在插入记录前，需要检查这条记录是否已经存在，只有当记录不存在时才执行插入操作，可以通过使用 EXISTS 条件句防止插入重复记录。</font></p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> TableIn (ANAME,ASEX) </span><br><span class="line"><span class="keyword">SELECT</span> top <span class="number">1</span> <span class="string">'张三'</span>, <span class="string">'男'</span> <span class="keyword">FROM</span> TableIn</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">not</span> <span class="keyword">exists</span> (<span class="keyword">select</span> * <span class="keyword">from</span> TableIn <span class="keyword">where</span> TableIn.AID = <span class="number">7</span>);</span><br></pre></td></tr></table></figure>
<br/>
<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg .tg-9wq8{border-color:inherit;text-align:center;vertical-align:middle}
.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}
.tg .tg-nrix{text-align:center;vertical-align:middle}
.tg .tg-0lax{text-align:left;vertical-align:top}
</style>
<table class="tg">
  <tr>
    <th class="tg-0pky"><span style="font-weight:700">Relational  Algebra</span></th>
    <th class="tg-0pky"><span style="font-weight:700">SQL  Predicate</span></th>
  </tr>
  <tr>
    <td class="tg-nrix" rowspan="3">natural join</td>
    <td class="tg-0lax">IN</td>
  </tr>
  <tr>
    <td class="tg-0lax">=SOME</td>
  </tr>
  <tr>
    <td class="tg-0lax">EXISTS</td>
  </tr>
  <tr>
    <td class="tg-9wq8" rowspan="3">difference</td>
    <td class="tg-0pky">NOT IN</td>
  </tr>
  <tr>
    <td class="tg-0pky">&lt;&gt;ALL</td>
  </tr>
  <tr>
    <td class="tg-0pky">NOT EXISTS</td>
  </tr>
</table>
<br/>
<p><font color = blue size = 4>1. Retrieve all customer names where the customer places an order through agent a05.</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Select</span>  <span class="keyword">distinct</span>  c.cname</span><br><span class="line"><span class="keyword">From</span>  customers c</span><br><span class="line"><span class="keyword">Where</span>  <span class="keyword">EXISTS</span>  (</span><br><span class="line">		<span class="keyword">Select</span></span><br><span class="line">		<span class="keyword">From</span>  orders x</span><br><span class="line">		<span class="keyword">Where</span>  c.cid=x.cid  <span class="keyword">and</span>  x.aid=‘a05’ );</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> c.cname </span><br><span class="line"><span class="keyword">from</span> customers c, <span class="keyword">order</span> o <span class="keyword">where</span> o.cid = c.cid <span class="keyword">and</span> o.aid = <span class="string">'a05'</span>;</span><br></pre></td></tr></table></figure>
<br/>
<p><font color = blue size = 4>2. Find all customer names where the customer does not place an order through agent a05.</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  cname</span><br><span class="line"><span class="keyword">FROM</span>    customers c</span><br><span class="line"><span class="keyword">WHERE</span>   cid  <span class="keyword">NOT</span> <span class="keyword">IN</span> ( </span><br><span class="line">		<span class="keyword">SELECT</span>  o.cid</span><br><span class="line">		<span class="keyword">FROM</span>  orders  o</span><br><span class="line">		<span class="keyword">WHERE</span>  o.aid = ‘a05’ ) ;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  cname</span><br><span class="line"><span class="keyword">FROM</span>    customers  c</span><br><span class="line"><span class="keyword">WHERE</span>   <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (</span><br><span class="line">		<span class="keyword">SELECT</span>  *</span><br><span class="line">		<span class="keyword">FROM</span>   orders  o</span><br><span class="line">		<span class="keyword">WHERE</span>   o.cid = c.cid  <span class="keyword">and</span>  o.aid = ‘a05’ ) ;</span><br></pre></td></tr></table></figure>
<br/>
<p><font color = blue size = 4>3. Find cids of all customers who don’t place any order through agent a03.</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  cid</span><br><span class="line"><span class="keyword">FROM</span>    customers</span><br><span class="line"><span class="keyword">WHERE</span>   cid  <span class="keyword">NOT</span> <span class="keyword">IN</span> ( </span><br><span class="line">        <span class="keyword">SELECT</span>  o.cid</span><br><span class="line">		<span class="keyword">FROM</span>  orders  o</span><br><span class="line">		<span class="keyword">WHERE</span>  o.aid = ‘a03’ ) ;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  cid</span><br><span class="line"><span class="keyword">FROM</span>    customers  c</span><br><span class="line"><span class="keyword">WHERE</span>   <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (</span><br><span class="line">		<span class="keyword">SELECT</span>  *</span><br><span class="line">		<span class="keyword">FROM</span>  orders  o</span><br><span class="line">		<span class="keyword">WHERE</span>   o.cid = c.cid  <span class="keyword">and</span>  o.aid = ‘a03’ );</span><br></pre></td></tr></table></figure>
<br/>
<blockquote>
<p><font color = red size = 5>注意：</font></p>
<p><font color = green size = 4>EXISTS用于检查子查询是否至少会返回一行数据，该子查询实际上并不返回任何数据，而是返回值True或False</font></p>
</blockquote>
<br/>
<p><font color = blue size = 5>not in和not exists的区别：</font></p>
<p><font color = green>1. not in 只有当子查询中，select 关键字后的字段有not null约束或者有这种暗示时用not in,另外如果主查询中表大，子查询中的表小但是记录多，则应当使用not in,</font></p>
<p><font color = blue size = 4>例如:查询那些班级中没有学生的：</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">class</span> <span class="keyword">where</span> cid <span class="keyword">not</span> <span class="keyword">in</span> </span><br><span class="line">(<span class="keyword">select</span> <span class="keyword">distinct</span> cid <span class="keyword">from</span> stu);</span><br></pre></td></tr></table></figure>
<br/>
<p><font color = green>2. 当表中cid存在null值，not in 不对空值进行处理</font></p>
<p><span style="background: linear-gradient(to right, #f2994a, #f2c94c);">解决:</span></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">class</span> <span class="keyword">where</span> cid <span class="keyword">not</span> <span class="keyword">in</span></span><br><span class="line">(<span class="keyword">select</span> <span class="keyword">distinct</span> cid <span class="keyword">from</span> stu <span class="keyword">where</span> cid <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<br/>
<blockquote>
<p><font color = green>not in的执行顺序是：是在表中一条记录一条记录的查询(查询每条记录）符合要求的就返回结果集，不符合的就继续查询下一条记录，直到把表中的记录查询完。也就是说为了证明找不到，所以只能查询全部记录才能证明，并没有用到索引。<br>
not exists：如果主查询表中记录少，子查询表中记录多，并有索引。</font></p>
</blockquote>
<p><font color = blue size = 4>例如:查询那些班级中没有学生的</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> class2</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span></span><br><span class="line">(<span class="keyword">select</span> * <span class="keyword">from</span> stu1 <span class="keyword">where</span> stu1.cid =class2.cid)</span><br></pre></td></tr></table></figure>
<br/>
<blockquote>
<p><font color = green>not exists的执行顺序是：在表中查询，是根据索引查询的，如果存在就返回true，如果不存在就返回false，不会每条记录都去查询。<br>
之所以要多用not exists，而不用not in，也就是not exists查询的效率远远高与not in查询的效率。</font></p>
</blockquote>
<br/>
<h4 id="4-The-LIKE-Predicate">4. The LIKE Predicate</h4>
<p><img data-src="http://image.zxkidea.top/1550455574345.png" alt="zxk"></p>
<br/>
<p><font color = blue size = 4>1. Get pids of products not ordered by any customer living in a city whose name begin with the letter D.</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  p.pid</span><br><span class="line"><span class="keyword">FROM</span>    products  p</span><br><span class="line"><span class="keyword">WHERE</span>   p.pid  <span class="keyword">NOT</span>  <span class="keyword">IN</span>  (</span><br><span class="line">	<span class="keyword">SELECT</span>  o.pid</span><br><span class="line">	<span class="keyword">FROM</span>    orders  o,  customers  c</span><br><span class="line">	<span class="keyword">WHERE</span>   o.cid = c.cid  <span class="keyword">and</span>  c.city <span class="keyword">LIKE</span> ‘D%’  ) ;</span><br></pre></td></tr></table></figure>
<br/>
<p><font color = blue size = 4>2. Retrieve cid values of customers whose cname <span style="background: linear-gradient(to right, #f2994a, #f2c94c);">does not have a third letter</span> equal to ‘%’.</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Select</span>  cid</span><br><span class="line"><span class="keyword">From</span>  customers</span><br><span class="line"><span class="keyword">Where</span>  cname  <span class="keyword">NOT</span> <span class="keyword">LIKE</span>  ‘_ _ \ % %’</span><br><span class="line">		ESCAPE  ‘ \ ’ ;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><font color = red size = 4>注意：% 原为通配符，指定用 ’ \ '符号来说明跟在其后面的通配符字符为普通字符。</font></p>
</blockquote>
<br/>
<p><font color = blue size = 4>3. Retrieve cid values of customers whose cname <span style="background: linear-gradient(to right, #f2994a, #f2c94c);">begins “Tip_”</span> and has an arbitrary number of characters following.</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Select</span>  cid</span><br><span class="line"><span class="keyword">From</span>  customers</span><br><span class="line"><span class="keyword">Where</span>  cname  <span class="keyword">LIKE</span>  ‘Tip\_%’</span><br><span class="line">ESCAPE  <span class="string">'\'</span> ;</span><br></pre></td></tr></table></figure>
<br/>
<p><font color = blue size = 4>4. Retrieve cid values of customers whose cname <span style="background: linear-gradient(to right, #f2994a, #f2c94c);">starts with the sequence “ab\”</span>.</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Select</span>  *</span><br><span class="line"><span class="keyword">From</span>  customers</span><br><span class="line"><span class="keyword">Where</span>  cname  <span class="keyword">LIKE</span>  ‘ab\ \%’  ESCAPE  ‘\’ ;</span><br></pre></td></tr></table></figure>
<p><span style="background: linear-gradient(to right, #f2994a, #f2c94c);"><font color = green size = 4>( 连续的两个转义指示字符表示 ‘转义指示符 ’自己)</font></span></p>
<br/>
<blockquote>
<p><font color = red size = 5>注意：</font></p>
<p><font color = green size = 4>‘A_Z’: 所有以 ‘A’ 起头，另一个任何值的字原，且以 ‘Z’ 为结尾的字串。</font></p>
<p><font color = green size = 4>‘ABC%’: 所有以 ‘ABC’ 起头的字串。</font></p>
<p><font color = green size = 4>‘%XYZ’: 所有以 ‘XYZ’ 结尾的字串。</font></p>
<p><font color = green size = 4>‘%AN%’: 所有含有 ‘AN’ 这个套式的字串。</font></p>
<p><font color = green size = 4>使用   ESCAPE   关键字定义转义符。</font></p>
<p><font color = green size = 4>WHERE   ColumnA   LIKE   ‘%5/%%’   ESCAPE   ‘/’   即 ‘/’为转义字符，第二个‘%’为普通字符，第一、第三个为通配符。</font></p>
</blockquote>
<br/>
<h4 id="5-The-NULL-Predicate">5. The NULL Predicate</h4>
<blockquote>
<p>NULL表示不可知不确定，NULL不与任何值相等（包括其本身）</p>
<p>IS NULL 判断某个字符是否为空，并不代表空字符或者是0</p>
<p>=NULL 是判断某个值是否等于NULL</p>
<p>总之，要判断一个数是否等于NULL只能用 IS NULL 或者 IS NOT NULL 来判断</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 选择非空列</span><br><span class="line">select * from tableName where colName IS NOT NULL;</span><br><span class="line"></span><br><span class="line">-- 删除列为NULL的行</span><br><span class="line">delete from tableName where colName IS NULL;</span><br></pre></td></tr></table></figure>
<br>
<h4 id="6-Example-of-Subqueries">6.Example  of Subqueries</h4>
<p><font color = blue size = 4>1. Retrieve all customer names where the customer places an order through agent a05.</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  <span class="keyword">distinct</span>  cname</span><br><span class="line"><span class="keyword">FROM</span>    customers c, orders o</span><br><span class="line"><span class="keyword">WHERE</span>   c.cid = o.cid  <span class="keyword">and</span>  o.aid = ‘a05’ ;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  <span class="keyword">distinct</span>  cname</span><br><span class="line"><span class="keyword">FROM</span>    customers</span><br><span class="line"><span class="keyword">WHERE</span>   cid   <span class="keyword">IN</span></span><br><span class="line">(<span class="keyword">SELECT</span> cid  <span class="keyword">FROM</span> orders  <span class="keyword">WHERE</span> aid=‘a05’) ;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  <span class="keyword">distinct</span>  cname</span><br><span class="line"><span class="keyword">FROM</span>    customers  c</span><br><span class="line"><span class="keyword">WHERE</span>   <span class="keyword">EXISTS</span> </span><br><span class="line">(<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> orders o <span class="keyword">WHERE</span>  o.cid=c.cid <span class="keyword">and</span> o.aid=‘a05’) ;</span><br></pre></td></tr></table></figure>
<br/>
<p><font color = blue size = 4>2. Get cids of customers who order <span style="background: linear-gradient(to right, #f2994a, #f2c94c);">both</span> products p01 and p07.</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  o1.cid  <span class="keyword">FROM</span>  orders  o1, orders  o2</span><br><span class="line"><span class="keyword">WHERE</span>  o1.cid=o2.cid  <span class="keyword">and</span></span><br><span class="line">o1.pid=‘p01’  <span class="keyword">and</span>  o2.pid=‘p07’;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  o1.cid  <span class="keyword">FROM</span> orders  o1</span><br><span class="line"><span class="keyword">WHERE</span>  o1.pid=‘p01’ <span class="keyword">and</span> o1.cid <span class="keyword">IN</span> (</span><br><span class="line"><span class="keyword">SELECT</span>  o2.cid   <span class="keyword">FROM</span>  orders  o2</span><br><span class="line"><span class="keyword">WHERE</span>  o2.pid=‘p07’ );</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Select</span> cid <span class="keyword">from</span> orders <span class="keyword">where</span> pid = <span class="string">'p01'</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">Select</span> cid <span class="keyword">from</span> orders <span class="keyword">where</span> pid = <span class="string">'p07'</span>;</span><br></pre></td></tr></table></figure>
<br/>
<p><font color = blue size = 4>3. Get cids of customers who <span style="background: linear-gradient(to right, #f2994a, #f2c94c);">place an order</span> through at least one agent who <span style="background: linear-gradient(to right, #f2994a, #f2c94c);">places an order</span> for product p03.</font></p>
<blockquote>
<p><font color = green size = 4>T1 := (O where pid = ‘p03’)[aid]</font></p>
<p><font color = green size = 4>T2 := (T1 $\infty $ O) [cid]</font></p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  o2.cid</span><br><span class="line"><span class="keyword">FROM</span>    orders  o1,  orders  o2</span><br><span class="line"><span class="keyword">WHERE</span>   o1.pid=‘p03’  <span class="keyword">and</span>  o1.aid=o2.aid;</span><br></pre></td></tr></table></figure>
<br/>
<p><font color = blue size = 4>4. Get cids of all customers who <span style="background: linear-gradient(to right, #f2994a, #f2c94c);">have the same discount</span> as any customer in Dallas or Boston.</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  c1.cid</span><br><span class="line"><span class="keyword">FROM</span>    customers  c1,  customers  c2</span><br><span class="line"><span class="keyword">WHERE</span>  ( c1.city = ‘Dallas’  <span class="keyword">or</span>  c1.city = ‘Boston’ )</span><br><span class="line"><span class="keyword">and</span>  c1.discnt = c2.discnt <span class="keyword">and</span> c1.cid &lt; c2.cid;</span><br></pre></td></tr></table></figure>
<br/>
<p><font color = blue size = 4>5. Find all customer names where the customer <span style="background: linear-gradient(to right, #f2994a, #f2c94c);">does not place</span> an order through agent a05.</font></p>
<blockquote>
<p><font color = green size = 4>((C[cid] – (O where aid = ‘a05’) [cid]) $\infty $ C) [cname]</font></p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  cname</span><br><span class="line"><span class="keyword">FROM</span>  customers</span><br><span class="line"><span class="keyword">WHERE</span>  cid  <span class="keyword">NOT</span> <span class="keyword">IN</span> ( </span><br><span class="line">    <span class="keyword">SELECT</span>  o.cid</span><br><span class="line">	<span class="keyword">FROM</span>  orders  o</span><br><span class="line">	<span class="keyword">WHERE</span>  o.aid = ‘a05’ ) ;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  cname</span><br><span class="line"><span class="keyword">FROM</span>    customers  c</span><br><span class="line"><span class="keyword">WHERE</span>   <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (</span><br><span class="line"><span class="keyword">SELECT</span>  *</span><br><span class="line"><span class="keyword">FROM</span>   orders  o</span><br><span class="line"><span class="keyword">WHERE</span>  o.cid = c.cid  <span class="keyword">and</span>  o.aid = ‘a05’ ) ;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><font color = red size = 4>注意：</font><font color = green size = 4>此处可以看见NOT EXISTS需要将索引联结起来；而NOT IN则不需要</font></p>
</blockquote>
<br/>
<p><font color = blue size = 4>6. Find all cid, aid pairs where the customer <span style="background: linear-gradient(to right, #f2994a, #f2c94c);">does not place</span> an order through the agent.</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  cid,  aid</span><br><span class="line"><span class="keyword">FROM</span>  customers  c,  agents  a</span><br><span class="line"><span class="keyword">WHERE</span>  <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (</span><br><span class="line"><span class="keyword">SELECT</span>  *</span><br><span class="line"><span class="keyword">FROM</span>  orders  o</span><br><span class="line"><span class="keyword">WHERE</span>  o.cid = c.cid  <span class="keyword">and</span>  o.aid = a.aid );</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  cid,  aid</span><br><span class="line"><span class="keyword">FROM</span>  customers  c,  agents  a</span><br><span class="line"><span class="keyword">WHERE</span>   (cid,  aid)  <span class="keyword">NOT</span>  <span class="keyword">IN</span> (</span><br><span class="line"><span class="keyword">SELECT</span>  o.cid,  o.aid  <span class="keyword">FROM</span>  orders  o );</span><br></pre></td></tr></table></figure>
<blockquote>
<p><font color = red size = 4>注意：</font><font color = green size = 4>此处也可以看见NOT EXISTS需要将索引联结起来；而NOT IN则不需要</font></p>
</blockquote>
<br/>
<p><font color = blue size = 4>7. Get the names of customers who order <span style="background: linear-gradient(to right, #f2994a, #f2c94c);">at least one</span> product priced at $0.50.</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  cname</span><br><span class="line"><span class="keyword">FROM</span>  products  p, orders  o, customers  c</span><br><span class="line"><span class="keyword">WHERE</span>  price=<span class="number">0.50</span> <span class="keyword">and</span> p.pid=o.pid <span class="keyword">and</span></span><br><span class="line">o.cid=c.cid ;</span><br></pre></td></tr></table></figure>
<br/>
<p><font color = blue size = 4>8. Retrieve customers who place orders <span style="background: linear-gradient(to right, #f2994a, #f2c94c);">only through</span> agent a03</font></p>
<blockquote>
<p><font color = green size = 4>O [cid] - (O where aid &lt;&gt; ‘a03’) [cid]</font></p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  o1.cid</span><br><span class="line"><span class="keyword">FROM</span>    orders  o1</span><br><span class="line"><span class="keyword">WHERE</span>  o1.cid  <span class="keyword">NOT</span> <span class="keyword">IN</span> (</span><br><span class="line"><span class="keyword">SELECT</span> o2.cid</span><br><span class="line"><span class="keyword">FROM</span>  orders  o2</span><br><span class="line"><span class="keyword">WHERE</span>  o2.aid &lt;&gt; ‘a03’) ;</span><br></pre></td></tr></table></figure>
<br/>
<hr>
<h3 id="四-UNION-Operators-and-FOR-ALL-Conditions">四.UNION Operators and FOR ALL Conditions</h3>
<h4 id="1-The-UNION-Operator-并集-交集拓展">1. The UNION Operator(并集/交集拓展)</h4>
<p><font color = blue size = 4>1. Retrieve all cities where either a customer or an agent, or both, is based.</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span>  city  <span class="keyword">from</span>  customers </span><br><span class="line"><span class="keyword">UNION</span> </span><br><span class="line"><span class="keyword">select</span>  city  <span class="keyword">from</span>  agents</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span>  city  <span class="keyword">from</span>  customers </span><br><span class="line"><span class="keyword">UNION</span> </span><br><span class="line"><span class="keyword">select</span>  city  <span class="keyword">from</span>  agents</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span>  city  <span class="keyword">from</span>  customers</span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">select</span>  city  <span class="keyword">from</span>  agents</span><br></pre></td></tr></table></figure>
<blockquote>
<p><font color = red size = 4>注意：</font></p>
<p><font color = green size = 4>如果我们需要将两个或多个select语句的结果作为一个整体显示出来，这是我们就需要用到union或者union all关键字。</font></p>
<p><font color = green size = 4>union和union all的区别是,union会自动压缩多个结果集合中的重复结果，而union all则将所有的结果全部显示出来，不管是不是重复。</font></p>
</blockquote>
<br/>
<p><font color = red size = 5>拓展：求交集</font></p>
<p><font color = blue size = 4>1. Get cid values of customers who order both products p01 and p07.</font></p>
<blockquote>
<p><font color = green size = 4>(Orders where pid = ‘p01’) [cid] $\cap$ (Orders where pid = ‘p07’) [cid]</font></p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> o1.cid <span class="keyword">from</span> Orders o1</span><br><span class="line"><span class="keyword">where</span> pid = <span class="string">'p01'</span> <span class="keyword">and</span> pid <span class="keyword">IN</span></span><br><span class="line">(<span class="keyword">select</span> o2.cid <span class="keyword">from</span> Orders o2</span><br><span class="line"><span class="keyword">where</span> pid = <span class="string">'p02'</span> <span class="keyword">and</span> o1.cid = o2.cid);</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> cid <span class="keyword">from</span> (<span class="keyword">select</span> cid <span class="keyword">from</span> Orders <span class="keyword">where</span> pid = <span class="string">'p01'</span>) t1,</span><br><span class="line">(<span class="keyword">select</span> cid <span class="keyword">from</span> Orders <span class="keyword">where</span> pid = <span class="string">'p07'</span>) t2</span><br><span class="line"><span class="keyword">where</span> t1.cid = t2.cid;</span><br></pre></td></tr></table></figure>
<br/>
<h4 id="2-The-span-style-background-linear-gradient-to-right-f2994a-f2c94c-Division-Operation-span-in-Relational-Algebra">2. The <span style="background: linear-gradient(to right, #f2994a, #f2c94c);">Division Operation</span> in Relational Algebra</h4>
<blockquote>
<p><font color = red size = 4>注意：</font></p>
<p><font color = green size = 4>1. 可将关系代数中的除法运算<font color = red>转换为</font>SQL语句的NOT EXISTS<font color = red>二重</font>条件判断</font></p>
<p><font color = green size = 4>2. 写出关系代数式(包含除法运算)<font color = red>根据表关系</font>构造NOT EXISTS二重条件判断</font></p>
<p><font color = green size = 4>3. NOT EXISTS判断为Select *，且需要建立索引</font></p>
</blockquote>
<br/>
<p><font color = blue size = 4>1. Find cids of customers who place orders with <span style="background: linear-gradient(to right, #f2994a, #f2c94c);">ALL agents</span> based in New York.</font></p>
<blockquote>
<p><font color = green size = 4>o[cid, aid] $\div$ (a where city=‘New York’)[aid]</font></p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  c.cid</span><br><span class="line"><span class="keyword">FROM</span>    customers  c</span><br><span class="line"><span class="keyword">WHERE</span>  	<span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (</span><br><span class="line">    	<span class="keyword">SELECT</span>  *</span><br><span class="line">		<span class="keyword">FROM</span>  agents  a</span><br><span class="line">		<span class="keyword">WHERE</span>  a.city = ‘<span class="keyword">New</span> York’  <span class="keyword">and</span>  <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (</span><br><span class="line">		<span class="keyword">SELECT</span>  *</span><br><span class="line">		<span class="keyword">FROM</span>  orders  o</span><br><span class="line">		<span class="keyword">WHERE</span>  o.cid = c.cid  <span class="keyword">and</span>  o.aid = a.aid ) );</span><br></pre></td></tr></table></figure>
<br/>
<p><img data-src="https://image.zxkidea.top/1550381521441.png" alt="zxk"></p>
<br/>
<p><font color = blue size = 4>2. Get the aid values of agents in New York or Duluth who place orders for <span style="background: linear-gradient(to right, #f2994a, #f2c94c);">all products</span> costing more than a dollar.</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  aid</span><br><span class="line"><span class="keyword">FROM</span>    agents  a</span><br><span class="line"><span class="keyword">WHERE</span>  (city=‘<span class="keyword">New</span> York’ <span class="keyword">or</span> city=‘Duluth’) <span class="keyword">and</span></span><br><span class="line"><span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (</span><br><span class="line">	<span class="keyword">SELECT</span>  *</span><br><span class="line">	<span class="keyword">FROM</span>  products  p</span><br><span class="line">	<span class="keyword">WHERE</span>  p.price &gt; <span class="number">1</span>  <span class="keyword">and</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (</span><br><span class="line">	<span class="keyword">SELECT</span>  *</span><br><span class="line">	<span class="keyword">FROM</span>  orders  o</span><br><span class="line">	<span class="keyword">WHERE</span>  o.aid=a.aid <span class="keyword">and</span> o.pid=p.pid  ) );</span><br></pre></td></tr></table></figure>
<br/>
<p><font color = blue size = 4>3. Find aid values of agents who <span style="background: linear-gradient(to right, #f2994a, #f2c94c);">place orders for product p01</span> as well as for <span style="background: linear-gradient(to right, #f2994a, #f2c94c);">all products</span> costing more than a dollar.</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  aid    <span class="keyword">FROM</span>  agents  a</span><br><span class="line"><span class="keyword">WHERE</span>   aid <span class="keyword">IN</span> (  </span><br><span class="line">    <span class="keyword">select</span> aid <span class="keyword">from</span> orders</span><br><span class="line">	<span class="keyword">where</span> pid=‘p01’ )</span><br><span class="line">	<span class="keyword">and</span>  <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (</span><br><span class="line">	<span class="keyword">SELECT</span>  *    <span class="keyword">FROM</span>  products  p</span><br><span class="line">	<span class="keyword">WHERE</span>  p.price &gt; <span class="number">1</span>  <span class="keyword">and</span>  <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (</span><br><span class="line">	<span class="keyword">SELECT</span>  *    <span class="keyword">FROM</span>  orders  o</span><br><span class="line">	<span class="keyword">WHERE</span>  o.aid=a.aid <span class="keyword">and</span> o.pid=p.pid));</span><br></pre></td></tr></table></figure>
<br/>
<p><font color = blue size = 4>4. Get cids of customers who order <span style="background: linear-gradient(to right, #f2994a, #f2c94c);">all products</span> that <span style="background: linear-gradient(to right, #f2994a, #f2c94c);">anybody orders</span>.</font></p>
<blockquote>
<p><font color = green size = 4>O[cid, pid] ÷ O[pid]</font></p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  c.cid  <span class="keyword">FROM</span>  customers  c</span><br><span class="line"><span class="keyword">WHERE</span>  <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (</span><br><span class="line">		<span class="keyword">SELECT</span>  *  <span class="keyword">FROM</span> orders  o1</span><br><span class="line">		<span class="keyword">WHERE</span>  <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (</span><br><span class="line">		<span class="keyword">SELECT</span>  *  <span class="keyword">FROM</span> orders  o2</span><br><span class="line">		<span class="keyword">WHERE</span>  o2.cid=c.cid  <span class="keyword">and</span>  o2.pid=o1.pid ));</span><br></pre></td></tr></table></figure>
<br/>
<p><font color = blue size = 4>5. Get aids of agents who take orders on <span style="background: linear-gradient(to right, #f2994a, #f2c94c);">at least</span> that set of products ordered by c004.</font></p>
<blockquote>
<p><font color = green size = 4>O[aid, pid] ÷ (O where cid = ‘c004’)[pid]</font></p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  a.aid</span><br><span class="line"><span class="keyword">FROM</span>  agents  a</span><br><span class="line"><span class="keyword">WHERE</span>  <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (</span><br><span class="line">		<span class="keyword">SELECT</span>  *</span><br><span class="line">		<span class="keyword">FROM</span>  orders o1</span><br><span class="line">		<span class="keyword">WHERE</span>  o1.cid=‘c004’  <span class="keyword">and</span>  <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (</span><br><span class="line">		<span class="keyword">SELECT</span>  *</span><br><span class="line">		<span class="keyword">FROM</span>  orders o2</span><br><span class="line">		<span class="keyword">WHERE</span>  o2.aid=a.aid  <span class="keyword">and</span>  o2.pid=o1.pid  ));</span><br></pre></td></tr></table></figure>
<br/>
<p><font color = blue size = 4>6. Get cids for customers with the following property: </font></p>
<p><font color = blue size = 4>If customer c006 orders a product x through agent y, so the customer orders the product x through the agent y.</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  cid</span><br><span class="line"><span class="keyword">FROM</span>    customers  c</span><br><span class="line"><span class="keyword">WHERE</span>   <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (</span><br><span class="line">		<span class="keyword">SELECT</span>  *</span><br><span class="line">		<span class="keyword">FROM</span>   orders o1</span><br><span class="line">		<span class="keyword">WHERE</span>   o1.cid=‘c006’  <span class="keyword">and</span>  <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (</span><br><span class="line">		<span class="keyword">SELECT</span>  *</span><br><span class="line">		<span class="keyword">FROM</span>  orders o2</span><br><span class="line">		<span class="keyword">WHERE</span>   o2.cid = c.cid  <span class="keyword">and</span>  o2.pid = o1.pid</span><br><span class="line">	   	<span class="keyword">and</span>  o2.aid = o1.aid  ) );</span><br></pre></td></tr></table></figure>
<br/>
<p><font color = blue size = 4>7. Get aids of agents who place orders for <span style="background: linear-gradient(to right, #f2994a, #f2c94c);">all customers</span> who place orders for <span style="background: linear-gradient(to right, #f2994a, #f2c94c);">all products</span> costing more than a dollar through the agent.</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  aid</span><br><span class="line"><span class="keyword">FROM</span>  agents  a</span><br><span class="line"><span class="keyword">WHERE</span>  <span class="keyword">not</span> <span class="keyword">exists</span> (</span><br><span class="line">		<span class="keyword">SELECT</span>  *</span><br><span class="line">		<span class="keyword">FROM</span>  customers  c,  products  p</span><br><span class="line">		<span class="keyword">WHERE</span>  p.price &gt; <span class="number">1</span>  <span class="keyword">and</span>  <span class="keyword">not</span> <span class="keyword">exists</span> (</span><br><span class="line">		<span class="keyword">SELECT</span>  *</span><br><span class="line">		<span class="keyword">FROM</span>  orders  x</span><br><span class="line">		<span class="keyword">WHERE</span>   x.cid = c.cid  <span class="keyword">and</span>  x.pid = p.pid</span><br><span class="line">	  	<span class="keyword">and</span>  x.aid = a.aid  ) );</span><br></pre></td></tr></table></figure>
<br/>
<blockquote>
<p><font color = red size = 5>注意：</font></p>
<p><font color = green size = 4>Relational Algebra：</font></p>
<p>R(x, y) $\div$ S(y)</p>
<p><font color = green size = 4>Relational Calculus：</font></p>
<p>$\forall$z ( $\exists$ y ( P(z, y) )) $\longleftrightarrow$ $\nexists$z ( $\nexists$ y ( P(z, y) ))</p>
</blockquote>
<br/>
<h4 id="3-Set-Functions-in-SQL-聚合函数">3.  Set Functions in SQL(聚合函数)</h4>
<p><img data-src="https://image.zxkidea.top/1550405574789.png" alt="zxk"></p>
<br/>
<p><font color = blue size = 4>1. Get the total dollar amount of all orders.</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span>  <span class="keyword">sum</span> ( dollars )  <span class="keyword">as</span>  totaldollars</span><br><span class="line"><span class="keyword">from</span>  orders;</span><br></pre></td></tr></table></figure>
<br/>
<p><font color = blue size = 4>2. Get the total quantity of product p03 that has been ordered.</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span>  <span class="keyword">sum</span> ( qty )  <span class="keyword">as</span>  TOTAL</span><br><span class="line"><span class="keyword">from</span>  orders</span><br><span class="line"><span class="keyword">where</span>  pid = ‘p03’;</span><br></pre></td></tr></table></figure>
<br/>
<p><font color = blue size = 4>3. List the cid values of all customers who have a discount <span style="background: linear-gradient(to right, #f2994a, #f2c94c);">less than</span> the maximum discount.</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span>  cid</span><br><span class="line"><span class="keyword">from</span>  customers  c1</span><br><span class="line"><span class="keyword">where</span>  discnt &lt; <span class="keyword">all</span> ( </span><br><span class="line">    <span class="keyword">select</span>  <span class="keyword">max</span>(c2.discnt)</span><br><span class="line">	<span class="keyword">from</span>  customers  c2 );</span><br></pre></td></tr></table></figure>
<br/>
<p><font color = blue size = 4>4. Find products ordered by <span style="background: linear-gradient(to right, #f2994a, #f2c94c);">at least</span> two customers.</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span>   p.pid</span><br><span class="line"><span class="keyword">from</span>     products  p</span><br><span class="line"><span class="keyword">where</span>  <span class="number">2</span> &lt;= <span class="keyword">ALL</span> (   </span><br><span class="line">    <span class="keyword">select</span>  <span class="keyword">count</span> ( <span class="keyword">distinct</span>  cid )</span><br><span class="line">	<span class="keyword">from</span>     orders  o</span><br><span class="line">	<span class="keyword">where</span>  o.pid = p.pid );</span><br></pre></td></tr></table></figure>
<blockquote>
<p><font color = red size = 4>注意：</font></p>
<p><font color = green size = 4>1. 此处表示至少有两个顾客购买的产品；</font></p>
<p><font color = green size = 4>2. 具体语句运行过程：</font></p>
<p><font color = brown size = 4>a. 先将两表连接；</font></p>
<p><font color = brown size = 4>b. 然后返回相等pid下cid不重复的记录数；</font></p>
<p><font color = brown size = 4>c. 若相同pid的该记录数大于2，则返回其pid；</font></p>
</blockquote>
<br/>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> p.pid <span class="keyword">from</span> (</span><br><span class="line">	<span class="keyword">select</span> pid, <span class="keyword">count</span>(<span class="keyword">distinct</span> cid) dcd </span><br><span class="line">    <span class="keyword">from</span> orders <span class="keyword">as</span> o <span class="keyword">group</span> <span class="keyword">by</span> pid) t, products p </span><br><span class="line"><span class="keyword">where</span> t.pid = t.pid <span class="keyword">and</span> t.dcd &gt;= <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><font color = red size = 4>注意：</font></p>
<p><font color = green size = 4>1. 先将orders表pid，cid不重复记录分组构造新表t；</font></p>
<p><font color = green size = 4>2. 再将produsts表与t表连接，最后返回cid不重复记录数大于2的pid；</font></p>
</blockquote>
<br/>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  pid</span><br><span class="line"><span class="keyword">FROM</span>    orders</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span>  pid</span><br><span class="line"><span class="keyword">HAVING</span>   <span class="keyword">count</span> ( <span class="keyword">distinct</span>  cid ) &gt;= <span class="number">2</span> ;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><font color = red size = 4>注意：</font><font color = green size = 4>使用Group By对pid进行分组，Having对cid进行过滤</font></p>
</blockquote>
<br/>
<blockquote>
<p><font color = red size = 4>注意：</font></p>
<p><font color = green size = 4>1. count(*)：获取数量</font></p>
<p><font color = green size = 4>2. sum()：求和（这里要注意求和是忽略null值的，null与其他数值相加结果为null，所以可以通过ifnull(xxx,0)将null的值赋为0</font></p>
<p><font color = green size = 4>3. avg()：求平均数</font></p>
<p><font color = green size = 4>4. max()：求最大值</font></p>
<p><font color = green size = 4>5. min()：求最小值</font></p>
</blockquote>
<br/>
<h4 id="4-Groups-of-Rows-in-SQL">4. Groups of Rows in SQL</h4>
<p><font color = blue size = 4>GROUP BY clause &amp; HAVING clause</font></p>
<blockquote>
<p><em><strong><font color = red size = 4>SQL语句的执行顺序：</font></strong></em></p>
<p><font color = red size = 4>from–where–group by–having–select–order by</font></p>
<p>from：需要从哪个数据表检索数据<br>
where：过滤表中数据的条件<br>
group by：如何将上面过滤出的数据分组<br>
having：对上面已经分组的数据进行过滤的条件<br>
select：查看结果集中的哪个列，或列的计算结果<br>
order by：按照什么样的顺序来查看返回的数据</p>
</blockquote>
<br/>
<p><font color = blue size = 4>1) GROUP BY</font></p>
<ul>
<li>
<p>GROUP BY语句用来与聚合函数(aggregate functions such as COUNT, SUM, AVG, MIN, or MAX.)联合使用来得到一个或多个列的结果集。</p>
</li>
<li>
<p>因为聚合函数通过作用于一组数据而只返回一个单个值，因此，在SELECT语句中出现的元素要么为一个聚合函数的输入值，要么为GROUP BY语句的参数，否则会出错。</p>
</li>
</ul>
<br/>
<p><font color = blue size = 4>例如，对于上面提到的表格，我们做一个这样的查询：</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, <span class="keyword">COUNT</span>(course) <span class="keyword">as</span> numcourse, score</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">id</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><font color = green size = 4>此时查询便会出错，错误提示如下：</font></p>
<p><font color = green size = 4>Column ‘student.score’ is invalid in the select list because it is not contained in either an aggregate function or the GROUP BY clause.</font></p>
<p><font color = green size = 4>出现以上错误的原因是因为一个学生id对应多个分数，如果我们简单的在</font></p>
<p><font color = green size = 4>SELECT语句中写上score，则无法判断应该输出哪一个分数。如果想用score作为</font></p>
<p><font color = green size = 4>select语句的参数可以将它用作一个聚合函数的输入值，如下例，我们可以得到每个</font></p>
<p><font color = green size = 4>学生所选的课程门数以及每个学生的平均分数：</font></p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, <span class="keyword">COUNT</span>(course) <span class="keyword">as</span> numcourse, <span class="keyword">AVG</span>(score) <span class="keyword">as</span> avgscore</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">id</span>;</span><br></pre></td></tr></table></figure>
<br/>
<p><font color = blue size = 4>1. Find the agent name and aid, and the product name and pid, together with the total quantity each agent supplies of that product to customers c002 and c003.</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  a.aid, a.aname, p.pid, p.pname, <span class="keyword">sum</span>(qty)</span><br><span class="line"><span class="keyword">FROM</span>  agents  a, products  p, orders  o</span><br><span class="line"><span class="keyword">WHERE</span>  a.aid = o.aid <span class="keyword">and</span> p.pid = o.pid <span class="keyword">and</span></span><br><span class="line">o.cid <span class="keyword">IN</span> (<span class="string">'c002'</span>,<span class="string">'c003'</span>)</span><br><span class="line"><span class="keyword">GROUP</span>  <span class="keyword">BY</span>  a.aid, a.aname, p.pid, p.pname</span><br></pre></td></tr></table></figure>
<blockquote>
<p><font color = red size = 4>注意：</font><font color = green size = 4>多表连接也可以使用Group By进行分组</font></p>
</blockquote>
<br/>
<p><font color = red size = 4>2.对某个字段分组且进行数据统计，可使用count(*)技巧</font></p>
<p><font color = blue>例如说明现在有一个这样的表：每个部门有多少人 就要用到分组的技术</font></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select DepartmentID as &#39;部门名称&#39;,</span><br><span class="line">COUNT(*) as &#39;个数&#39; from BasicDepartment group by DepartmentID</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个就是使用了group by +字段进行了分组，其中我们就可以理解为我们按照了部门的名称ID，DepartmentID将数据集进行了分组；然后再进行各个组的统计数据分别有多少；<br>
<span style="background: linear-gradient(to right, #f2994a, #f2c94c);">通俗一点说</span>：group by 字段1，字段2。。。(整个表中不止这两个字段)表示数据集中字段1相等，字段2也相等的数据归为一组，只显示一条数据。那么你可以对字段3进行统计（求和，求平均值等）;</p>
</blockquote>
<br/>
<p><font color = red size = 4>3.MySQL中group by的时候字段不加聚合函数的情况</font></p>
<blockquote>
<p>首先对于不加聚合函数的sql语句来说，它的功能<span style="background: linear-gradient(to right, #f2994a, #f2c94c);">结合了limit</span>来得出结果，仔细想想的时候有点Oracle分析函数的味道，limit的时候得到的并不是最大最小的值(元素按照原来在<span style="background: linear-gradient(to right, #f2994a, #f2c94c);">表中的默认顺序结合分组</span>)，而是某一下group by结果集中第一行，也就是刚才说的<span style="background: linear-gradient(to right, #74ebd5, #acb6e5);">相当于先group by， 然后在每个group by下面进行limit 1</span>。</p>
</blockquote>
<br/>
<blockquote>
<p>其次，刚才还说了常规的group by结合聚合函数的时候，选择的字段除了聚合函数外，必须在group by中存在，但是在mysql中不是这样了，它具有<span style="background: linear-gradient(to right, #f2994a, #f2c94c);">隐含字段</span>的功能，例如：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select a,b,c,count(*) from test1 group by a,b;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">a</th>
<th style="text-align:center">b</th>
<th style="text-align:center">c</th>
<th style="text-align:center">count(*)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">5</td>
<td style="text-align:center">3</td>
</tr>
</tbody>
</table>
<blockquote>
<p><font color = red>注意：</font>对于没有选择的字段，上面是c，c的值还是和上面说到的一样，是根据得到的结果集然后根据每个group by 进行limit 1得到的结果。</p>
</blockquote>
<br/>
<p><font color = blue size = 4>2) HAVING</font></p>
<ul>
<li>
<p>HAVING语句通常与GROUP BY语句联合使用，用来过滤由GROUP BY语句返回的记录集。</p>
</li>
<li>
<p>HAVING语句的存在弥补了WHERE关键字不能与聚合函数联合使用的不足（只能接聚合函数进行筛选）。</p>
</li>
</ul>
<br/>
<p><font color = blue size = 4>1. Find all product and agent IDs and the total quantity ordered of the product by the agent, when this quantity exceeds 1000.</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  pid,  aid,  <span class="keyword">sum</span>(qty)  <span class="keyword">as</span>  total</span><br><span class="line"><span class="keyword">FROM</span>    orders</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span>  pid,  aid</span><br><span class="line"><span class="keyword">HAVING</span>  <span class="keyword">sum</span>(qty) &gt; <span class="number">1000</span> ;</span><br></pre></td></tr></table></figure>
<br/>
<p><font color = blue size = 4>2. Provide pid values of all products purchased by at least two customers.</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  pid</span><br><span class="line"><span class="keyword">FROM</span>    orders</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span>  pid</span><br><span class="line"><span class="keyword">HAVING</span>  <span class="keyword">count</span> ( <span class="keyword">distinct</span>  cid ) &gt;= <span class="number">2</span> ;</span><br></pre></td></tr></table></figure>
<br/>
<p><font color = blue size = 4>3. Find the average, over all agents, of the maximum dollar sales made by each agent.</font></p>
<p><span style="background: linear-gradient(to right, #f2994a, #f2c94c);">Right：</span></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  <span class="keyword">avg</span> ( t.x )</span><br><span class="line"><span class="keyword">FROM</span> ( <span class="keyword">select</span>  aid, <span class="keyword">max</span>(dollars)  <span class="keyword">as</span>  x</span><br><span class="line">	   <span class="keyword">from</span>   orders</span><br><span class="line">	   <span class="keyword">group</span> <span class="keyword">by</span>  aid ) t ;</span><br></pre></td></tr></table></figure>
<p><span style="background: linear-gradient(to right, #f2994a, #f2c94c);">Wrong：</span></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  <span class="keyword">avg</span> ( <span class="keyword">select</span> <span class="keyword">max</span> ( dollars ) <span class="keyword">from</span> orders )</span><br><span class="line"><span class="keyword">FROM</span>    orders</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span>  aid ;</span><br></pre></td></tr></table></figure>
<br/>
<h4 id="5-Insert-Update-and-Delete-Statements">5. Insert, Update, and Delete Statements</h4>
<p><font color = green size = 4>1) The Insert Statement</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tablename [ ( colname, ...... ) ]</span><br><span class="line"><span class="keyword">VALUES</span> ( expr|<span class="literal">NULL</span>, ...... ) | subquery</span><br></pre></td></tr></table></figure>
<br/>
<ul>
<li><font color = blue>带有子查询</font></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> T_ReaderFavorite2 (FCategoryId, FReaderId)</span><br><span class="line"><span class="keyword">SELECT</span> FCategoryId, FReaderId <span class="keyword">FROM</span> T_ReaderFavorite <span class="keyword">Where</span> ....</span><br></pre></td></tr></table></figure>
<blockquote>
<p><font color = brown>这里使用SELECT FCategoryId,FReaderId FROM T_ReaderFavorite将T_ReaderFavorite表中的数据读出，然后使用INSERT INTO T_ReaderFavorite2(FCategoryId,FReaderId)将检索结果插入到T_ReaderFavorite2 表中，注意上下的列顺序必须是<b>一一对应</b>的。</font></p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> T_ReaderFavorite(FCategoryId,FReaderId)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">1</span>,FId <span class="keyword">FROM</span> T_Reader <span class="keyword">Where</span> ....</span><br></pre></td></tr></table></figure>
<blockquote>
<p><font color = brown>SELECT语句从T_Reader表中检索所有的读者信息，并且将第一列设定为固定值1，而将第二列设定为读者的主键，执行完毕查看T_ReaderFavorite表中的内容。</font></p>
</blockquote>
<br/>
<p><font color = green size = 4>2) The Update Statements</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span>  tablename</span><br><span class="line"><span class="keyword">SET</span>  colname = expr | <span class="literal">NULL</span> | subquery, ......</span><br><span class="line">[ <span class="keyword">WHERE</span>  <span class="keyword">search</span>-condition ];</span><br></pre></td></tr></table></figure>
<br/>
<p><font color = blue size = 4>1. Give all customers who have total orders of more than $1000 a 10% increase in the discnt they receive.</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span>  customers</span><br><span class="line"><span class="keyword">SET</span>  discnt = <span class="number">1.1</span> * discnt</span><br><span class="line"><span class="keyword">WHERE</span>  cid  <span class="keyword">in</span>  ( <span class="keyword">select</span>  cid</span><br><span class="line">		<span class="keyword">from</span>  orders</span><br><span class="line">		<span class="keyword">group</span>  <span class="keyword">by</span>  cid</span><br><span class="line">		<span class="keyword">having</span>  <span class="keyword">sum</span>(dollars) &gt; <span class="number">1000</span> );</span><br></pre></td></tr></table></figure>
<blockquote>
<p><font color = red size = 4>注意：</font><font color = green size = 4>可利用Select不包含聚合函数，Having包含聚合函数进行单一筛选！</font></p>
</blockquote>
<br/>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> customers c</span><br><span class="line"><span class="keyword">SET</span>  discnt = <span class="number">1.1</span> * discnt</span><br><span class="line"><span class="keyword">WHERE</span> <span class="number">1000</span> &lt; ( <span class="keyword">Select</span> <span class="keyword">sum</span>(dollars) </span><br><span class="line">      <span class="keyword">from</span> orders o <span class="keyword">where</span> o.cid = c.cid);</span><br></pre></td></tr></table></figure>
<br/>
<ul>
<li><font color = blue>多张表UPDATE用法</font></li>
<li><font color = blue>当用一个表中的数据来更新另一个表中的数据，T-SQL提供多种写法(下面列出了二种)，但建议用第一种写法，虽然传统，但结构清晰。<br>
并且要注意，当用一个表中的数据来更新另一个表中的数据时，<font color = red>二个表一定要有关联！</font></font></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> t1 <span class="keyword">set</span> t1.c2 = t2.c2</span><br><span class="line"><span class="keyword">from</span> t2 </span><br><span class="line"><span class="keyword">where</span> t1.c1 = t2.c1;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Update</span> t1 <span class="keyword">set</span> t1.c2 = t2.c2</span><br><span class="line"><span class="keyword">from</span> t1 <span class="keyword">inner</span> <span class="keyword">join</span> t2 <span class="keyword">on</span> t1.c1 = t2.c1;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Update</span> t1 <span class="keyword">set</span> t1.c2 = t2.c2</span><br><span class="line"><span class="keyword">from</span> t1 <span class="keyword">inner</span> <span class="keyword">join</span> t2 <span class="keyword">using</span>(c1);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><font color = red size = 4>注意：用using关键字进行简化</font></p>
<p><font color = green size = 4>1.查询必须是等值连接。</font></p>
<p><font color = green size = 4>2.等值连接中的列必须具有相同的名称和数据类型。</font></p>
</blockquote>
<br/>
<blockquote>
<p><font color = red size = 4>表联结（join）拓展：</font></p>
</blockquote>
<p><font color = blue size = 4>相同多列联结：</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">select... <span class="keyword">from</span> table1 <span class="keyword">inner</span> <span class="keyword">join</span> table2</span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span>(column1,column2)</span><br></pre></td></tr></table></figure>
<p><font color = green size = 4>相当于</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">select... <span class="keyword">from</span> table1 <span class="keyword">inner</span> <span class="keyword">join</span> table2</span><br><span class="line"> </span><br><span class="line"><span class="keyword">on</span> table1.column1=table2.column1</span><br><span class="line"> </span><br><span class="line"><span class="keyword">and</span> table1.column2=table2.column2;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">select... <span class="keyword">from</span> table1, table2</span><br><span class="line"> </span><br><span class="line"><span class="keyword">where</span> table1.column1=table2.column1</span><br><span class="line"> </span><br><span class="line"><span class="keyword">and</span> table1.column2=table2.column2;</span><br></pre></td></tr></table></figure>
<br/>
<p><font color = blue size = 4>多表联结：</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">select... <span class="keyword">from</span> table1</span><br><span class="line"> </span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> table2 <span class="keyword">using</span>(column1)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> table3 <span class="keyword">using</span>(column2);</span><br></pre></td></tr></table></figure>
<p><font color = green size = 4>相当于</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">select... <span class="keyword">from</span> table1,table2,table3</span><br><span class="line"> </span><br><span class="line"><span class="keyword">where</span> table1.column1=table2.column1</span><br><span class="line"> </span><br><span class="line"><span class="keyword">and</span> table1.column2=table3.column2;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">select... <span class="keyword">from</span> table1 </span><br><span class="line"></span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> table2 <span class="keyword">on</span> table1.column1=table2.column1</span><br><span class="line"> </span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> table3 <span class="keyword">on</span> table1.column2=table3.column2;</span><br></pre></td></tr></table></figure>
<br/>
<ul>
<li><font color = blue>FROM 子句中指定的表的别名不能作为 SET column_name 子句中<font color = red>被修改字段</font>的限定符使用。</font></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> titles</span><br><span class="line"><span class="keyword">SET</span> t.ytd_sales = t.ytd_sales + s.qty   <span class="comment">--此处的t.ytd_sales使用不当</span></span><br><span class="line"><span class="keyword">FROM</span> titles t, sales s</span><br><span class="line"><span class="keyword">WHERE</span> t.title_id = s.title_id</span><br><span class="line"><span class="keyword">AND</span> s.ord_date = (<span class="keyword">SELECT</span> <span class="keyword">MAX</span>(sales.ord_date) <span class="keyword">FROM</span> sales);</span><br></pre></td></tr></table></figure>
<ul>
<li><font color = blue>若要使上例合法，请从列名中删除别名 t 或使用本身的表名。</font></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> titles</span><br><span class="line"><span class="keyword">SET</span> ytd_sales = t.ytd_sales + s.qty     <span class="comment">--将别名t改为表名</span></span><br><span class="line"><span class="keyword">FROM</span> titles t, sales s</span><br><span class="line"><span class="keyword">WHERE</span> t.title_id = s.title_id</span><br><span class="line"><span class="keyword">AND</span> s.ord_date = (<span class="keyword">SELECT</span> <span class="keyword">MAX</span>(sales.ord_date) <span class="keyword">FROM</span> sales);</span><br></pre></td></tr></table></figure>
<br/>
<ul>
<li><font color = blue>更新多列</font></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> mytab a </span><br><span class="line"><span class="keyword">set</span> (<span class="keyword">name</span>,address)=(<span class="keyword">select</span> b.name,b.address </span><br><span class="line"><span class="keyword">from</span> goal b </span><br><span class="line"><span class="keyword">where</span> b.id=a.id)</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">exists</span> (<span class="keyword">select</span> <span class="number">1</span> </span><br><span class="line"><span class="keyword">from</span> goal b</span><br><span class="line"><span class="keyword">where</span> b.id=a.id );</span><br></pre></td></tr></table></figure>
<blockquote>
<p><font color = red size = 4>1. 多表关联update的时候,记得要加exists()条件,否则不满足条件的记录被update称NULL：<br>
比如：stu表存在,但stu1表不存在的数据,对应的字段会被update成NULL;</font></p>
<p><font color = red size = 4>2. oracle在进行更新时无法join,  所以我们用exists来进行连表条件查询,相当于mytab表和goal表关联，当id相等时才执行更新！</font></p>
</blockquote>
<br/>
<ul>
<li><font color = blue >Update与判断操作的结合</font></li>
</ul>
<blockquote>
<p><font color = green size = 4>1. if(true,a,b),  if(false,a,b) 这个就是第一个如果是true，就等于a，false就等于b，有点像三元表达式</font></p>
<p><font color = green size = 4>2. case when  then else end</font></p>
</blockquote>
<p><font color = red size = 4>(Eg.)性别互换：</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> salary <span class="keyword">set</span> sex = <span class="keyword">if</span>(sex = <span class="string">'m'</span>,<span class="string">'f'</span>,<span class="string">'m'</span>);</span><br><span class="line"><span class="keyword">select</span> (<span class="keyword">case</span> sex <span class="keyword">when</span> <span class="string">'男'</span> <span class="keyword">then</span> <span class="string">'女'</span> <span class="keyword">when</span> <span class="string">'女'</span> <span class="keyword">then</span> <span class="string">'男'</span> <span class="keyword">end</span> ) <span class="keyword">from</span> salary;</span><br><span class="line"><span class="keyword">update</span> salary <span class="keyword">set</span> sex = <span class="keyword">case</span> sex <span class="keyword">when</span> <span class="string">'f'</span> <span class="keyword">then</span> <span class="string">'m'</span> <span class="keyword">else</span> <span class="string">'f'</span> <span class="keyword">end</span> ;</span><br></pre></td></tr></table></figure>
<br/>
<p><font color = green size = 4>3) The Delete Statement</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span>  tablename</span><br><span class="line">[ <span class="keyword">WHERE</span>  <span class="keyword">search</span>-condition ] </span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> c1, c2, ...]</span><br><span class="line">[<span class="keyword">LIMIT</span> <span class="keyword">row_count</span>];</span><br></pre></td></tr></table></figure>
<br/>
<ul>
<li>
<p><font color = blue>多表删除</font></p>
</li>
<li>
<p><font color = blue>多表删除是指从一个或多个表中删除满足条件的数据，其中的 table_references代表了多个表的join操作，例如以下两个例子代表</font></p>
</li>
<li>
<p><font color = blue>从t 1和t 2表中删除满足条件的数据</font></p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> somelog <span class="keyword">WHERE</span> <span class="keyword">user</span> = <span class="string">'jcole'</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> timestamp_column <span class="keyword">LIMIT</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">DELETE</span> t1, t2 <span class="keyword">FROM</span> t1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> t2 <span class="keyword">on</span> t1.id=t2.id <span class="keyword">INNER</span> <span class="keyword">JOIN</span> t3 <span class="keyword">on</span> t1.id=t3.id;</span><br></pre></td></tr></table></figure>
<br/>
<ul>
<li><font color = blue>对多表删除语句而言，如果想对表使用别名，则只能在 table_references子句中使用，否则会报错。</font></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> a1, a2 <span class="keyword">FROM</span> t1 <span class="keyword">AS</span> a1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> t2 <span class="keyword">AS</span> a2 <span class="keyword">ON</span> a1.id=a2.id;      <span class="comment">-- 正确</span></span><br><span class="line"><span class="keyword">DELETE</span> t1 <span class="keyword">AS</span> a1, t2 <span class="keyword">AS</span> a2 <span class="keyword">FROM</span> t1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> t2 <span class="keyword">WHERE</span> a1.id=a2.id;      <span class="comment">-- 错误</span></span><br></pre></td></tr></table></figure>
<br/>
<p><font color = blue size = 4>1. Give all agents in New York a 10% raise in the percent commission they earn on an order.</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span>  agents</span><br><span class="line"><span class="keyword">SET</span>  <span class="keyword">percent</span> = <span class="number">1.1</span> * <span class="keyword">percent</span></span><br><span class="line"><span class="keyword">WHERE</span>  city = ‘<span class="keyword">New</span> York’;</span><br></pre></td></tr></table></figure>
<br/>
<p><font color = blue size = 4>2. Give all customers who have total orders of more than $1000 a 10% increase in the discnt they receive.</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span>  customers</span><br><span class="line"><span class="keyword">SET</span>  discnt = <span class="number">1.1</span> * discnt</span><br><span class="line"><span class="keyword">WHERE</span>  cid  <span class="keyword">in</span>  ( <span class="keyword">select</span>  cid</span><br><span class="line"><span class="keyword">from</span>  orders</span><br><span class="line"><span class="keyword">group</span>  <span class="keyword">by</span>  cid</span><br><span class="line"><span class="keyword">having</span>  <span class="keyword">sum</span>(dollars) &gt; <span class="number">1000</span> );</span><br></pre></td></tr></table></figure>
<br/>
<p><font color = blue size = 4>3. Delete all agents in New York.</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span>  <span class="keyword">FROM</span>  agents</span><br><span class="line"><span class="keyword">WHERE</span>  city = ‘<span class="keyword">New</span> York’;</span><br></pre></td></tr></table></figure>
<br/>
<p><font color = blue size = 4>4. Delete all agents who have total orders of less than $600.</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span>  <span class="keyword">FROM</span>  agents</span><br><span class="line"><span class="keyword">WHERE</span>  aid  <span class="keyword">IN</span>  (</span><br><span class="line"><span class="keyword">select</span>  aid</span><br><span class="line"><span class="keyword">from</span>  orders</span><br><span class="line"><span class="keyword">group</span>  <span class="keyword">by</span>  aid</span><br><span class="line"><span class="keyword">having</span>  <span class="keyword">sum</span>(dollars) &lt; <span class="number">600</span>  );</span><br></pre></td></tr></table></figure>
<br/>
<hr>
<h2 id="Ch4-Object-Relational-SQL">Ch4.Object-Relational SQL</h2>
<h3 id="一-Object-Types">一. Object Types</h3>
<h4 id="1-定义新的数据类型（对象类型）">1.定义新的数据类型（对象类型）</h4>
<ul>
<li><font color = blue size = 4>对象类型的创建与删除</font></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span>  <span class="keyword">TYPE</span>  typename  <span class="keyword">AS</span>  <span class="keyword">OBJECT</span></span><br><span class="line">(attrname  datatype, ......);</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span>  <span class="keyword">TYPE</span>  typename;</span><br></pre></td></tr></table></figure>
<br/>
<ul>
<li><font color = blue size = 4>创建一个 ’姓名’(name_t) 类型</font></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TYPE</span> name_t <span class="keyword">AS</span> <span class="keyword">OBJECT</span> (</span><br><span class="line">lname  <span class="built_in">varchar</span>(<span class="number">30</span>),</span><br><span class="line">fname  <span class="built_in">varchar</span>(<span class="number">30</span>),</span><br><span class="line">mi  <span class="built_in">char</span>(<span class="number">1</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<br/>
<h4 id="2-对象类型的使用方法">2.对象类型的使用方法</h4>
<ul>
<li><font color = blue size = 4>使用已有的对象类型来创建新的类型或表</font></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span>  <span class="keyword">TYPE</span>  person_t  <span class="keyword">AS</span>  <span class="keyword">OBJECT</span> (</span><br><span class="line">ssno          <span class="built_in">int</span>,</span><br><span class="line">pname      	  name_t,    <span class="comment">-- (类型的嵌套定义关系)</span></span><br><span class="line">age           <span class="built_in">int</span>  );</span><br></pre></td></tr></table></figure>
<br/>
<h4 id="3-使用对象数据类型来直接创建一张表">3.使用对象数据类型来直接创建一张表</h4>
<ul>
<li><font color = blue size = 4>  CREATE TABLE tablename OF typename<br>
{  ( constraint-define ) } ;</font></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span>  <span class="keyword">TABLE</span>  people  <span class="keyword">OF</span>  person_t (PRIMARY  <span class="keyword">KEY</span>(ssno)) ;</span><br></pre></td></tr></table></figure>
<br/>
<h4 id="4-对象值的创建、查询与更新">4.对象值的创建、查询与更新</h4>
<ul>
<li><font color = blue size = 4>对象值的创建</font></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Insert</span>  <span class="keyword">into</span>  teachers  <span class="keyword">values</span></span><br><span class="line">(<span class="number">1234</span>, name_t(‘Einstein’, ‘Albert’, ‘E’), <span class="number">120</span>);  <span class="comment">-- 对象构造函数</span></span><br></pre></td></tr></table></figure>
<ul>
<li><font color = blue size = 4>对象值的查询</font></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Select</span>   t.tid, t.name_t.fname, t.name_t.lname</span><br><span class="line"><span class="keyword">From</span>    teachers  t</span><br><span class="line"><span class="keyword">Where</span>  t.room = <span class="number">123</span></span><br></pre></td></tr></table></figure>
<ul>
<li><font color = blue size = 4>对象值的更新</font></li>
</ul>
<p><font color = green size = 4>1) 修改元组中的对象属性值</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span>  people  p</span><br><span class="line"><span class="keyword">set</span>  p.pname = name_t(<span class="string">'Gould'</span>, <span class="string">'Ben'</span>, <span class="literal">null</span>)</span><br><span class="line"><span class="keyword">where</span>  ssno = <span class="number">321341223</span>;</span><br></pre></td></tr></table></figure>
<p><font color = green size = 4>2) 修改某个对象属性值的成员属性</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span>  people  p</span><br><span class="line"><span class="keyword">set</span>  p.pname.mi = ‘C’</span><br><span class="line"><span class="keyword">where</span>  ssno = <span class="number">321341223</span>;</span><br></pre></td></tr></table></figure>
<p><font color = green size = 4>3) 修改整个元组</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span>  people  p</span><br><span class="line"><span class="keyword">set</span>  p = person_t (</span><br><span class="line"><span class="number">332341223</span>,</span><br><span class="line">name_t(<span class="string">'Gould'</span>, <span class="string">'Glen'</span>, <span class="string">'A'</span>), <span class="number">55</span> )</span><br><span class="line"><span class="keyword">where</span>  ssno = <span class="number">321341223</span>;</span><br></pre></td></tr></table></figure>
<br/>
<h4 id="5-对象的引用类型">5.对象的引用类型</h4>
<ul>
<li><font color = blue size = 4>对象的引用类型：REF  &lt; object type &gt;</font></li>
</ul>
<blockquote>
<ol>
<li>
<p>是指向某个元组对象的指针类型</p>
</li>
<li>
<p>可用于实现对象类型之间的嵌套引用</p>
</li>
</ol>
</blockquote>
<br/>
<ul>
<li><font color = blue size = 4>在使用含有 REF类型的对象类型(Object Type)来创建关系表时，必须使用<span style="background: linear-gradient(to right, #f2994a, #f2c94c);">Scope for子句来限制REF属性的取值范围</span>。</font></li>
</ul>
<p><font color = red size =4>1) 定义类型之间的引用关系</font></p>
<blockquote>
<p><font color = brown size = 4>定义基本的对象类型：</font><br>
<font color = green size = 4>customer_t,  agents_t,  products_t</font></p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span>  <span class="keyword">type</span> customer_t <span class="keyword">as</span> <span class="keyword">object</span> (</span><br><span class="line">cid  <span class="built_in">char</span>(<span class="number">4</span>),</span><br><span class="line">cname  <span class="built_in">varchar</span>(<span class="number">13</span>),</span><br><span class="line">city  <span class="built_in">varchar</span>(<span class="number">20</span>),</span><br><span class="line">discnt  <span class="built_in">real</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span>  <span class="keyword">type</span>  agent_t <span class="keyword">as</span> <span class="keyword">object</span> (  </span><br><span class="line">aid  <span class="built_in">char</span>(<span class="number">3</span>),</span><br><span class="line">aname  <span class="built_in">varchar</span>(<span class="number">13</span>),</span><br><span class="line">city  <span class="built_in">varchar</span>(<span class="number">20</span>),</span><br><span class="line"><span class="keyword">percent</span>  <span class="built_in">smallint</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span>  <span class="keyword">type</span>  product_t <span class="keyword">as</span> <span class="keyword">object</span> (</span><br><span class="line">pid  <span class="built_in">char</span>(<span class="number">3</span>),</span><br><span class="line">pname  <span class="built_in">varchar</span>(<span class="number">13</span>),</span><br><span class="line">city  <span class="built_in">varchar</span>(<span class="number">20</span>),</span><br><span class="line">quantity  <span class="built_in">integer</span>,</span><br><span class="line">price  <span class="keyword">double</span>  <span class="keyword">precision</span>);</span><br></pre></td></tr></table></figure>
<br/>
<blockquote>
<p><font color = brown size = 4>定义类型之间的引用关系 :</font></p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">type</span> order_t <span class="keyword">as</span> <span class="keyword">object</span>  (</span><br><span class="line">ordno      <span class="built_in">int</span>,</span><br><span class="line"><span class="keyword">month</span>      <span class="built_in">char</span>(<span class="number">3</span>),</span><br><span class="line">cid        <span class="built_in">char</span>(<span class="number">4</span>),</span><br><span class="line">aid        <span class="built_in">char</span>(<span class="number">3</span>),</span><br><span class="line">pid        <span class="built_in">char</span>(<span class="number">3</span>),</span><br><span class="line">qty        <span class="built_in">int</span>,</span><br><span class="line">dollars    <span class="keyword">double</span> <span class="keyword">precision</span>,  </span><br><span class="line">ordcust    <span class="keyword">ref</span>  customer_t,</span><br><span class="line">ordagent   <span class="keyword">ref</span>  agent_t,</span><br><span class="line">ordprod    <span class="keyword">ref</span>  product_t);</span><br></pre></td></tr></table></figure>
<p><span style="background: linear-gradient(to right, #f2994a, #f2c94c);"><font color = blue size = 4>(新增三个REF属性，分别引用（指向）三个不同的元组对象（Row Object）)</font></span></p>
<br/>
<p><font color = red size = 5>2) 创建含有引用类型的关系表</font></p>
<blockquote>
<p><font color = brown size = 4>使用前面定义的对象类型创建基本关系表 :</font></p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> customers <span class="keyword">of</span> customer_t</span><br><span class="line">(primary <span class="keyword">key</span> (cid));</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> products <span class="keyword">of</span> product_t</span><br><span class="line">(primary <span class="keyword">key</span> (pid));</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> agents <span class="keyword">of</span> agent_t</span><br><span class="line">(primary <span class="keyword">key</span> (aid));</span><br></pre></td></tr></table></figure>
<br/>
<blockquote>
<p><font color = brown size = 4>创建含有引用类型的关系表</font></p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> orders <span class="keyword">of</span> order_t  (</span><br><span class="line">    primary <span class="keyword">key</span> (ordno),</span><br><span class="line">    <span class="keyword">scope</span> <span class="keyword">for</span> (ordcust)  <span class="keyword">is</span>  customers,</span><br><span class="line">    <span class="keyword">scope</span> <span class="keyword">for</span> (ordagent) <span class="keyword">is</span>  agents,</span><br><span class="line">    <span class="keyword">scope</span> <span class="keyword">for</span> (ordprod)  <span class="keyword">is</span>  products );</span><br></pre></td></tr></table></figure>
<br/>
<p><font color = red size = 5>3) 引用关系查询</font></p>
<blockquote>
<p><font color = brown size = 4>根据元组之间的REF引用关系进行查询</font></p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span>   o.ordno, o.ordcust.cname</span><br><span class="line"><span class="keyword">from</span>     orders  o</span><br><span class="line"><span class="keyword">where</span>  o.dollars &gt; <span class="number">200.00</span></span><br></pre></td></tr></table></figure>
<p><font color = blue size = 4>1. Find pid values of products that have been ordered by at least two customers.</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span>  <span class="keyword">distinct</span>  x1.pid </span><br><span class="line"><span class="keyword">from</span>    orders x1, orders x2</span><br><span class="line"> <span class="keyword">where</span>  x1.pid = x2.pid <span class="keyword">and</span> x1.ordcust &lt; x2.ordcust;</span><br></pre></td></tr></table></figure>
<p><span style="background: linear-gradient(to right, #f2994a, #f2c94c);"><font color = green size = 4>ordcust 承担起了 cid 所担负的责任！</font></span></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span>  <span class="keyword">distinct</span>  x1.pid </span><br><span class="line"><span class="keyword">from</span>    orders x1, orders x2</span><br><span class="line"><span class="keyword">where</span>  x1.pid = x2.pid <span class="keyword">and</span> x1.cid &lt; x2.cid;</span><br></pre></td></tr></table></figure>
<br/>
<p><font color = red size = 5>4) 函数与谓词</font></p>
<ul>
<li><font color = blue size = 4>函数与谓词</font></li>
</ul>
<blockquote>
<p>1.获取对象(元组)的引用指针: REF(……)</p>
<p>2.返回引用指针所指向对象的值: DEREF(……)</p>
</blockquote>
<br/>
<ul>
<li>
<p><font color = blue size = 4>两个谓词</font></p>
<ul>
<li>
<p><span style="background: linear-gradient(to right, #f2994a, #f2c94c);">IS DANGLING</span></p>
<blockquote>
<ol>
<li>
<p>用于判断所引用的元组对象是否存在</p>
</li>
<li>
<p>如果所引用的元组对象不存在，那么该谓词返回逻辑真(TRUE)，否则返回逻辑假(FALSE)。</p>
</li>
<li>
<p>该谓词主要用于检查那些错误的对象引用指针。</p>
</li>
</ol>
</blockquote>
</li>
<li>
<p><span style="background: linear-gradient(to right, #f2994a, #f2c94c);">IS NULL</span></p>
</li>
</ul>
</li>
</ul>
<br/>
<p><font color = blue size = 4>1. Retrieve all customer names where the customer does not place an order through agent a05.</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span>  c.cname</span><br><span class="line"><span class="keyword">from</span>   customers  c</span><br><span class="line"><span class="keyword">where</span>  <span class="keyword">not</span> <span class="keyword">exists</span> (</span><br><span class="line"><span class="keyword">select</span>  *  <span class="keyword">from</span> orders x </span><br><span class="line"><span class="keyword">where</span>  x.ordcust = <span class="keyword">ref</span>(c) <span class="keyword">and</span> x.aid = <span class="string">'a05‘ );</span></span><br></pre></td></tr></table></figure>
<br/>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span>  o.cid    <span class="keyword">from</span>  orders o</span><br><span class="line"><span class="keyword">where</span>  o.ordcust  <span class="keyword">IS</span> DANGLING;</span><br></pre></td></tr></table></figure>
<p><font color = green size = 4>等价于：</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> o.cid   <span class="keyword">from</span> orders o</span><br><span class="line"><span class="keyword">where</span> o.ordcust &lt;&gt;</span><br><span class="line">(<span class="keyword">select</span> <span class="keyword">ref</span>(c) <span class="keyword">from</span> customers c</span><br><span class="line"><span class="keyword">where</span> c.cid = o.cid)</span><br></pre></td></tr></table></figure>
<br/>
<p><font color = red size = 5>5) 类型的循环嵌套定义</font></p>
<ul>
<li><font color = blue size = 4>对象类型(object type)不能嵌套定义，但 REF 关系可以实现嵌套引用。</font></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span>  <span class="keyword">type</span>  police_officer_t <span class="keyword">as</span> <span class="keyword">object</span></span><br><span class="line">( pol_person   person_t,</span><br><span class="line">  badge_number <span class="built_in">integer</span>,</span><br><span class="line">  partner  <span class="keyword">ref</span> police_officer_t );</span><br></pre></td></tr></table></figure>
<br/>
<ul>
<li><font color = blue size = 4>可以使用对象类型 police_officer_t 来创建表</font></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> police_officers <span class="keyword">of</span> police_officer_t</span><br><span class="line">( primary <span class="keyword">key</span> (badge_number),</span><br><span class="line">  <span class="keyword">scope</span> <span class="keyword">for</span> (partner) <span class="keyword">is</span> police_officers );</span><br></pre></td></tr></table></figure>
<br/>
<ul>
<li><font color = blue size = 4>在表 police_officers 上的对象查询的例子</font></li>
</ul>
<p><font color = green size = 4>1. Retrieve the last names of all police officers who have partners over sixty years of age.</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span>  p.pol_person.pname.lname</span><br><span class="line"><span class="keyword">from</span>    police_officers  p</span><br><span class="line"><span class="keyword">where</span>   p.partner.pol_person.age &gt; <span class="number">60</span>;</span><br></pre></td></tr></table></figure>
<br/>
<p><font color = red size = 5>6) 其它约束</font></p>
<ul>
<li><font color = blue size = 4>有关 REF定义的其它约束 (REF Dependencies)</font></li>
</ul>
<p><font color = green size = 4>1)  两张表之间的相互 REF关系的定义</font></p>
<blockquote>
<ol>
<li>
<p>首先，定义两个具有相互REF关系的对象类型 (create type …… )</p>
</li>
<li>
<p>再用创建好的对象类型创建关系表</p>
</li>
</ol>
</blockquote>
<br/>
<p><font color = green size  = 4>2)  两个具有相互REF关系的表/类型的删除</font></p>
<blockquote>
<ol>
<li>
<p>在删除类型(drop type)之前需要先删除表(drop table)</p>
</li>
<li>
<p>在删除类型(drop type)时需要采用强制删除的方式</p>
</li>
</ol>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TYPE</span> typename <span class="keyword">FORCE</span>;</span><br></pre></td></tr></table></figure>
<br/>
<blockquote>
<p>先不管REF属性的赋值(先置为NULL)，然后再使用UPDATE操作修改REF属性上的取值</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span>  orders  o</span><br><span class="line"> <span class="keyword">set</span>   ordcust = (<span class="keyword">select</span> <span class="keyword">ref</span>(c) <span class="keyword">from</span> customers c</span><br><span class="line">                        <span class="keyword">where</span> c.cid = o.cid),</span><br><span class="line">     ordagent = (<span class="keyword">select</span> <span class="keyword">ref</span>(a) <span class="keyword">from</span> agents a</span><br><span class="line">                        <span class="keyword">where</span> a.aid = o.aid),</span><br><span class="line">     ordprod = (<span class="keyword">select</span> <span class="keyword">ref</span>(p) <span class="keyword">from</span> products p</span><br><span class="line">                        <span class="keyword">where</span> p.pid = o.pid);</span><br></pre></td></tr></table></figure>
<br/>
<hr>
<h3 id="二-Collection-Types-集合类型">二. Collection Types(集合类型)</h3>
<h4 id="1-Table-Types-Nested-Tables">1.Table Types ( Nested Tables )</h4>
<p><font color = blue size = 4>1) 创建一个新的表类型 (table type)</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span>  <span class="keyword">TYPE</span>  dependents_t</span><br><span class="line"><span class="keyword">AS</span>  <span class="keyword">TABLE</span>  <span class="keyword">OF</span>  person_t;</span><br></pre></td></tr></table></figure>
<br/>
<p><font color = blue size = 4>2) 使用类型dependents_t来定义表employees中的属性并形成一个嵌套表(nested table)定义。</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> employees (</span><br><span class="line">    eid       <span class="built_in">int</span>,</span><br><span class="line">    eperson   person_t,</span><br><span class="line">    dependents  dependents_t,</span><br><span class="line">    primary <span class="keyword">key</span> (eid)</span><br><span class="line">) <span class="keyword">nested</span> <span class="keyword">table</span> dependents <span class="keyword">store</span> <span class="keyword">as</span> dependents_tab;</span><br></pre></td></tr></table></figure>
<br/>
<p><font color = blue size = 4>3) Nested table的访问</font></p>
<ul>
<li>
<p><font color = red size = 4>table ( … ) 的使用</font><br></p>
<p><font color = brown size = 4>Oracle 不支持直接对嵌套表属性的统计查询功能，即下述的统计查询操作是错误的：</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span>  <span class="keyword">count</span>(e.dependents)</span><br><span class="line"><span class="keyword">from</span>    employees  e </span><br><span class="line"><span class="keyword">where</span>  e.eid = <span class="number">101</span>;</span><br></pre></td></tr></table></figure>
<p><font color = brown size = 4>应为：</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Select</span>  <span class="keyword">count</span>(*)</span><br><span class="line"><span class="keyword">From</span>   <span class="keyword">table</span> (</span><br><span class="line">    <span class="keyword">select</span> e.dependents</span><br><span class="line">    <span class="keyword">from</span> employees e  <span class="keyword">where</span> e.eid = <span class="number">101</span>);</span><br></pre></td></tr></table></figure>
<br/>
</li>
<li>
<p><font color = red size = 4>Oracle 数据库没有提供 nested table 的相等比较运算。</font><br></p>
<p><font color = brown size = 4>可以使用 IN 操作符来实现某些需要通过 nested table 进行的查询功能</font></p>
<br/>
</li>
<li>
<p><font color = red size = 4>Oracle提供了单个对象的相等比较功能</font></p>
<p><font color = blue size = 4>1. Retrieve eids with dependents that have name given by<br>
name_t(‘Lukas’, ‘David’, ‘E’)</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span>  eid  <span class="keyword">from</span>  employees e</span><br><span class="line"><span class="keyword">where</span>  name_t(‘Lukas’, ‘David’, ‘E’) <span class="keyword">in</span> </span><br><span class="line">      ( <span class="keyword">select</span>  d.pname</span><br><span class="line">        <span class="keyword">from</span>  <span class="keyword">table</span>(e.dependents)  d);</span><br></pre></td></tr></table></figure>
<br/>
</li>
<li>
<p><font color = red size = 4>Nested Cursors （嵌套游标）</font><br></p>
<p><font color = brown size = 4>(i) 普通的查询操作</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> e.eid, d.ssno <span class="keyword">as</span> dep_sso</span><br><span class="line"><span class="keyword">from</span> employees e, <span class="keyword">table</span>(e.dependents) d</span><br><span class="line"><span class="keyword">where</span> d.age &lt; <span class="number">16</span>;</span><br></pre></td></tr></table></figure>
<br/>
<p><font color = brown size = 4>(ii) 使用 nested cursor 的查询操作</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> e.eid, <span class="keyword">cursor</span>(<span class="keyword">select</span> d.ssno <span class="keyword">as</span> dep_ssno </span><br><span class="line"><span class="keyword">from</span> <span class="keyword">table</span>(e.dependents) d</span><br><span class="line"><span class="keyword">where</span> d.age &lt; <span class="number">16</span>) dep_tab</span><br><span class="line"><span class="keyword">from</span> employees e;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<br/>
<h4 id="2-Array-Types">2.Array Types</h4>
<p><font color = blue size = 4>1) Array Types for VARRAYs</font></p>
<blockquote>
<p><font color = green size = 4>1. 自定义一个TYPE使用 VARRAY来得到一个数组但只能对基本类型定义。</font></p>
<p><font color = green size = 4>2. VARRAY数据结构可存储相同类型元素的一个固定大小的连续集合。</font><br>
<font color = green size = 4>3. VARRAY用于存储数据的有序集合，但它往往是更加有用认为数组作为相同类型的变量的集合。</font></p>
</blockquote>
<br/>
<ul>
<li><font color = red size = 4>一个VARRAY类型是用CREATE TYPE语句创建。必须指定最大长度，并存储在 VARRAY元素的类型。<br>
PL/SQL 块创建 VRRAY类型的基本语法：</font></li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">TYPE  varray_type_name  IS  VARRAY(n) of &lt;element_type&gt;</span><br></pre></td></tr></table></figure>
<br/>
<blockquote>
<p><font color = blue size = 4>create type extensions_t as varray(<span style="background: linear-gradient(to right, #f2994a, #f2c94c);">4</span>) of <span style="background: linear-gradient(to right, #f2994a, #f2c94c);">int</span>;</font></p>
<p><font color = blue size = 4>使用 Array Types 定义表中的属性</font></p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span>  <span class="keyword">table</span>  phonebook  (</span><br><span class="line">phperson   person_t,</span><br><span class="line">extensions  extensions_t );</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据库基础</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>考研</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>DatabaseNotes-Ch1,2</title>
    <url>/posts/786bf771.html</url>
    <content><![CDATA[<h2 id="Ch1-Introduction">Ch1:  Introduction</h2>
<h2 id="Ch2-The-Rational-Model">Ch2:  The Rational Model</h2>
<h3 id="1-The-CAP-Database">1.The CAP Database</h3>
<h3 id="2-Naming-the-Parts-of-the-Database">2.Naming the Parts of the Database</h3>
<h3 id="3-Rational-Rules">3.Rational Rules:</h3>
<a id="more"></a>
<ol>
<li><strong>First Normal Form Rules</strong></li>
<li><strong>Access Rows By Content Only Rule</strong></li>
<li><strong>The Unique Row Rule</strong></li>
<li><strong>Entity Integrity rule</strong></li>
</ol>
<h3 id="4-Keys-Superkeys-and-Null-values">4.Keys, Superkeys and Null values</h3>
<h3 id="5-Rational-Algebra-关系代数">5.Rational Algebra(关系代数)</h3>
<table>
<thead>
<tr>
<th><font color = red>NAME   </font></th>
<th><font color = red> SYMBOL   </font></th>
<th><font color = red>FORM   </font></th>
<th><font color = red>EXAMPLE   </font></th>
</tr>
</thead>
<tbody>
<tr>
<td>UNION   (并)</td>
<td>∪</td>
<td>UNION</td>
<td>R   ∪ S</td>
</tr>
<tr>
<td>INTERSECTION   (交)</td>
<td>∩</td>
<td>INTERSECT</td>
<td>R   ∩ S</td>
</tr>
<tr>
<td>DIFFERENCE   (差)</td>
<td>—</td>
<td>MINUS</td>
<td>R  —  S</td>
</tr>
<tr>
<td>PRODUCT   (乘积)</td>
<td>$\times$</td>
<td>TIMES</td>
<td>R  $\times$ S</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th><font color = red> NAME   </font></th>
<th><font color = red>SYMBOL   </font></th>
<th><font color = red> FORM   </font></th>
<th><font color = red>EXAMPLE   </font></th>
</tr>
</thead>
<tbody>
<tr>
<td>PROJECT   (投影)</td>
<td>R   [  ]</td>
<td>R   [  ]</td>
<td>R[A~i1~,…,A~ik~]</td>
</tr>
<tr>
<td></td>
<td>$\Pi $</td>
<td></td>
<td>$\Pi$~Ai1,…,Aik~  ®</td>
</tr>
<tr>
<td>SELECT   (选择)</td>
<td>R   where C</td>
<td>R   where C</td>
<td>R   where A~1~=5</td>
</tr>
<tr>
<td></td>
<td>$\sigma$</td>
<td>$\sigma$~c~®</td>
<td>$\sigma$~A1=5~®</td>
</tr>
<tr>
<td>JOIN   (联接)</td>
<td>$\infty$</td>
<td>JOIN</td>
<td>R  $\infty$ S</td>
</tr>
<tr>
<td>DIVISION   (除法)</td>
<td>$\div$</td>
<td>DIVIDEBY</td>
<td>R  $\div$ S</td>
</tr>
</tbody>
</table>
<p><font size = 4 color = purple>Compatible Tables (相容表)</font></p>
<p>表R和表S是相容表，当且仅当，</p>
<p>表R和表S的表头相同，并且对应的列中的数据是相同的类型和相同的语义。</p>
<p><font size = 4 color = purple>Assignment(赋值/取别名)</font></p>
<ol>
<li>
<p>符号：:=</p>
</li>
<li>
<p>将表格R的值赋给(取别名)S: S := R</p>
</li>
<li>
<p>举个栗子：<br>
$$<br>
T1 := (R \cap S)\<br>
T2 := (R \cup S)\<br>
T := T1 – T2<br>
$$</p>
</li>
</ol>
<hr>
<h4 id="1-Set-Theoretic-Operation">1) Set-Theoretic Operation</h4>
<div align="center"><font color = blue size = 4>Union,Intersection,Difference,Product</font></div>
- Example:
<p>$$<br>
R\cup S,\ R\cap S,\ R-S,\ R\times S<br>
$$</p>
<table>
<thead>
<tr>
<th><img data-src="https://image.zxkidea.top/1547706516510.png" alt="zxk"></th>
<th><img data-src="https://image.zxkidea.top/1547706548705.png" alt="zxk"></th>
<th><img data-src="https://image.zxkidea.top/1547707597889.png" alt="zxk"></th>
</tr>
</thead>
<tbody>
<tr>
<td><img data-src="https://image.zxkidea.top/1547707646859.png" alt="zxk"></td>
<td><img data-src="https://image.zxkidea.top/1547707694254.png" alt="zxk"></td>
<td><img data-src="https://image.zxkidea.top/1547707712319.png" alt="zxk"></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th><img data-src="https://image.zxkidea.top/1547708058177.png" alt="zxk"></th>
<th><img data-src="https://image.zxkidea.top/1547708130599.png" alt="zxk"></th>
<th><img data-src="https://image.zxkidea.top/1547708187008.png" alt="zxk"></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p><font size = 4 color = red>Tips:</font></p>
<ul>
<li>Product运算产生的新表列的个数为$C_S + C_R$，新表行的个数为$N_R \times N_S$</li>
</ul>
<hr>
<h4 id="2-Native-Theoretic-Operation">2) Native Theoretic Operation</h4>
<div align="center"><font color = blue size = 4>Project,Select,Join,Division</font></div>
- Example:
<p>$$<br>
R[A_{i1},…A_{ik}],\ R\ where\ A_i=5,\ R\infty S,\ R\div S<br>
$$</p>
<table>
<thead>
<tr>
<th style="text-align:center">(Projection)CN:= C[cname]</th>
<th><img data-src="https://image.zxkidea.top/1547708591736.png" alt="zxk"></th>
<th><img data-src="https://image.zxkidea.top/1547709820322.png" alt="zxk"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>(Selection)T :=CUSTOMERS where city = 'Kyoto’</strong></td>
<td><img data-src="https://image.zxkidea.top/1547710588795.png" alt="zxk"></td>
<td><img data-src="https://image.zxkidea.top/1547710757123.png" alt="zxk"></td>
</tr>
<tr>
<td style="text-align:center"><strong>(Selection)Pairs:=(L$\times$ M)  where L.city=M.city</strong></td>
<td><img data-src="https://image.zxkidea.top/1547711394006.png" alt="zxk"></td>
<td><img data-src="https://image.zxkidea.top/1547711610818.png" alt="zxk" style="zoom: 150%;" /></td>
</tr>
<tr>
<td style="text-align:center"><strong>Join($R\infty S$)</strong></td>
<td><img data-src="https://image.zxkidea.top/1547712009184.png" alt="zxk"></td>
<td><img data-src="https://image.zxkidea.top/1547712143439.png" alt="zxk"></td>
</tr>
<tr>
<td style="text-align:center"><strong>Division($R\div S$)</strong></td>
<td><img data-src="https://image.zxkidea.top/1547775339292.png" alt="zxk"></td>
<td><img data-src="https://image.zxkidea.top/1547775604826.png" alt="zxk"></td>
</tr>
</tbody>
</table>
<p><font size = 4 color = red>关系代数运算的优先级：</font></p>
<table>
<thead>
<tr>
<th>Precedence（优先级）</th>
<th>Operators(运算符)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Highest</td>
<td>PROJECT</td>
</tr>
<tr>
<td>…</td>
<td>SELECT</td>
</tr>
<tr>
<td>…</td>
<td>PRODUCT</td>
</tr>
<tr>
<td>…</td>
<td>JOIN,   DIVIDEBY</td>
</tr>
<tr>
<td>…</td>
<td>INTERSECTION</td>
</tr>
<tr>
<td>Lowest</td>
<td>UNION,   DIFFERENCE</td>
</tr>
</tbody>
</table>
<hr>
<h4 id="3-Complex-Query">3) Complex Query</h4>
<p><img data-src="https://image.zxkidea.top/databasenote1.png" alt="zxk"></p>
<p><font size = 4 color = blue>1. Find cname and city of customers and aname of agents that the customer lives in the same city with agents.</font></p>
<blockquote>
<p>((C$\times$A) where C.city=A.city)[C.cname,C.city,A.aname]</p>
<p>相当于</p>
<p>(C$\infty$ A)[C.cname,C.city,A.aname]</p>
</blockquote>
<p><font size = 4 color = blue>2. Find pid, month and qty of order whose customer’s name is ‘Allied’.</font></p>
<blockquote>
<p>((C$\times$O) where C.cid=O.cid and C.cname=‘Allied’)[O.pid,O.month,O.qty]</p>
<p>or</p>
<p>( ( ( (C where cname = ‘Allied’) [cid] ) x O ) where C.cid = O.cid ) [ O.pid, O.month, O.qty ]</p>
<p>相当于</p>
<p>((C$\infty$O)where C.cname=‘Allied’)[O.pid,O.month,O.qty]</p>
</blockquote>
<p><font size = 4 color = blue>3. Find ordno of orders for customer, agent and product combinations that are all in the same city.</font></p>
<blockquote>
<p>( (C [ cid, city ] x A [ aid, city ] x P [ pid, city ] x O)</p>
<p>where C.city = A.city and P.city = A.city and</p>
<p>C.cid = O.cid and A.aid = O.aid and P.pid = O.pid )</p>
<p>[ O.ordno ]</p>
<p>相当于</p>
<p>(C$\infty$ O$\infty$ P$\infty$ A)[O.ordno]</p>
</blockquote>
<br/>
<br/>
<p><img data-src="https://image.zxkidea.top/databasenote2.png" alt="zxk"></p>
<p><font size = 4 color = blue>4. Find cid of customers who have a <font color = black size = 5>highest </font>discount in all customers.</font></p>
<blockquote>
<p><font color=red size=6>Step 1:</font> Find all cids of customers</p>
<p><font color=red size=5>R1 := C[pid]</font></p>
<p><font color=red size=6>Step 2:</font> Find cid of customers whose discount less than another customer. Let <font color = green size = 5>S := C</font>, then</p>
<p><font color=red size=5>R2: = ((CxS) where C.discnt&lt;S.discnt)[C.cid]</font></p>
<p><font color=red size =6>Step 3:</font>  calculate the result of this query by DIFFERENCE operation.</p>
<p><font color=red size=5>T := R1 - R2</font></p>
</blockquote>
<p><font color = blue size = 4>注意：除法法则：</font></p>
<p><strong>if  R = T $ \times $ S, then</strong></p>
<p><strong>T = R $\div$ S</strong></p>
<p><strong>S = R $\div$ T</strong></p>
<p><strong>if T = R $\div$ S，then</strong></p>
<p><strong>T $\times$ S $\subseteq$ R</strong></p>
<ul>
<li><font color = green>举个栗子：</font></li>
</ul>
<p><img data-src="https://image.zxkidea.top/databasenote3.png" alt="zxk"></p>
<hr>
<h4 id="4-Native-Relational-Operation">4) Native Relational Operation</h4>
<p><font color=green size=5>Questions:</font></p>
<p><font color = blue size = 4>1. Get cids of customers who order  products  p01 ?</font></p>
<blockquote>
<p><font color=red size=5>(O  where pid=‘p01’) [ cid ]</font></p>
</blockquote>
<p><font color = blue size = 4>2. Get cids of customers who order  <font size = 5 color = black>products  p01 and p02 ?</font></font></p>
<blockquote>
<p><font color=red size=5>(O  where pid=‘p01’)[cid] $\cap$ (O  where pid=‘p02’)[cid]</font></p>
</blockquote>
<p><font color = blue size = 4>3. Get cnames of customers who order <font color = black size = 5>all products</font> ?</font></p>
<blockquote>
<p><font color = green>//出现求ALL(所有一类属性)的记录时，需要使用除法运算</font></p>
<p><font color=red size=5>First:</font>  get cids of customers who orders all products</p>
<p><font color=red size=5>T := ORDERS[cid , pid] $\div$ PRODUCTS[pid]</font></p>
</blockquote>
<blockquote>
<p><font color = blue size = 4><font color=red>注意：</font>//使用除法运算时，Dividend(被除数)中的属性经过除法运算后剩余属性也需要是候选键性质</font></p>
<p><font color=brown size = 5>1.Why must project PRODUCTS on pid ?</font></p>
<ul>
<li><font color = green size=5>columns of divisor must be subset of columns of dividend.</font></li>
</ul>
<p><font color=brown size=5>Why must project ORDERS on cid,pid?</font></p>
<ul>
<li><font color = green size = 5>We only try to find the value of the cid in ORDERS of the same for all cid.</font></li>
</ul>
</blockquote>
<blockquote>
<p><font color=red size=5>Second:</font> get names of customers</p>
<p><font color = red size = 5>T1 := ( ( T ) $\infty$ C ) [cname]</font></p>
</blockquote>
<p><font color = blue size = 4>4. Get names of customers who order  all products ordered by customer ‘c006’ ?</font></p>
<blockquote>
<p><font color=red size=5>Step 1:</font>  find all products ordered by customer ‘c006’</p>
<p><font color=red size=5>R1 := (ORDERS where cid = ‘c006’)[pid]</font></p>
<p><font color=red size = 5>Step 2:</font>  find cid of customers who order all products ordered by customer ‘c006’</p>
<p><font color=red size=5>R2 := ORDERS[cid,pid] $\div$R1</font></p>
<p><font color=red size = 5>Step 3:</font>  find cnames of customers</p>
<p><font color=red size=5>R3 := ( R2 $\infty$ C ) [ cname ]</font></p>
</blockquote>
<p><font color = blue size = 4>5. Get pid of products ordered through all agents ?</font></p>
<blockquote>
<p><font color=red size=5>ORDERS [ aid, pid ] $\div$ AGENTS [ aid ]</font></p>
</blockquote>
<p><font color = blue size = 4>6. Get name of products ordered by all customers who live in Dallas ?</font></p>
<blockquote>
<p><font color=red size=5>R1 := (CUSTOMERS where city=‘Dallas’)[cid]</font></p>
<p><font color =red size=5>R2 := ORDERS [ cid, pid ] $\div$ R1</font></p>
<p><font color = red size = 5>R3 := ( PRODUCTS $\infty$ R2 )[ pname ]</font></p>
</blockquote>
<p><font color = blue size = 4>7. Get cids of customers who order all products priced at $0.50.</font></p>
<blockquote>
<p><font color = red size = 5>R1 := (PRODUCTS where price = 0.50) [pid]</font></p>
<p><font color = red size = 5>R2 := ORDERS [ cid, pid ] $\div$ R1</font></p>
</blockquote>
<p><font color = blue size = 4>8. Get cids of customers who order all products that <font color = black size = 5>anybody</font> orders.</font></p>
<blockquote>
<p><font color = red size = 5>ORDERS [ cid, pid ] $\div$ ORDERS [ pid ]</font></p>
</blockquote>
<br/>
<br/>
<blockquote>
<p><font color = green size = 5>条件：</font></p>
<p><font color = green size = 5>Customers: C(cid, cname, city, discnt)</font></p>
<p><font color = green size = 5>Agents: A(aid, aname, city, percent)</font></p>
<p><font color = green size = 5>Products: P(pid, pname, city, quantity, price)</font></p>
<p><font color = green size = 5>Orders: O(ordno, month, cid, aid, pid, qty, dollars)</font></p>
</blockquote>
<p><font color = blue size = 4>9. Get aids of agents who take orders on <font color = black size = 5>at least that set of products(相当于all the products)</font> ordered by c004.</font></p>
<blockquote>
<p><font color = red size = 5>O[aid, pid] ÷ (O where cid = ‘c004’)[pid]</font></p>
</blockquote>
<p><font color = blue size = 4>10. Get cids of customers who order p01 and p07.</font></p>
<blockquote>
<p><font color = red size = 5>(O where pid = ‘p01’)[cid] $\cap$ (O where pid = ‘p07’)[cid]</font><font color = red size = 5>(正确)</font></p>
<p><font color = grey size = 5>(O where pid = ‘p01’ and pid = ‘p07’)[cid]</font><font color  = grey size = 5>(错误)</font></p>
</blockquote>
<p><font color = blue size = 4>11. Get cids of customers who order p01 or p07.</font></p>
<blockquote>
<p><font color = red size = 5>(O where pid=‘p01’)[cid] $\cup$ (O where pid=‘p07’)[cid]</font></p>
<p><font color = green size = 4>或者</font></p>
<p><font color = red size = 5>(O where pid = ‘p01’ or pid = ‘p07’)[cid]</font></p>
</blockquote>
<p><font color = blue size = 4>12. List all cities inhabited by customers who order product p02 or agents who place an order for p02.</font></p>
<blockquote>
<p><font color = red size = 5>T1 := ((O where pid = ‘p02’) $\infty$ C)[city]</font></p>
<p><font color = red size = 5>T2 := ((O where pid = ‘p02’) $\infty$  A)[city]</font></p>
<p><font color = red size = 5>T := T1 $\cup$ T2</font></p>
</blockquote>
<p><font color = blue size = 4>13. Get aids of agents who place an order for <font color = black size = 5>at least one customer</font> that uses product p01.</font></p>
<blockquote>
<p><font color = red size = 5>((O where pid = ‘p01’)[cid] $\infty$ O) [aid]</font></p>
</blockquote>
<p><font color = blue size = 4>14. Get aids of agents who place orders for <font color = black size = 5>all customers</font> that uses product p01.</font></p>
<blockquote>
<p><font color = red size = 5>O[cid, aid] ÷ (O where pid =  ‘p01’)[cid]</font></p>
</blockquote>
<p><font color = blue size = 4>15. Retrieve product ids for all products that are <font color = black size = 5>not ordered by</font> any customers living in a city <font color = black size = 5>beginning with the letter “D”</font>.</font></p>
<blockquote>
<p><font color = red size = 5>T1  :=  C where <u>C.city &gt;= ‘D’ and C.city &lt; ‘E’</u></font></p>
<p><font color = red size = 5>T2  :=  P [ pid ] - ( O $\infty$ T1 ) [ pid ]</font></p>
</blockquote>
<br/>
<br/>
<blockquote>
<p><font color = green size = 5>条件：</font></p>
<p><font color = green size = 5>Customers: C(cid, cname, city, discnt)</font></p>
</blockquote>
<p><font color = blue size = 4>16. Retrieve cids of customers with the <font color = black size = 5>largest</font> discounts.</font></p>
<blockquote>
<p><font color = green size = 5>Answer 1:</font></p>
<p><font color = red size = 5>1)CY := C</font></p>
<p><font color = red size = 5>2)T1:=((CY $\times$ C) where <u>CY.discnt &gt; C.discnt</u>)[C.cid]</font></p>
<p><font color = red size = 5>3)T2 := C[cid] - T1</font></p>
</blockquote>
<blockquote>
<p><font color = green size  = 5>Answer 2:</font></p>
<p><font color = red size = 5>1)CY := C</font></p>
<p><font color = red size = 5>2)T1(cyid, cid) := ((CY $\times$ C) where <u>CY.discnt &gt;= C.discnt</u>) [CY.cid, C.cid]</font></p>
<p><font color = red size = 5>3)T2 := T1 ÷ C[cid]</font></p>
</blockquote>
<br/>
<br/>
<blockquote>
<p><font color = green size = 5>条件：</font></p>
<p><font color = green size = 5>Customers: C(cid, cname, city, discnt)</font><br>
<font color = green size = 5>Agents: A(aid, aname, city, percent)</font><br>
<font color = green size = 5>Products: P(pid, pname, city, quantity, price)</font><br>
<font color = green size = 5>Orders: O(ordno, month, cid, aid, pid, qty, dollars)</font></p>
</blockquote>
<p><font color = blue size = 4>17. Get aids of agents who <font color = black size = 5>do not supply</font> product p02. </font></p>
<blockquote>
<p><font color = red size = 5>A[aid]  —  (O where pid = ‘p02’)[aid]</font></p>
</blockquote>
<p><font color = blue size = 4>18. Get aids of agents who <font color = black size = 5>supply only</font> product p02.</font></p>
<blockquote>
<p><font color = red size = 5>O[aid]  —  (O where pid &lt;&gt; ‘p02’)[aid]</font><font color = red size = 5>  (正确)</font><br>
<font color = grey size = 5>A[aid]  —  (O where pid &lt;&gt; ‘p02’)[aid]</font><font color = grey size = 5>  (错误)</font></p>
</blockquote>
<hr>
<h4 id="5-Illustrative-Examples-示例">5) Illustrative Examples(示例)</h4>
<blockquote>
<p><font color = green size = 5>条件：</font></p>
<p><font color = green size = 5>Customers: C(cid, cname, city, discnt)</font></p>
<p><font color = green size = 5>Agents: A(aid, aname, city, percent)</font></p>
<p><font color = green size = 5>Products: P(pid, pname, city, quantity, price)</font></p>
<p><font color = green size = 5>Orders: O(ordno, month, cid, aid, pid, qty, dollars)</font></p>
</blockquote>
<p><font color = blue size = 4>1.Get the names of customers who order <font color = black size = 5>at least one product</font> priced at $0.50.</font></p>
<blockquote>
<p><font color = red size = 5>(((P where price=0.50)[pid] $\infty$ O) $\infty$ C) [cname]</font></p>
</blockquote>
<p><font color = blue size = 4>2.Find cids of all customers who <font color = black size = 5>don’t place</font> any order through agent a03.</font></p>
<blockquote>
<p><font color = red size = 5>C[cid] – (O where aid = ‘a03’) [cid]</font></p>
<p><font color = green size = 5>而不是O[cid] – (O where aid = ‘a03’) [cid]</font></p>
</blockquote>
<p><font color = blue size = 4>3.Retrieve customers who place orders <font color = black size = 5>only through</font> agent a03.</font></p>
<blockquote>
<p><font color = red size = 5>O[cid] – (O where aid $\neq$ ‘a03’) [cid]</font></p>
<p><font color = green size = 5>而不是C[cid] – (O where aid $\neq$ ‘a03’) [cid]</font></p>
</blockquote>
<p><font color = blue size = 4>4.More Complex One <font color = red><u>(Question And Steps)</u></font>:</font></p>
<br/>
<p><img data-src="https://image.zxkidea.top/databasenote4.png" alt="zxk"></p>
]]></content>
      <categories>
        <category>数据库基础</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>考研</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>五大经典算法分析</title>
    <url>/posts/31d96ab6.html</url>
    <content><![CDATA[<p>转载自：五大经典算法分析   <a href="https://www.cnblogs.com/parzulpan/p/9919208.html" target="_blank" rel="noopener">https://www.cnblogs.com/parzulpan/p/9919208.html</a></p>
<hr>
<h1>分治算法</h1>
<p><font size = 5>1. 基本概念</font></p>
<p>在计算机科学中，分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)……</p>
<p>任何一个可以用计算机求解的问题所需的计算时间都与其规模有关。问题的规模越小，越容易直接求解，解题所需的计算时间也越少。例如，对于n个元素的排序问题，当n=1时，不需任何计算。n=2时，只要作一次比较即可排好序。n=3时只要作3次比较即可，…。而当n较大时，问题就不那么容易处理了。要想直接解决一个规模较大的问题，有时是相当困难的。</p>
<a id="more"></a>
<hr>
<p><font size = 5>2. 基本思想及策略</font></p>
<p>分治法的设计思想是：将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。</p>
<p>分治策略是：对于一个规模为n的问题，若该问题可以容易地解决（比如说规模n较小）则直接解决，否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解。这种算法设计策略叫做分治法。</p>
<p>如果原问题可分割成k个子问题，1&lt;k≤n，且这些子问题都可解并可利用这些子问题的解求出原问题的解，那么这种分治法就是可行的。由分治法产生的子问题往往是原问题的较小模式，这就为使用递归技术提供了方便。在这种情况下，反复应用分治手段，可以使子问题与原问题类型一致而其规模却不断缩小，最终使子问题缩小到很容易直接求出其解。这自然导致递归过程的产生。分治与递归像一对孪生兄弟，经常同时应用在算法设计之中，并由此产生许多高效算法。</p>
<hr>
<p><font size = 5>3. 分治法适用的情况</font></p>
<p>​    分治法所能解决的问题一般具有以下几个特征：</p>
<p>​    1) 该问题的规模缩小到一定的程度就可以容易地解决</p>
<p>​    2) 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。</p>
<p>​    3) 利用该问题分解出的子问题的解可以合并为该问题的解；</p>
<p>​    4) 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。</p>
<p>第一条特征是绝大多数问题都可以满足的，因为问题的计算复杂性一般是随着问题规模的增加而增加；</p>
<p><strong>第二条特征是应用分治法的前提</strong>它也是大多数问题可以满足的，此特征反映了递归思想的应用；、</p>
<p><strong>第三条特征是关键，能否利用分治法完全取决于问题是否具有第三条特征</strong>，如果<strong>具备了第一条和第二条特征，而不具备第三条特征，则可以考虑用贪心法或动态规划法</strong>。</p>
<p><strong>第四条特征涉及到分治法的效率</strong>，如果各子问题是不独立的则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然可用分治法，但<strong>一般用动态规划法较好</strong>。</p>
<hr>
<p><font size = 5>4. 分治法的基本步骤</font></p>
<p>分治法在每一层递归上都有三个步骤：</p>
<p>​    step1 分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题；</p>
<p>​    step2 解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题</p>
<p>​    step3 合并：将各个子问题的解合并为原问题的解。</p>
<p>它的一般的算法设计模式如下：</p>
<p>​    Divide-and-Conquer§</p>
<p>​    1. if |P|≤n0</p>
<p>​    2. then return(ADHOC§)</p>
<p>​    3. 将P分解为较小的子问题 P1 ,P2 ,…,Pk</p>
<p>​    4. for i←1 to k</p>
<p>​    5. do yi ← Divide-and-Conquer(Pi) △ 递归解决Pi</p>
<p>​    6. T ← MERGE(y1,y2,…,yk) △ 合并子问题</p>
<p>​    7. return(T)</p>
<p>​    其中|P|表示问题P的规模；n0为一阈值，表示当问题P的规模不超过n0时，问题已容易直接解出，不必再继续分解。ADHOC§是该分治法中的基本子算法，用于直接解小规模的问题P。因此，当P的规模不超过n0时直接用算法ADHOC§求解。算法MERGE(y1,y2,…,yk)是该分治法中的合并子算法，用于将P的子问题P1 ,P2 ,…,Pk的相应的解y1,y2,…,yk合并为P的解。</p>
<hr>
<p><font size = 5>5. 分治法的复杂性分析</font></p>
<p>​    一个分治法将规模为n的问题分成k个规模为n／m的子问题去解。设分解阀值n0=1，且adhoc解规模为1的问题耗费1个单位时间。再设将原问题分解为k个子问题以及用merge将k个子问题的解合并为原问题的解需用f(n)个单位时间。用T(n)表示该分治法解规模为|P|=n的问题所需的计算时间，则有：</p>
<p>T（n）= k T(n/m)+f(n)</p>
<p>​    通过迭代法求得方程的解：</p>
<p>​    <strong>递归方程及其解只给出n等于m的方幂时T(n)的值，但是如果认为T(n)足够平滑，那么由n等于m的方幂时T(n)的值可以估计T(n)的增长速度。通常假定T(n)是单调上升的，从而当mi≤n&lt;mi+1时，T(mi)≤T(n)&lt;T(mi+1)。</strong></p>
<hr>
<p><font size = 5>6. 可使用分治法求解的一些经典问题</font></p>
<p>（1）二分搜索</p>
<p>（2）大整数乘法</p>
<p>（3）Strassen矩阵乘法</p>
<p>（4）棋盘覆盖</p>
<p>（5）合并排序</p>
<p>（6）快速排序</p>
<p>（7）线性时间选择</p>
<p>（8）最接近点对问题</p>
<p>（9）循环赛日程表</p>
<p>（10）汉诺塔</p>
<hr>
<p><font size = 5>7. 依据分治法设计程序时的思维过程</font></p>
<p><strong>实际上就是类似于数学归纳法，找到解决本问题的求解方程公式，然后根据方程公式设计递归程序。</strong></p>
<p><strong>1、一定是先找到最小问题规模时的求解方法</strong></p>
<p><strong>2、然后考虑随着问题规模增大时的求解方法</strong></p>
<p><strong>3、找到求解的递归函数式后（各种规模或因子），设计递归程序即可。</strong></p>
<hr>
<h1>动态规划算法</h1>
<p><font size = 5>1. 基本概念</font></p>
<p>​    动态规划过程是：每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划。</p>
<p><font size = 5>2. 基本思想与策略</font></p>
<p>​    基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。</p>
<p>​    由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中。</p>
<p>​    与分治法最大的差别是：适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）。</p>
<hr>
<p><font size = 5>3. 适用的情况</font></p>
<p>能采用动态规划求解的问题的一般要具有3个性质：</p>
<p>​    (1) 最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。</p>
<p>​    (2) 无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。</p>
<p>（3）有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）</p>
<hr>
<p><font size = 5>4. 求解的基本步骤</font></p>
<p>​     动态规划所处理的问题是一个多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态。这些决策形成了一个决策序列，同时确定了完成整个过程的一条活动路线(通常是求最优的活动路线)。如图所示。动态规划的设计都有着一定的模式，一般要经历以下几个步骤。</p>
<p>​    初始状态→│决策１│→│决策２│→…→│决策ｎ│→结束状态</p>
<p>​                      图1 动态规划决策过程示意图</p>
<p>​    (1)<strong>划分阶段</strong>：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。</p>
<p>​    (2)<strong>确定状态和状态变量</strong>：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。</p>
<p>​    (3)<strong>确定决策并写出状态转移方程</strong>：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。</p>
<p>​    (4)<strong>寻找边界条件</strong>：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。</p>
<p>​    一般，只要解决问题的阶段、状态和状态转移决策确定了，就可以写出状态转移方程（包括边界条件）。</p>
<p>实际应用中可以按以下几个简化的步骤进行设计：</p>
<p>​    （1）分析最优解的性质，并刻画其结构特征。</p>
<p>​    （2）递归的定义最优解。</p>
<p>​    （3）以自底向上或自顶向下的记忆化方式（备忘录法）计算出最优值</p>
<p>​    （4）根据计算最优值时得到的信息，构造问题的最优解</p>
<hr>
<p><font size = 5>5. 算法实现的说明</font></p>
<p>​    动态规划的主要难点在于理论上的设计，也就是上面4个步骤的确定，一旦设计完成，实现部分就会非常简单。</p>
<p>​     使用动态规划求解问题，最重要的就是确定动态规划三要素：</p>
<p>​    （1）问题的阶段 （2）每个阶段的状态</p>
<p>​    （3）从前一个阶段转化到后一个阶段之间的递推关系。</p>
<p>​     递推关系必须是从次小的问题开始到较大的问题之间的转化，从这个角度来说，动态规划往往可以用递归程序来实现，不过因为递推可以充分利用前面保存的子问题的解来减少重复计算，所以对于大规模问题来说，有递归不可比拟的优势，这也是动态规划算法的核心之处。</p>
<p>​    确定了动态规划的这三要素，整个求解过程就可以用一个最优决策表来描述，最优决策表是一个二维表，其中行表示决策的阶段，列表示问题状态，表格需要填写的数据一般对应此问题的在某个阶段某个状态下的最优值（如最短路径，最长公共子序列，最大价值等），填表的过程就是根据递推关系，从1行1列开始，以行或者列优先的顺序，依次填写表格，最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解。</p>
<p>​          <strong>f(n,m)=max{f(n-1,m), f(n-1,m-w[n])+P(n,m)}</strong></p>
<hr>
<p><font size = 5>6. 动态规划算法基本框架</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;=m; j=j+<span class="number">1</span>) <span class="comment">// 第一个阶段</span></span><br><span class="line">   xn[j] = 初始值;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span>(i=n-<span class="number">1</span>; i&gt;=<span class="number">1</span>; i=i-<span class="number">1</span>)<span class="comment">// 其他n-1个阶段</span></span><br><span class="line">   <span class="keyword">for</span>(j=<span class="number">1</span>; j&gt;=f(i); j=j+<span class="number">1</span>)<span class="comment">//f(i)与i有关的表达式</span></span><br><span class="line">     xi[j]=j=max（或min）&#123;g(xi-<span class="number">1</span>[j1:j2]), ......, g(xi-<span class="number">1</span>[jk:jk+<span class="number">1</span>])&#125;;</span><br><span class="line"></span><br><span class="line">t = g(x1[j1:j2]); <span class="comment">// 由子问题的最优解求解整个问题的最优解的方案</span></span><br><span class="line"></span><br><span class="line">print(x1[j1]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">2</span>; i&lt;=n-<span class="number">1</span>; i=i+<span class="number">1</span>）</span><br><span class="line">&#123;  </span><br><span class="line">     t = t-xi-<span class="number">1</span>[ji];</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span>(j=<span class="number">1</span>; j&gt;=f(i); j=j+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span>(t=xi[ji])</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1>贪心算法</h1>
<p><font size = 5>1. 基本概念：</font></p>
<p>​     所谓贪心算法是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解。</p>
<p>​     贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效性，即某个状态以后的过程不会影响以前的状态，只与当前状态有关。</p>
<p>​    所以对所采用的贪心策略一定要仔细分析其是否满足无后效性。</p>
<hr>
<p><font size = 5>2. 贪心算法的基本思路：</font></p>
<p>​    1.建立数学模型来描述问题。</p>
<p>​    2.把求解的问题分成若干个子问题。</p>
<p>​    3.对每一子问题求解，得到子问题的局部最优解。</p>
<p>​    4.把子问题的解局部最优解合成原来解问题的一个解。</p>
<hr>
<p><font size = 5>3. 贪心算法适用的问题</font></p>
<p>​      <strong>贪心策略适用的前提是：局部最优策略能导致产生全局最优解。</strong></p>
<p>​    <strong>实际上，贪心算法适用的情况很少。一般，对一个问题分析是否适用于贪心算法，可以先选择该问题下的几个实际数据进行分析，就可做出判断。</strong></p>
<hr>
<p><font size = 5>4. 贪心算法的实现框架</font></p>
<p>​    从问题的某一初始解出发；</p>
<p>​    while （能朝给定总目标前进一步）</p>
<p>​    {</p>
<p>​          利用可行的决策，求出可行解的一个解元素；</p>
<p>​    }</p>
<p>​    由所有解元素组合成问题的一个可行解；</p>
<hr>
<p><font size = 5>5. 贪心策略的选择</font></p>
<p>​     因为用贪心算法只能通过解局部最优解的策略来达到全局最优解，因此，一定要注意判断问题是否适合采用贪心算法策略，找到的解是否一定是问题的最优解。</p>
<hr>
<p><font size = 5>6. 例题分析</font></p>
<p>​    下面是一个可以试用贪心算法解的题目，贪心解的确不错，可惜不是最优解。</p>
<p>​    [背包问题]有一个背包，背包容量是M=150。有7个物品，物品可以分割成任意大小。</p>
<p>​    要求尽可能让装入背包中的物品总价值最大，但不能超过总容量。</p>
<p>​    物品 A B C D E F G</p>
<p>​    重量 35 30 60 50 40 10 25</p>
<p>​    价值 10 40 30 50 35 40 30</p>
<p>​    分析：</p>
<p>​    目标函数： ∑pi最大</p>
<p>​    约束条件是装入的物品总重量不超过背包容量：∑wi&lt;=M( M=150)</p>
<p>​    （1）根据贪心的策略，每次挑选价值最大的物品装入背包，得到的结果是否最优？</p>
<p>​    （2）每次挑选所占重量最小的物品装入是否能得到最优解？</p>
<p>​    （3）每次选取单位重量价值最大的物品，成为解本题的策略。</p>
<p>​    值得注意的是，贪心算法并不是完全不可以使用，贪心策略一旦经过证明成立后，它就是一种高效的算法。</p>
<p>​    贪心算法还是很常见的算法之一，这是由于它简单易行，构造贪心策略不是很困难。</p>
<p>​    可惜的是，它需要证明后才能真正运用到题目的算法中。</p>
<p>​    一般来说，贪心算法的证明围绕着：整个问题的最优解一定由在贪心策略中存在的子问题的最优解得来的。</p>
<p>​    对于例题中的3种贪心策略，都是无法成立（无法被证明）的，解释如下：</p>
<p>​    （1）贪心策略：选取价值最大者。反例：</p>
<p>​    W=30</p>
<p>​    物品：A B C</p>
<p>​    重量：28 12 12</p>
<p>​    价值：30 20 20</p>
<p>​    根据策略，首先选取物品A，接下来就无法再选取了，可是，选取B、C则更好。</p>
<p>​    （2）贪心策略：选取重量最小。它的反例与第一种策略的反例差不多。</p>
<p>​    （3）贪心策略：选取单位重量价值最大的物品。反例：</p>
<p>​    W=30</p>
<p>​    物品：A B C</p>
<p>​    重量：28 20 10</p>
<p>​    价值：28 20 10</p>
<p>​    根据策略，三种物品单位重量价值一样，程序无法依据现有策略作出判断，如果选择A，则答案错误。</p>
<hr>
<h1>回溯法</h1>
<p><font size = 5>1. 概念</font></p>
<p>​      回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。</p>
<p>回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。</p>
<p>​     许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。</p>
<hr>
<p><font size = 5>2. 基本思想</font></p>
<p>在包含问题的所有解的解空间树中，按照<strong>深度优先搜索的策略</strong>，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯。（其实回溯法就是对隐式图的深度优先搜索算法）。</p>
<p>​       若用回溯法求问题的所有解时，要回溯到根，且根结点的所有可行的子树都要已被搜索遍才结束。</p>
<p>​       而若使用回溯法求任一个解时，只要搜索到问题的一个解就可以结束。</p>
<hr>
<p><font size = 5>3. 用回溯法解题的一般步骤：</font></p>
<p>​    （1）针对所给问题，确定问题的解空间：</p>
<p>​            首先应明确定义问题的解空间，问题的解空间应至少包含问题的一个（最优）解。</p>
<p>​    （2）确定结点的扩展搜索规则</p>
<p>​    （3）以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。</p>
<hr>
<p><font size = 5>4. 算法框架</font></p>
<p>​     （1）问题框架</p>
<p>​      设问题的解是一个n维向量(a1,a2,………,an),约束条件是ai(i=1,2,3,……,n)之间满足某种条件，记为f(ai)。</p>
<p>​     （2）非递归回溯框架</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[n],i;</span><br><span class="line">初始化数组a[];</span><br><span class="line">i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i&gt;<span class="number">0</span>(有路可走)   and  (未达到目标))  <span class="comment">// 还未回溯到头</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(i &gt; n)                                              <span class="comment">// 搜索到叶结点</span></span><br><span class="line">     &#123;   </span><br><span class="line">           搜索到一个解，输出；</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span>                                                   <span class="comment">// 处理第i个元素</span></span><br><span class="line">     &#123; </span><br><span class="line">           a[i]第一个可能的值；</span><br><span class="line">           <span class="keyword">while</span>(a[i]在不满足约束条件且在搜索空间内)</span><br><span class="line">           &#123;</span><br><span class="line">               a[i]下一个可能的值；</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(a[i]在搜索空间内)</span><br><span class="line">          &#123;</span><br><span class="line">               标识占用的资源；</span><br><span class="line">               i = i+<span class="number">1</span>;                              <span class="comment">// 扩展下一个结点</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> </span><br><span class="line">         &#123;</span><br><span class="line">               清理所占的状态空间；            <span class="comment">// 回溯</span></span><br><span class="line">               i = i –<span class="number">1</span>; </span><br><span class="line">          &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>3）递归的算法框架</p>
<p>​         回溯法是对解空间的深度优先搜索，在一般情况下使用递归函数来实现回溯法比较简单，其中i为搜索的深度，框架如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[n];</span><br><span class="line"><span class="keyword">try</span>(<span class="keyword">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;n)</span><br><span class="line">       输出结果;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">for</span>(j = 下界; j &lt;= 上界; j=j+<span class="number">1</span>)  <span class="comment">// 枚举i所有可能的路径</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span>(fun(j))                 <span class="comment">// 满足限界函数和约束条件</span></span><br><span class="line">             &#123;</span><br><span class="line">                a[i] = j;</span><br><span class="line">              ...                         <span class="comment">// 其他操作</span></span><br><span class="line">                <span class="keyword">try</span>(i+<span class="number">1</span>);</span><br><span class="line">              回溯前的清理工作（如a[i]置空值等）;</span><br><span class="line">              &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1>分支限界法</h1>
<p><font size = 5>1. 基本描述</font></p>
<p>​    类似于回溯法，也是一种在问题的解空间树T上搜索问题解的算法。但在一般情况下，分支限界法与回溯法的求解目标不同。<strong>回溯法的求解目标是找出T中满足约束条件的所有解</strong>，而<strong>分支限界法</strong>的求解目标则是找出<strong>满足约束条件的一个解</strong>，或是在满足约束条件的解中找出使某一目标函数值达到<strong>极大或极小的解</strong>，即在某种意义下的<strong>最优解</strong>。</p>
<p><strong>（1）分支搜索算法</strong></p>
<p>​    所谓“分支”就是采用广度优先的策略，依次搜索E-结点的所有分支，也就是所有相邻结点，抛弃不满足约束条件的结点，其余结点加入活结点表。然后从表中选择一个结点作为下一个E-结点，继续搜索。</p>
<p>​     选择下一个E-结点的方式不同，则会有几种不同的分支搜索方式。</p>
<p>1）FIFO搜索</p>
<p>2）LIFO搜索</p>
<p>3）优先队列式搜索</p>
<p><strong>（2）分支限界搜索算法</strong></p>
<hr>
<p><font size = 5>2. 分支限界法的一般过程</font></p>
<p>​    由于求解目标不同，导致分支限界法与回溯法在解空间树T上的搜索方式也不相同。<strong>回溯法以深度优先的方式搜索解空间树T</strong>，而<strong>分支限界法则以广度优先或以最小耗费优先的方式搜索解空间树T</strong>。</p>
<p>​    分支限界法的<strong>搜索策略是</strong>：在扩展结点处，先生成其所有的儿子结点（分支），然后再从当前的活结点表中选择下一个扩展对点。为了有效地选择下一扩展结点，以加速搜索的进程，在每一活结点处，计算一个函数值（限界），并根据这些已计算出的函数值，从当前活结点表中选择一个最有利的结点作为扩展结点，使搜索朝着解空间树上有最优解的分支推进，以便尽快地找出一个最优解。</p>
<p>​    分支限界法常以广度优先或以最小耗费（最大效益）优先的方式搜索问题的解空间树。问题的<strong>解空间树是表示问题解空间的一棵有序树，常见的有子集树和排列树</strong>。在搜索问题的解空间树时，分支限界法与回溯法对当前扩展结点所使用的扩展方式不同。在分支限界法中，每一个活结点只有一次机会成为扩展结点。活结点一旦成为扩展结点，就一次性产生其所有儿子结点。在这些儿子结点中，那些导致不可行解或导致非最优解的儿子结点被舍弃，其余儿子结点被子加入活结点表中。此后，从活结点表中取下一结点成为当前扩展结点，并重复上述结点扩展过程。这个过程一直持续到找到所求的解或活结点表为空时为止。</p>
<hr>
<p><font size = 5>3. 回溯法和分支限界法的一些区别</font></p>
<p>​    有一些问题其实无论用回溯法还是分支限界法都可以得到很好的解决，但是另外一些则不然。也许我们需要具体一些的分析——到底何时使用分支限界而何时使用回溯呢？</p>
<p>回溯法和分支限界法的一些区别：</p>
<p>方法对解空间树的搜索方式       存储结点的常用数据结构      结点存储特性常用应用</p>
<p>回溯法深度优先搜索堆栈活结点的所有可行子结点被遍历后才被从栈中弹出找出满足约束条件的所有解</p>
<p>分支限界法广度优先或最小消耗优先搜索队列、优先队列每个结点只有一次成为活结点的机会找出满足约束条件的一个解或特定意义下的最优解</p>
]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>职场工作效率手册</title>
    <url>/posts/efadcc2c.html</url>
    <content><![CDATA[<h1>任务管理</h1>
<blockquote>
<p>处理任务的流程：收集、厘清、整理、执行、回顾<br>
现代任务管理工具：所有任务管理软件都在用一个体系，称之为LTF体系，List-Tag-Filter。<br>
基础任务管理工具只有列表这个功能，高级任务管理工具会包括LTF三个功能，如全平台的Todoist，苹果平台的2Do、Omnifocus等等。<br>
List是一层一层嵌套的，通过列表来组织任务，不断拆分，直到拆分到每一个具体的任务。列表用来确定一个东西的位置，而Tag用来表示一个任务的属性。标签在任务管理工具里可以横跨列表。Tag可以包括时间、优先级、人物，一个比较有趣的思路是用精力来做标签，我们可以把精力分为两档，“Focus”和“Brain Dead”。Filter是过滤，表示通过一定的条件，把我们需要的东西从一大堆信息中筛选出来。</p>
</blockquote>
<a id="more"></a>
<hr>
<h1>文件管理</h1>
<blockquote>
<p>初步整理：1. 给文件取个好名字，下载到桌面时随手给它们起一个看得懂的名字，从源头上解决文件名问题。2. 做好关联和归档。在使用中有意识的把相关的文件放在一起，便于对整体做进一步的操作。同时把过期的文件进行归档，保持桌面整洁。</p>
<p>高效管理：macOS的标签可以将同类型的文件跨越文件夹聚集起来，Windows中的库则可以把不同文件夹聚集在一起。最后达到的效果是一样的。标签可以分为两类：1. 为文件定性，如文档、素材、图片等 2. 另一类是临时性的标签，如正在处理、待归档、待完善等。</p>
<p>深度整理：文件夹的层级最好不要多于三层，过于详尽的分类会消磨整理的想法。宁愿多建一些文件夹，也不要建立第四第五层文件夹。</p>
<p>归档和备份：将那些不再常用的文件夹整理归类，挑出对将来有参考价值的文件，进行统一归档。将三种类型的文件删除节约硬盘空间：没有保留价值的文件、可以轻易从网上下载到的文件、已过期或者有实效性的文件。</p>
</blockquote>
<hr>
<h1>邮件处理</h1>
<blockquote>
<p>要使用正式的邮箱名，不要用qq或者数字作为邮箱注册名，很不友好。对外展示的名字（正文上方显示的发件人名字）一般取个人姓名，如果岗位涉及到频繁对外沟通，可以加上公司的名字方便别人辨认。</p>
<p>正确使用cc和bcc：cc是抄送，cc里面人名的程度是知情，而不需要做什么实质性回复。bcc是密送，每一个被密送的人，都会觉得这封邮件是单独发给他们的。如果刚到公司对组织架构和相关人员情况不是特别了解，不知道需要抄送哪些人的时候可以直接问上级。</p>
<p>写邮件的规范：<br>
邮件正文一定要对收件人友好，倡导ABC法则，先写Action，你希望收件人做什么事情，一句话总结出来。再写Background，背景情况，向对方解释一些执行细节或者前因后果。最后是Close，写一两句简短的客套话、礼貌用语，也可以适当放一些相关联系人，比如那件事情要了解详情的话找谁。<br>
邮件标题一般是Action的精简版，也可以在最前方加上[通知]、[信息]、[请求]两三个字标记一下类型。<br>
写邮件的顺序：先贴附件、再写正文、再写标题，最后放收件人。先把附件放进来，为了防止最后忘记贴附件，如果有多个附件，可以在文件前面加上附件1、附件2这样的命名，可以在写正文的时候方便对应上。正文写好后再去归纳总结标题。<br>
附件如果是excel这种对手机不友好的文件，有义务在邮件正文中简要说明一下附件当中可能最需要对方关注的重点；如一个ppt可以把最重要的几页截图粘在正文中，或者考虑单独再存一个pdf文件，不然有的时候手机端打开ppt查看格式会乱掉。</p>
<p>如何使用自动回复：适时且适当。比如休假过程中告知对方现在不会像平时工作一样马上查阅邮件。自动回复应该说明两件事情：如果对方很急可以临时先联系谁，如果不是很急自己什么时候可以回复（什么时候结束休假）。</p>
<p>整理邮箱的步骤：用处理任务的思路处理邮件。</p>
</blockquote>
<hr>
<h1>思维导图</h1>
<blockquote>
<p>利用思维导图可以尽可能去掉实际内容之外的装饰，把知识的骨架提取出来，另外除了学习外部的知识之外，思维导图还能够帮助你更好地把自己的想法表达出来。</p>
<p>相比于大纲和鱼骨图等其他关系图，思维导图更符合大脑的思维方式（发散性思维方式）。思维导图的重要功能是帮助自己回忆起整体的信息，用分支来表达逻辑关系，只在节点处保留关键文字信息。</p>
<p>常见思维导图的误区：1. 文本不够精炼，从而降低了思维导图的效率。2. 单调，图像记忆是思维导图的一个重要功能，尽量让作品好看一些，使用线条的时候有组织的基础上使用多种颜色。</p>
<p>思维导图工具推荐：MindNode，是Mac上最广泛使用的思维导图软件，其他平台推荐XMind跨平台。</p>
</blockquote>
<hr>
<h1>密码管理</h1>
<blockquote>
<p>使用密码管理工具管理密码，每个软件的密码应该不相同且具有一定复杂性，最好是数字、英文、符号混在一起，不要使用WiFi密码工具，甚至不要使用公共场所的WiFi。使用1password,LastPass管理密码。</p>
</blockquote>
<hr>
<h1>信息摄取</h1>
<blockquote>
<p>信息源的控制：明确目标，优化信息源的质量，一个信息的半衰期越久、稀缺程度越高，能带来的价值也就越大。要掌握对信息源的掌控主动权，不应该简简单单把这个权力交出去，想想应该用什么搜索引擎，不能把选择权交给浏览器的默认设置。警惕回声效应：你关注的人、认同的观点，慢慢会收拢成一个圈子，信息就像回声一样在这里传播，外面的信息就进不来了，甚至你也没有办法认同和接收不一样的观点了。这是一件很危险的事情。在获取信息的时候，一定要从多个角度、正面反面的、不同利益方的视角来摄取。</p>
<p>处理网络信息的核心能力：速读，逐渐锻炼自己的大脑，通过对关键词的出现频率和稀缺程度，来判断内容的重要性。溯源，需要一个稍后阅读的枢纽，将不通的内容都集合起来统一阅读。要知道自己为什么当时觉得重要，保留原信息的原始链接很重要，因为很多时候收集下来的内容，一段时间后回顾的时候已经想不起来到底为什么重要、值得收集下来了。吸收，收集到笔记里的重要信息，应该养成习惯，用自己的语法去重新整理，这样才能真正的吸收。</p>
</blockquote>
<hr>
<h1>PDF取代纸质文档</h1>
<blockquote>
<p>PDF的优势：便携性、可搜索性、自动归纳笔记。<br>
利用标签整理PDF可以同时应用多套分类方式，更方便的是可以打破文件夹的限制，透过标签来查找文件。</p>
<p>高效使用PDF：</p>
<ol>
<li>利用书签和大纲快速定位内容所在位置。</li>
<li>高光和下划线，高光更适合用来标注文档中的关键词和单句，例如专有名词、或者对段落含义有决定性影响的句子。下划线更适合对文档中的关键段落进行标注，例如文章中结论性的段落。</li>
<li>制定自己的颜色体系，提升自己标注PDF时候的效率。</li>
<li>笔记和批注，只有你希望添加或者修改文档中的内容时，采取使用手写笔记功能。例如在批改或者审核文档，使用手写笔迹就能清晰直接的指出确切位置和内容。当作为学习者的角色阅读文档的时候，要记下自己的感悟，应该使用阅读器的批注功能，这种批注通过键盘添加，内容可以隐藏起来。</li>
</ol>
</blockquote>
<hr>
<h1>学会记账</h1>
<blockquote>
<p>月光如何形成：你不知道你有多少钱，你不知道你的钱都花到哪里去了。</p>
<p>预算能做的只是提醒，在你不理性的状态下提醒你：如果你能做到理性消费，在当下这个场景中你应该花多少钱。</p>
</blockquote>
<hr>
<h1>理财</h1>
<blockquote>
<p>职场新人更应该理财，刚刚开始工作的毕业生往往会以没钱可理财来拒绝学习理财。刚刚参加工作时，是开始理财的最佳阶段。收入刚刚增加，消费水平还没收水涨船高之前，可以把握理财机会，快速积累本金。</p>
<p>理财技能的高低不在于理财能产生多少收入，而在于理财的收益率，这是百分比，与本金无关。理财技能的提升需要几年时间，新手需要试错，如果现在不早早开始，等到你有钱了，想理财也无从下手了。</p>
<p>理财就是一种奋斗，虽然它周期较长，要十年甚至几十年才能看到成效，但是一旦理财初具规模，进入快车道，后面的增长速度绝对是普通工作望尘莫及的。理财开始得早，后面才能享受到快速增长的价值。</p>
<p>过早买房其实是你投资的一个障碍，不是说房子不重要，而是说要考虑清楚再下手，工作前几年是快速积累资本的时期，一套房子入手可能多年的资本积累一下子就烟消云散了。一套房子从使用角度来看，值不值的关键因素在于房价和房租的比例，买房不应该是一种约定俗成的习惯，而应该是深思熟虑后的决定。理财的目标是实现真正的财务自由。</p>
<p>资产与负债很容易搞混，自住的房子和自用的车子不能算资产，因为几乎不会主动变卖，房子和车子无法产生收益，只会产生越来越多的开支，所以他们都是负债。</p>
<p>理财：投资产品之前先投资自己。以证券投资这个话题为例，吃透十几本经典，基本就可以立于不败之地。用时间来抵消波动的不利。投资亏损实际上就是波动也的一种表现形式，能接受越高的波动性，才可能获得越高的收益。</p>
<p>保险：配置保险是理财不可缺失的一环。头号大坑是返还型保险。过分追求高保额是保险的另一个常见误区，保额要合理才有意义。低保额的保险尽可能回避。</p>
</blockquote>
<hr>
<h1>记录灵感</h1>
<blockquote>
<p>灵感是想要创作时的素材和数据来源，《程序员的思维修炼》这本书里说：</p>
<p>“每个人——不论教育背景、经济状况如何。不论日常工作是什么，不论年龄大小——都有好想法。但是在这么多拥有好想法的人里面，只有少数人在努力追踪它们。而其中，又只有更少数人会努力付诸行动。随后，仅有少之又少的人有能力将好想法成功实现。”</p>
<p>智能设备相对于纸笔记录有很大的优势：如信息多元化，可以图片链接等复杂内容。便携性，同步等。</p>
<p>笔记工具的要求：第一个基本要求就是打开软件能不能最快地新建一个笔记。市面上很多软件都做不到这一点，打开来需要同步，有的还有启动广告。打开完想记什么早就忘了。第二点是应该能人让你对笔记进行整理。要有文件夹、标签、搜索语法、最近使用、收藏、置顶等功能。有的一些人需要笔记软件支持Markdown。</p>
</blockquote>
]]></content>
      <categories>
        <category>工作效率</category>
      </categories>
      <tags>
        <tag>职场</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux基本命令</title>
    <url>/posts/4b6ea061.html</url>
    <content><![CDATA[<h1>命令的基本格式</h1>
<blockquote>
<p>[root@localhost~]</p>
<p>root为用户名</p>
<p>～表示当前所在位置</p>
<p>localhost主机名</p>
<p>‘#’超级用户</p>
<p>'$&quot;  普通用户</p>
</blockquote>
<a id="more"></a>
<p>命令的基本格式：</p>
<blockquote>
<p>命令  [选项]  [参数]</p>
</blockquote>
<hr>
<h1>查询目录的内容</h1>
<p>命令格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls [选项][文件或目录]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>选项：</p>
<p>-a 所有文件</p>
<p>-l  查看详情</p>
<p>-d查看目录属性</p>
<p>-h显示文件大小</p>
</blockquote>
<hr>
<h1>文件处理命令</h1>
<h2 id="1-建立目录">1.建立目录</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p [目录名]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>-p表述递归建文件夹</p>
</blockquote>
<p>举例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir japan</span><br><span class="line"></span><br><span class="line">mkdir -p japan/cangjk</span><br></pre></td></tr></table></figure>
<h2 id="2-切换目录">2.切换目录</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd [目录]</span><br></pre></td></tr></table></figure>
<p>简化操作：</p>
<blockquote>
<p>cd~  进入当前用户目录</p>
<p>cd- 上次目录</p>
<p>cd… 进入上一级目录</p>
<p>pwd查看当前目录所在位置</p>
</blockquote>
<h2 id="3-删除目录">3.删除目录</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rmdir [目录]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>删除所有文件</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm -rf [目录]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>删除目录所有文件</p>
</blockquote>
<h2 id="4-复制目录">4.复制目录</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp[选项][原文件目录][目标目录]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>选项：</p>
<p>-r复制目录</p>
<p>-p连文件属性一起复制</p>
<p>-a 相当于-pdr</p>
</blockquote>
<h2 id="5-剪切、改名">5.剪切、改名</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv[原文件目录][目标文件目录]</span><br></pre></td></tr></table></figure>
<h2 id="6-常见目录作用">6.常见目录作用</h2>
<blockquote>
<p>/ 根目录</p>
<p>/bin 命令保存目录</p>
<p>/boot  启动目录</p>
<p>/dev  设备文件命令</p>
<p>/etc  配置文件保存目录</p>
<p>/home  家目录</p>
<p>/lib  系统库保存命令</p>
<p>/mnt  系统挂载目录</p>
</blockquote>
<hr>
<h1>文件搜索命令</h1>
<h2 id="1-locate">1.locate</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">locate [文件名]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在系统数据库中查找文件的</p>
</blockquote>
<blockquote>
<p>新建的文件，要执行updatedb操作之后才能搜到</p>
</blockquote>
<h2 id="2-命令搜索">2.命令搜索</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">whereis [选项] [命令名]</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">which [选项][命令名]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>选项：</p>
<p>-b 只查找可执行文件</p>
<p>-m 只查找帮助文件</p>
</blockquote>
<h2 id="3-文件搜索">3.文件搜索</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find [搜索范围][选项][条件]</span><br></pre></td></tr></table></figure>
<p>直接举例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find  /  -name install.log  </span><br><span class="line">在根目录下查找名为install.log文件</span><br><span class="line">find /root  -inname install.log</span><br><span class="line">忽略大小写查找文件</span><br><span class="line">find /var/log -mtime +10</span><br><span class="line"></span><br><span class="line">其中-mtime 文件修改时间</span><br><span class="line">-atime 文件访问时间</span><br><span class="line">-ctime 改变文件属性时间</span><br><span class="line"></span><br><span class="line">+10 10天前</span><br><span class="line">10  10天</span><br><span class="line">-10 10天内</span><br><span class="line">find /etc -size +20M</span><br><span class="line"></span><br><span class="line">查找文件大于20M的文件</span><br></pre></td></tr></table></figure>
<hr>
<h1>压缩与解压缩命令</h1>
<p>常见压缩格式：.zip  、 .gz 、 .bz2、<br>
.tar.gz  、 .tar.bz2</p>
<h2 id="1-zip格式">1.zip格式</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//压缩文件</span><br><span class="line">zip [压缩文件名][原文件]</span><br><span class="line">//压缩目录</span><br><span class="line">zip -r  [压缩文件名][原文件]</span><br></pre></td></tr></table></figure>
<p>举例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">touch jp/cangls</span><br><span class="line"></span><br><span class="line">touch jp/longls</span><br><span class="line"></span><br><span class="line">zip -r jp.zip jp</span><br><span class="line"><span class="meta">#</span><span class="bash">解压：</span></span><br><span class="line">unzip [压缩文件名]</span><br></pre></td></tr></table></figure>
<h2 id="2-gz格式">2.gz格式</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 压缩为gz格式，原文件不保留</span></span><br><span class="line">gzip [原文件]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">压缩.gz格式，原文件保留</span></span><br><span class="line"></span><br><span class="line">gzip -c 原文件 &gt; 压缩文件</span><br><span class="line"><span class="meta">#</span><span class="bash"> 压缩目录：</span></span><br><span class="line">gzip -r  目录</span><br></pre></td></tr></table></figure>
<p>解压：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">guzip [文件]</span><br><span class="line"></span><br><span class="line">guzip -r [目录]</span><br></pre></td></tr></table></figure>
<h2 id="3-tar格式">3.tar格式</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 打包</span></span><br><span class="line">tar -cvf  打包文件名 原文件</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 解压</span></span><br><span class="line"></span><br><span class="line">tar -xvf jp.tar</span><br></pre></td></tr></table></figure>
<h2 id="4-tar-gz格式">4.tar.gz格式</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">打包</span></span><br><span class="line">tar -zcvf 压缩包名.tar.gz  原文件</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">解压</span></span><br><span class="line">tar -zxvf  压缩包名.tar.gz</span><br></pre></td></tr></table></figure>
<hr>
<h1>关机和重启</h1>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shutdown [选项][时间]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">选项：</span></span><br><span class="line">-c 取消前一个关机命令</span><br><span class="line">-h 关机</span><br><span class="line">-r 重启</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">init 6重启</span><br><span class="line"></span><br><span class="line">init 0关机</span><br><span class="line"></span><br><span class="line">logout退出登陆</span><br></pre></td></tr></table></figure>
<hr>
<h1>查看用户信息</h1>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">w</span><br><span class="line">who</span><br><span class="line">last</span><br><span class="line">lastlog</span><br></pre></td></tr></table></figure>
<hr>
<h1>shell基础</h1>
<h2 id="1-什么是shell">1.什么是shell</h2>
<p>shell是命令行解释器。</p>
<h2 id="2-echo-输出命令">2.echo 输出命令</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo[选项][输出内容]</span><br></pre></td></tr></table></figure>
<p>选项：</p>
<blockquote>
<p>-e:支持转义</p>
</blockquote>
<h2 id="3-创建一个脚本">3.创建一个脚本</h2>
<p>创建 <span>hello.sh</span></p>
<blockquote>
<p>vim <span>hello.sh</span><br>
进入编辑：</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> the first program</span></span><br><span class="line"></span><br><span class="line">echo "hello world!"</span><br></pre></td></tr></table></figure>
<p>执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod 755 hello.sh</span><br><span class="line"></span><br><span class="line">./hello.sh</span><br></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bash hello.sh</span><br></pre></td></tr></table></figure>
<hr>
<h1>历史命令</h1>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">history 查看历史命令</span><br><span class="line">history [选项][历史保存文件]</span><br><span class="line">选项：</span><br><span class="line">-c清空历史</span><br><span class="line">-w把缓存中的历史写入历史命令保存文件</span><br></pre></td></tr></table></figure>
<hr>
<h1>输出重定向</h1>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">命令&gt;文件   以覆盖的方式，把正确的命令输出到指定文件</span><br><span class="line">命令&gt;&gt;文件  以追加的方式，把正确的命令输出到指定文件、</span><br><span class="line">错误命令 2&gt; 文件  以覆盖的方式把错误的命令覆盖到指定文件</span><br><span class="line">错误命令 2&gt;&gt; 文件  以追击的方式把错误的命令覆盖到指定文件</span><br><span class="line"></span><br><span class="line"> 命令&gt;&gt;文件 2&gt;&amp;1  同时追加正确命令和错误命令到 指定文件</span><br><span class="line">命令 &gt;&gt;文件1 2&gt;&gt;文件2   把正确的命令输出到文件1错误的文件2</span><br></pre></td></tr></table></figure>
<p>举个例子:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">/bin/bash</span></span><br><span class="line">while command</span><br><span class="line">do</span><br><span class="line">curl -d "userid=123343,action=getuserinfo" https://app.testasss.com.cn/ &gt;test.txt</span><br><span class="line">time=$(date)</span><br><span class="line">cat=$(cat test.txt |cut -d \: -f 3|cut -d \" -f 2)</span><br><span class="line">echo "$time $cat" &gt;&gt;test.log</span><br><span class="line">sleep 15s</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<hr>
<h1>网络相关</h1>
<h2 id="1-ifconfig查看ip">1.ifconfig查看ip</h2>
<p>举个例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">ifconfig&gt;</span><span class="bash">&gt; ip.log</span></span><br><span class="line">cat ip.log</span><br></pre></td></tr></table></figure>
<h2 id="2-查看网络状态">2.查看网络状态</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat [选项]</span><br></pre></td></tr></table></figure>
<p>选项：</p>
<blockquote>
<p>-t: 列出tcp 协议端口<br>
-u: 列出upd协议端口<br>
-n  ip地址个端口号<br>
-l 列出监听状态的<br>
-a 所有</p>
</blockquote>
<h2 id="3-查看路由列表">3.查看路由列表</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -rn</span><br><span class="line">或者</span><br><span class="line">route -n</span><br></pre></td></tr></table></figure>
<h2 id="4-查看某域名与自己的电脑的网络状态">4.查看某域名与自己的电脑的网络状态</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ping www.baodu.com</span><br></pre></td></tr></table></figure>
<hr>
<h1>vi编辑器</h1>
<p>vi的升级版是vim</p>
<h2 id="1-vim的操作模式">1.vim的操作模式</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">commond mode  命令模式</span><br><span class="line">inser tmode  编辑模式</span><br><span class="line">lastline mode  底行模式</span><br></pre></td></tr></table></figure>
<h2 id="2-模式切换">2.模式切换</h2>
<p>i  进入编辑模式<br>
esc  进入命令行模式</p>
<h2 id="3-命令模式">3.命令模式</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim [文件]         进入文件或者创建文件（文件不存在的情况下）</span><br><span class="line">vim + [文件名]   进入文件尾部</span><br><span class="line">vim +/[字符串] [文件名]  光标定位到文件第一次出现该字符串的位置</span><br></pre></td></tr></table></figure>
<h2 id="4-底行模式">4.底行模式</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">:w  保存</span><br><span class="line">:q 退出</span><br><span class="line">:! 强制</span><br><span class="line">:15  定位的第15行</span><br><span class="line">/[字符串]  光标位置向后搜索该字符串</span><br><span class="line">?[字符串]  光标位置向前搜索该字符串</span><br><span class="line">dd  删除光标所在行</span><br><span class="line"></span><br><span class="line">ctr+f   向下翻页</span><br><span class="line">ctr+b  向上翻页</span><br></pre></td></tr></table></figure>
<hr>
<h1>常用操作快捷键</h1>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ctr+c  终止当前命令</span><br><span class="line">ctr+l 清屏  相当于 clear</span><br><span class="line">ctr+a  光标移到行首</span><br><span class="line">ctr+e  光标移到行尾</span><br><span class="line">ctr+u  把光标所在位置删除到行首</span><br><span class="line">ctr+z  把命令放入后台</span><br><span class="line">ctr+r  在历史命令中搜索</span><br></pre></td></tr></table></figure>
<hr>
<h1>其他</h1>
<p>常用工具：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Vmware  虚拟机</span><br><span class="line">centos.iso   centos系统镜像 ,绝大多数服务器是这个系统</span><br><span class="line">SecureCRT  远程登陆工具</span><br><span class="line">Xshell 远程登陆工具</span><br><span class="line">winscp copy文件工具</span><br></pre></td></tr></table></figure>
<p>原文链接：<a href="https://www.jianshu.com/p/0718b3abedcf" target="_blank" rel="noopener">https://www.jianshu.com/p/0718b3abedcf</a></p>
]]></content>
      <categories>
        <category>Linux指令</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>资料整理</tag>
      </tags>
  </entry>
</search>
