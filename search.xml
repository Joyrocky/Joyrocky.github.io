<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>五大经典算法分析</title>
    <url>/posts/31d96ab6.html</url>
    <content><![CDATA[<h1>分治算法</h1>
<p><font size = 5>1. 基本概念</font></p>
<p>在计算机科学中，分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)……</p>
<p>任何一个可以用计算机求解的问题所需的计算时间都与其规模有关。问题的规模越小，越容易直接求解，解题所需的计算时间也越少。例如，对于n个元素的排序问题，当n=1时，不需任何计算。n=2时，只要作一次比较即可排好序。n=3时只要作3次比较即可，…。而当n较大时，问题就不那么容易处理了。要想直接解决一个规模较大的问题，有时是相当困难的。</p>
<a id="more"></a>
<hr>
<p><font size = 5>2. 基本思想及策略</font></p>
<p>分治法的设计思想是：将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。</p>
<p>分治策略是：对于一个规模为n的问题，若该问题可以容易地解决（比如说规模n较小）则直接解决，否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解。这种算法设计策略叫做分治法。</p>
<p>如果原问题可分割成k个子问题，1&lt;k≤n，且这些子问题都可解并可利用这些子问题的解求出原问题的解，那么这种分治法就是可行的。由分治法产生的子问题往往是原问题的较小模式，这就为使用递归技术提供了方便。在这种情况下，反复应用分治手段，可以使子问题与原问题类型一致而其规模却不断缩小，最终使子问题缩小到很容易直接求出其解。这自然导致递归过程的产生。分治与递归像一对孪生兄弟，经常同时应用在算法设计之中，并由此产生许多高效算法。</p>
<hr>
<p><font size = 5>3. 分治法适用的情况</font></p>
<p>​    分治法所能解决的问题一般具有以下几个特征：</p>
<p>​    1) 该问题的规模缩小到一定的程度就可以容易地解决</p>
<p>​    2) 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。</p>
<p>​    3) 利用该问题分解出的子问题的解可以合并为该问题的解；</p>
<p>​    4) 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。</p>
<p>第一条特征是绝大多数问题都可以满足的，因为问题的计算复杂性一般是随着问题规模的增加而增加；</p>
<p><strong>第二条特征是应用分治法的前提</strong>它也是大多数问题可以满足的，此特征反映了递归思想的应用；、</p>
<p><strong>第三条特征是关键，能否利用分治法完全取决于问题是否具有第三条特征</strong>，如果<strong>具备了第一条和第二条特征，而不具备第三条特征，则可以考虑用贪心法或动态规划法</strong>。</p>
<p><strong>第四条特征涉及到分治法的效率</strong>，如果各子问题是不独立的则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然可用分治法，但<strong>一般用动态规划法较好</strong>。</p>
<hr>
<p><font size = 5>4. 分治法的基本步骤</font></p>
<p>分治法在每一层递归上都有三个步骤：</p>
<p>​    step1 分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题；</p>
<p>​    step2 解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题</p>
<p>​    step3 合并：将各个子问题的解合并为原问题的解。</p>
<p>它的一般的算法设计模式如下：</p>
<p>​    Divide-and-Conquer§</p>
<p>​    1. if |P|≤n0</p>
<p>​    2. then return(ADHOC§)</p>
<p>​    3. 将P分解为较小的子问题 P1 ,P2 ,…,Pk</p>
<p>​    4. for i←1 to k</p>
<p>​    5. do yi ← Divide-and-Conquer(Pi) △ 递归解决Pi</p>
<p>​    6. T ← MERGE(y1,y2,…,yk) △ 合并子问题</p>
<p>​    7. return(T)</p>
<p>​    其中|P|表示问题P的规模；n0为一阈值，表示当问题P的规模不超过n0时，问题已容易直接解出，不必再继续分解。ADHOC§是该分治法中的基本子算法，用于直接解小规模的问题P。因此，当P的规模不超过n0时直接用算法ADHOC§求解。算法MERGE(y1,y2,…,yk)是该分治法中的合并子算法，用于将P的子问题P1 ,P2 ,…,Pk的相应的解y1,y2,…,yk合并为P的解。</p>
<hr>
<p><font size = 5>5. 分治法的复杂性分析</font></p>
<p>​    一个分治法将规模为n的问题分成k个规模为n／m的子问题去解。设分解阀值n0=1，且adhoc解规模为1的问题耗费1个单位时间。再设将原问题分解为k个子问题以及用merge将k个子问题的解合并为原问题的解需用f(n)个单位时间。用T(n)表示该分治法解规模为|P|=n的问题所需的计算时间，则有：</p>
<p>T（n）= k T(n/m)+f(n)</p>
<p>​    通过迭代法求得方程的解：</p>
<p>​    <strong>递归方程及其解只给出n等于m的方幂时T(n)的值，但是如果认为T(n)足够平滑，那么由n等于m的方幂时T(n)的值可以估计T(n)的增长速度。通常假定T(n)是单调上升的，从而当mi≤n&lt;mi+1时，T(mi)≤T(n)&lt;T(mi+1)。</strong></p>
<hr>
<p><font size = 5>6. 可使用分治法求解的一些经典问题</font></p>
<p>（1）二分搜索</p>
<p>（2）大整数乘法</p>
<p>（3）Strassen矩阵乘法</p>
<p>（4）棋盘覆盖</p>
<p>（5）合并排序</p>
<p>（6）快速排序</p>
<p>（7）线性时间选择</p>
<p>（8）最接近点对问题</p>
<p>（9）循环赛日程表</p>
<p>（10）汉诺塔</p>
<hr>
<p><font size = 5>7. 依据分治法设计程序时的思维过程</font></p>
<p><strong>实际上就是类似于数学归纳法，找到解决本问题的求解方程公式，然后根据方程公式设计递归程序。</strong></p>
<p><strong>1、一定是先找到最小问题规模时的求解方法</strong></p>
<p><strong>2、然后考虑随着问题规模增大时的求解方法</strong></p>
<p><strong>3、找到求解的递归函数式后（各种规模或因子），设计递归程序即可。</strong></p>
<hr>
<h1>动态规划算法</h1>
<p><font size = 5>1. 基本概念</font></p>
<p>​    动态规划过程是：每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划。</p>
<p><font size = 5>2. 基本思想与策略</font></p>
<p>​    基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。</p>
<p>​    由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中。</p>
<p>​    与分治法最大的差别是：适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）。</p>
<hr>
<p><font size = 5>3. 适用的情况</font></p>
<p>能采用动态规划求解的问题的一般要具有3个性质：</p>
<p>​    (1) 最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。</p>
<p>​    (2) 无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。</p>
<p>（3）有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）</p>
<hr>
<p><font size = 5>4. 求解的基本步骤</font></p>
<p>​     动态规划所处理的问题是一个多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态。这些决策形成了一个决策序列，同时确定了完成整个过程的一条活动路线(通常是求最优的活动路线)。如图所示。动态规划的设计都有着一定的模式，一般要经历以下几个步骤。</p>
<p>​    初始状态→│决策１│→│决策２│→…→│决策ｎ│→结束状态</p>
<p>​                      图1 动态规划决策过程示意图</p>
<p>​    (1)<strong>划分阶段</strong>：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。</p>
<p>​    (2)<strong>确定状态和状态变量</strong>：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。</p>
<p>​    (3)<strong>确定决策并写出状态转移方程</strong>：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。</p>
<p>​    (4)<strong>寻找边界条件</strong>：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。</p>
<p>​    一般，只要解决问题的阶段、状态和状态转移决策确定了，就可以写出状态转移方程（包括边界条件）。</p>
<p>实际应用中可以按以下几个简化的步骤进行设计：</p>
<p>​    （1）分析最优解的性质，并刻画其结构特征。</p>
<p>​    （2）递归的定义最优解。</p>
<p>​    （3）以自底向上或自顶向下的记忆化方式（备忘录法）计算出最优值</p>
<p>​    （4）根据计算最优值时得到的信息，构造问题的最优解</p>
<hr>
<p><font size = 5>5. 算法实现的说明</font></p>
<p>​    动态规划的主要难点在于理论上的设计，也就是上面4个步骤的确定，一旦设计完成，实现部分就会非常简单。</p>
<p>​     使用动态规划求解问题，最重要的就是确定动态规划三要素：</p>
<p>​    （1）问题的阶段 （2）每个阶段的状态</p>
<p>​    （3）从前一个阶段转化到后一个阶段之间的递推关系。</p>
<p>​     递推关系必须是从次小的问题开始到较大的问题之间的转化，从这个角度来说，动态规划往往可以用递归程序来实现，不过因为递推可以充分利用前面保存的子问题的解来减少重复计算，所以对于大规模问题来说，有递归不可比拟的优势，这也是动态规划算法的核心之处。</p>
<p>​    确定了动态规划的这三要素，整个求解过程就可以用一个最优决策表来描述，最优决策表是一个二维表，其中行表示决策的阶段，列表示问题状态，表格需要填写的数据一般对应此问题的在某个阶段某个状态下的最优值（如最短路径，最长公共子序列，最大价值等），填表的过程就是根据递推关系，从1行1列开始，以行或者列优先的顺序，依次填写表格，最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解。</p>
<p>​          <strong>f(n,m)=max{f(n-1,m), f(n-1,m-w[n])+P(n,m)}</strong></p>
<hr>
<p><font size = 5>6. 动态规划算法基本框架</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;=m; j=j+<span class="number">1</span>) <span class="comment">// 第一个阶段</span></span><br><span class="line">   xn[j] = 初始值;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span>(i=n-<span class="number">1</span>; i&gt;=<span class="number">1</span>; i=i-<span class="number">1</span>)<span class="comment">// 其他n-1个阶段</span></span><br><span class="line">   <span class="keyword">for</span>(j=<span class="number">1</span>; j&gt;=f(i); j=j+<span class="number">1</span>)<span class="comment">//f(i)与i有关的表达式</span></span><br><span class="line">     xi[j]=j=max（或min）&#123;g(xi-<span class="number">1</span>[j1:j2]), ......, g(xi-<span class="number">1</span>[jk:jk+<span class="number">1</span>])&#125;;</span><br><span class="line"></span><br><span class="line">t = g(x1[j1:j2]); <span class="comment">// 由子问题的最优解求解整个问题的最优解的方案</span></span><br><span class="line"></span><br><span class="line">print(x1[j1]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">2</span>; i&lt;=n-<span class="number">1</span>; i=i+<span class="number">1</span>）</span><br><span class="line">&#123;  </span><br><span class="line">     t = t-xi-<span class="number">1</span>[ji];</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span>(j=<span class="number">1</span>; j&gt;=f(i); j=j+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span>(t=xi[ji])</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1>贪心算法</h1>
<p><font size = 5>1. 基本概念：</font></p>
<p>​     所谓贪心算法是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解。</p>
<p>​     贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效性，即某个状态以后的过程不会影响以前的状态，只与当前状态有关。</p>
<p>​    所以对所采用的贪心策略一定要仔细分析其是否满足无后效性。</p>
<hr>
<p><font size = 5>2. 贪心算法的基本思路：</font></p>
<p>​    1.建立数学模型来描述问题。</p>
<p>​    2.把求解的问题分成若干个子问题。</p>
<p>​    3.对每一子问题求解，得到子问题的局部最优解。</p>
<p>​    4.把子问题的解局部最优解合成原来解问题的一个解。</p>
<hr>
<p><font size = 5>3. 贪心算法适用的问题</font></p>
<p>​      <strong>贪心策略适用的前提是：局部最优策略能导致产生全局最优解。</strong></p>
<p>​    <strong>实际上，贪心算法适用的情况很少。一般，对一个问题分析是否适用于贪心算法，可以先选择该问题下的几个实际数据进行分析，就可做出判断。</strong></p>
<hr>
<p><font size = 5>4. 贪心算法的实现框架</font></p>
<p>​    从问题的某一初始解出发；</p>
<p>​    while （能朝给定总目标前进一步）</p>
<p>​    {</p>
<p>​          利用可行的决策，求出可行解的一个解元素；</p>
<p>​    }</p>
<p>​    由所有解元素组合成问题的一个可行解；</p>
<hr>
<p><font size = 5>5. 贪心策略的选择</font></p>
<p>​     因为用贪心算法只能通过解局部最优解的策略来达到全局最优解，因此，一定要注意判断问题是否适合采用贪心算法策略，找到的解是否一定是问题的最优解。</p>
<hr>
<p><font size = 5>6. 例题分析</font></p>
<p>​    下面是一个可以试用贪心算法解的题目，贪心解的确不错，可惜不是最优解。</p>
<p>​    [背包问题]有一个背包，背包容量是M=150。有7个物品，物品可以分割成任意大小。</p>
<p>​    要求尽可能让装入背包中的物品总价值最大，但不能超过总容量。</p>
<p>​    物品 A B C D E F G</p>
<p>​    重量 35 30 60 50 40 10 25</p>
<p>​    价值 10 40 30 50 35 40 30</p>
<p>​    分析：</p>
<p>​    目标函数： ∑pi最大</p>
<p>​    约束条件是装入的物品总重量不超过背包容量：∑wi&lt;=M( M=150)</p>
<p>​    （1）根据贪心的策略，每次挑选价值最大的物品装入背包，得到的结果是否最优？</p>
<p>​    （2）每次挑选所占重量最小的物品装入是否能得到最优解？</p>
<p>​    （3）每次选取单位重量价值最大的物品，成为解本题的策略。</p>
<p>​    值得注意的是，贪心算法并不是完全不可以使用，贪心策略一旦经过证明成立后，它就是一种高效的算法。</p>
<p>​    贪心算法还是很常见的算法之一，这是由于它简单易行，构造贪心策略不是很困难。</p>
<p>​    可惜的是，它需要证明后才能真正运用到题目的算法中。</p>
<p>​    一般来说，贪心算法的证明围绕着：整个问题的最优解一定由在贪心策略中存在的子问题的最优解得来的。</p>
<p>​    对于例题中的3种贪心策略，都是无法成立（无法被证明）的，解释如下：</p>
<p>​    （1）贪心策略：选取价值最大者。反例：</p>
<p>​    W=30</p>
<p>​    物品：A B C</p>
<p>​    重量：28 12 12</p>
<p>​    价值：30 20 20</p>
<p>​    根据策略，首先选取物品A，接下来就无法再选取了，可是，选取B、C则更好。</p>
<p>​    （2）贪心策略：选取重量最小。它的反例与第一种策略的反例差不多。</p>
<p>​    （3）贪心策略：选取单位重量价值最大的物品。反例：</p>
<p>​    W=30</p>
<p>​    物品：A B C</p>
<p>​    重量：28 20 10</p>
<p>​    价值：28 20 10</p>
<p>​    根据策略，三种物品单位重量价值一样，程序无法依据现有策略作出判断，如果选择A，则答案错误。</p>
<hr>
<h1>回溯法</h1>
<p><font size = 5>1. 概念</font></p>
<p>​      回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。</p>
<p>回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。</p>
<p>​     许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。</p>
<hr>
<p><font size = 5>2. 基本思想</font></p>
<p>在包含问题的所有解的解空间树中，按照<strong>深度优先搜索的策略</strong>，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯。（其实回溯法就是对隐式图的深度优先搜索算法）。</p>
<p>​       若用回溯法求问题的所有解时，要回溯到根，且根结点的所有可行的子树都要已被搜索遍才结束。</p>
<p>​       而若使用回溯法求任一个解时，只要搜索到问题的一个解就可以结束。</p>
<hr>
<p><font size = 5>3. 用回溯法解题的一般步骤：</font></p>
<p>​    （1）针对所给问题，确定问题的解空间：</p>
<p>​            首先应明确定义问题的解空间，问题的解空间应至少包含问题的一个（最优）解。</p>
<p>​    （2）确定结点的扩展搜索规则</p>
<p>​    （3）以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。</p>
<hr>
<p><font size = 5>4. 算法框架</font></p>
<p>​     （1）问题框架</p>
<p>​      设问题的解是一个n维向量(a1,a2,………,an),约束条件是ai(i=1,2,3,……,n)之间满足某种条件，记为f(ai)。</p>
<p>​     （2）非递归回溯框架</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[n],i;</span><br><span class="line">初始化数组a[];</span><br><span class="line">i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i&gt;<span class="number">0</span>(有路可走)   and  (未达到目标))  <span class="comment">// 还未回溯到头</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(i &gt; n)                                              <span class="comment">// 搜索到叶结点</span></span><br><span class="line">     &#123;   </span><br><span class="line">           搜索到一个解，输出；</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span>                                                   <span class="comment">// 处理第i个元素</span></span><br><span class="line">     &#123; </span><br><span class="line">           a[i]第一个可能的值；</span><br><span class="line">           <span class="keyword">while</span>(a[i]在不满足约束条件且在搜索空间内)</span><br><span class="line">           &#123;</span><br><span class="line">               a[i]下一个可能的值；</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(a[i]在搜索空间内)</span><br><span class="line">          &#123;</span><br><span class="line">               标识占用的资源；</span><br><span class="line">               i = i+<span class="number">1</span>;                              <span class="comment">// 扩展下一个结点</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> </span><br><span class="line">         &#123;</span><br><span class="line">               清理所占的状态空间；            <span class="comment">// 回溯</span></span><br><span class="line">               i = i –<span class="number">1</span>; </span><br><span class="line">          &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>3）递归的算法框架</p>
<p>​         回溯法是对解空间的深度优先搜索，在一般情况下使用递归函数来实现回溯法比较简单，其中i为搜索的深度，框架如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[n];</span><br><span class="line"><span class="keyword">try</span>(<span class="keyword">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;n)</span><br><span class="line">       输出结果;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">for</span>(j = 下界; j &lt;= 上界; j=j+<span class="number">1</span>)  <span class="comment">// 枚举i所有可能的路径</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span>(fun(j))                 <span class="comment">// 满足限界函数和约束条件</span></span><br><span class="line">             &#123;</span><br><span class="line">                a[i] = j;</span><br><span class="line">              ...                         <span class="comment">// 其他操作</span></span><br><span class="line">                <span class="keyword">try</span>(i+<span class="number">1</span>);</span><br><span class="line">              回溯前的清理工作（如a[i]置空值等）;</span><br><span class="line">              &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1>分支限界法</h1>
<p><font size = 5>1. 基本描述</font></p>
<p>​    类似于回溯法，也是一种在问题的解空间树T上搜索问题解的算法。但在一般情况下，分支限界法与回溯法的求解目标不同。<strong>回溯法的求解目标是找出T中满足约束条件的所有解</strong>，而<strong>分支限界法</strong>的求解目标则是找出<strong>满足约束条件的一个解</strong>，或是在满足约束条件的解中找出使某一目标函数值达到<strong>极大或极小的解</strong>，即在某种意义下的<strong>最优解</strong>。</p>
<p><strong>（1）分支搜索算法</strong></p>
<p>​    所谓“分支”就是采用广度优先的策略，依次搜索E-结点的所有分支，也就是所有相邻结点，抛弃不满足约束条件的结点，其余结点加入活结点表。然后从表中选择一个结点作为下一个E-结点，继续搜索。</p>
<p>​     选择下一个E-结点的方式不同，则会有几种不同的分支搜索方式。</p>
<p>1）FIFO搜索</p>
<p>2）LIFO搜索</p>
<p>3）优先队列式搜索</p>
<p><strong>（2）分支限界搜索算法</strong></p>
<hr>
<p><font size = 5>2. 分支限界法的一般过程</font></p>
<p>​    由于求解目标不同，导致分支限界法与回溯法在解空间树T上的搜索方式也不相同。<strong>回溯法以深度优先的方式搜索解空间树T</strong>，而<strong>分支限界法则以广度优先或以最小耗费优先的方式搜索解空间树T</strong>。</p>
<p>​    分支限界法的<strong>搜索策略是</strong>：在扩展结点处，先生成其所有的儿子结点（分支），然后再从当前的活结点表中选择下一个扩展对点。为了有效地选择下一扩展结点，以加速搜索的进程，在每一活结点处，计算一个函数值（限界），并根据这些已计算出的函数值，从当前活结点表中选择一个最有利的结点作为扩展结点，使搜索朝着解空间树上有最优解的分支推进，以便尽快地找出一个最优解。</p>
<p>​    分支限界法常以广度优先或以最小耗费（最大效益）优先的方式搜索问题的解空间树。问题的<strong>解空间树是表示问题解空间的一棵有序树，常见的有子集树和排列树</strong>。在搜索问题的解空间树时，分支限界法与回溯法对当前扩展结点所使用的扩展方式不同。在分支限界法中，每一个活结点只有一次机会成为扩展结点。活结点一旦成为扩展结点，就一次性产生其所有儿子结点。在这些儿子结点中，那些导致不可行解或导致非最优解的儿子结点被舍弃，其余儿子结点被子加入活结点表中。此后，从活结点表中取下一结点成为当前扩展结点，并重复上述结点扩展过程。这个过程一直持续到找到所求的解或活结点表为空时为止。</p>
<hr>
<p><font size = 5>3. 回溯法和分支限界法的一些区别</font></p>
<p>​    有一些问题其实无论用回溯法还是分支限界法都可以得到很好的解决，但是另外一些则不然。也许我们需要具体一些的分析——到底何时使用分支限界而何时使用回溯呢？</p>
<p>回溯法和分支限界法的一些区别：</p>
<p>方法对解空间树的搜索方式       存储结点的常用数据结构      结点存储特性常用应用</p>
<p>回溯法深度优先搜索堆栈活结点的所有可行子结点被遍历后才被从栈中弹出找出满足约束条件的所有解</p>
<p>分支限界法广度优先或最小消耗优先搜索队列、优先队列每个结点只有一次成为活结点的机会找出满足约束条件的一个解或特定意义下的最优解</p>
<p>原文链接：<a href="https://www.cnblogs.com/parzulpan/p/9919208.html" target="_blank" rel="noopener">https://www.cnblogs.com/parzulpan/p/9919208.html</a></p>
]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>职场工作效率手册</title>
    <url>/posts/efadcc2c.html</url>
    <content><![CDATA[<h1>任务管理</h1>
<blockquote>
<p>处理任务的流程：收集、厘清、整理、执行、回顾<br>
现代任务管理工具：所有任务管理软件都在用一个体系，称之为LTF体系，List-Tag-Filter。<br>
基础任务管理工具只有列表这个功能，高级任务管理工具会包括LTF三个功能，如全平台的Todoist，苹果平台的2Do、Omnifocus等等。<br>
List是一层一层嵌套的，通过列表来组织任务，不断拆分，直到拆分到每一个具体的任务。列表用来确定一个东西的位置，而Tag用来表示一个任务的属性。标签在任务管理工具里可以横跨列表。Tag可以包括时间、优先级、人物，一个比较有趣的思路是用精力来做标签，我们可以把精力分为两档，“Focus”和“Brain Dead”。Filter是过滤，表示通过一定的条件，把我们需要的东西从一大堆信息中筛选出来。</p>
</blockquote>
<a id="more"></a>
<hr>
<h1>文件管理</h1>
<blockquote>
<p>初步整理：1. 给文件取个好名字，下载到桌面时随手给它们起一个看得懂的名字，从源头上解决文件名问题。2. 做好关联和归档。在使用中有意识的把相关的文件放在一起，便于对整体做进一步的操作。同时把过期的文件进行归档，保持桌面整洁。</p>
<p>高效管理：macOS的标签可以将同类型的文件跨越文件夹聚集起来，Windows中的库则可以把不同文件夹聚集在一起。最后达到的效果是一样的。标签可以分为两类：1. 为文件定性，如文档、素材、图片等 2. 另一类是临时性的标签，如正在处理、待归档、待完善等。</p>
<p>深度整理：文件夹的层级最好不要多于三层，过于详尽的分类会消磨整理的想法。宁愿多建一些文件夹，也不要建立第四第五层文件夹。</p>
<p>归档和备份：将那些不再常用的文件夹整理归类，挑出对将来有参考价值的文件，进行统一归档。将三种类型的文件删除节约硬盘空间：没有保留价值的文件、可以轻易从网上下载到的文件、已过期或者有实效性的文件。</p>
</blockquote>
<hr>
<h1>邮件处理</h1>
<blockquote>
<p>要使用正式的邮箱名，不要用qq或者数字作为邮箱注册名，很不友好。对外展示的名字（正文上方显示的发件人名字）一般取个人姓名，如果岗位涉及到频繁对外沟通，可以加上公司的名字方便别人辨认。</p>
<p>正确使用cc和bcc：cc是抄送，cc里面人名的程度是知情，而不需要做什么实质性回复。bcc是密送，每一个被密送的人，都会觉得这封邮件是单独发给他们的。如果刚到公司对组织架构和相关人员情况不是特别了解，不知道需要抄送哪些人的时候可以直接问上级。</p>
<p>写邮件的规范：<br>
邮件正文一定要对收件人友好，倡导ABC法则，先写Action，你希望收件人做什么事情，一句话总结出来。再写Background，背景情况，向对方解释一些执行细节或者前因后果。最后是Close，写一两句简短的客套话、礼貌用语，也可以适当放一些相关联系人，比如那件事情要了解详情的话找谁。<br>
邮件标题一般是Action的精简版，也可以在最前方加上[通知]、[信息]、[请求]两三个字标记一下类型。<br>
写邮件的顺序：先贴附件、再写正文、再写标题，最后放收件人。先把附件放进来，为了防止最后忘记贴附件，如果有多个附件，可以在文件前面加上附件1、附件2这样的命名，可以在写正文的时候方便对应上。正文写好后再去归纳总结标题。<br>
附件如果是excel这种对手机不友好的文件，有义务在邮件正文中简要说明一下附件当中可能最需要对方关注的重点；如一个ppt可以把最重要的几页截图粘在正文中，或者考虑单独再存一个pdf文件，不然有的时候手机端打开ppt查看格式会乱掉。</p>
<p>如何使用自动回复：适时且适当。比如休假过程中告知对方现在不会像平时工作一样马上查阅邮件。自动回复应该说明两件事情：如果对方很急可以临时先联系谁，如果不是很急自己什么时候可以回复（什么时候结束休假）。</p>
<p>整理邮箱的步骤：用处理任务的思路处理邮件。</p>
</blockquote>
<hr>
<h1>思维导图</h1>
<blockquote>
<p>利用思维导图可以尽可能去掉实际内容之外的装饰，把知识的骨架提取出来，另外除了学习外部的知识之外，思维导图还能够帮助你更好地把自己的想法表达出来。</p>
<p>相比于大纲和鱼骨图等其他关系图，思维导图更符合大脑的思维方式（发散性思维方式）。思维导图的重要功能是帮助自己回忆起整体的信息，用分支来表达逻辑关系，只在节点处保留关键文字信息。</p>
<p>常见思维导图的误区：1. 文本不够精炼，从而降低了思维导图的效率。2. 单调，图像记忆是思维导图的一个重要功能，尽量让作品好看一些，使用线条的时候有组织的基础上使用多种颜色。</p>
<p>思维导图工具推荐：MindNode，是Mac上最广泛使用的思维导图软件，其他平台推荐XMind跨平台。</p>
</blockquote>
<hr>
<h1>密码管理</h1>
<blockquote>
<p>使用密码管理工具管理密码，每个软件的密码应该不相同且具有一定复杂性，最好是数字、英文、符号混在一起，不要使用WiFi密码工具，甚至不要使用公共场所的WiFi。使用1password,LastPass管理密码。</p>
</blockquote>
<hr>
<h1>信息摄取</h1>
<blockquote>
<p>信息源的控制：明确目标，优化信息源的质量，一个信息的半衰期越久、稀缺程度越高，能带来的价值也就越大。要掌握对信息源的掌控主动权，不应该简简单单把这个权力交出去，想想应该用什么搜索引擎，不能把选择权交给浏览器的默认设置。警惕回声效应：你关注的人、认同的观点，慢慢会收拢成一个圈子，信息就像回声一样在这里传播，外面的信息就进不来了，甚至你也没有办法认同和接收不一样的观点了。这是一件很危险的事情。在获取信息的时候，一定要从多个角度、正面反面的、不同利益方的视角来摄取。</p>
<p>处理网络信息的核心能力：速读，逐渐锻炼自己的大脑，通过对关键词的出现频率和稀缺程度，来判断内容的重要性。溯源，需要一个稍后阅读的枢纽，将不通的内容都集合起来统一阅读。要知道自己为什么当时觉得重要，保留原信息的原始链接很重要，因为很多时候收集下来的内容，一段时间后回顾的时候已经想不起来到底为什么重要、值得收集下来了。吸收，收集到笔记里的重要信息，应该养成习惯，用自己的语法去重新整理，这样才能真正的吸收。</p>
</blockquote>
<hr>
<h1>PDF取代纸质文档</h1>
<blockquote>
<p>PDF的优势：便携性、可搜索性、自动归纳笔记。<br>
利用标签整理PDF可以同时应用多套分类方式，更方便的是可以打破文件夹的限制，透过标签来查找文件。</p>
<p>高效使用PDF：</p>
<ol>
<li>利用书签和大纲快速定位内容所在位置。</li>
<li>高光和下划线，高光更适合用来标注文档中的关键词和单句，例如专有名词、或者对段落含义有决定性影响的句子。下划线更适合对文档中的关键段落进行标注，例如文章中结论性的段落。</li>
<li>制定自己的颜色体系，提升自己标注PDF时候的效率。</li>
<li>笔记和批注，只有你希望添加或者修改文档中的内容时，采取使用手写笔记功能。例如在批改或者审核文档，使用手写笔迹就能清晰直接的指出确切位置和内容。当作为学习者的角色阅读文档的时候，要记下自己的感悟，应该使用阅读器的批注功能，这种批注通过键盘添加，内容可以隐藏起来。</li>
</ol>
</blockquote>
<hr>
<h1>学会记账</h1>
<blockquote>
<p>月光如何形成：你不知道你有多少钱，你不知道你的钱都花到哪里去了。</p>
<p>预算能做的只是提醒，在你不理性的状态下提醒你：如果你能做到理性消费，在当下这个场景中你应该花多少钱。</p>
</blockquote>
<hr>
<h1>理财</h1>
<blockquote>
<p>职场新人更应该理财，刚刚开始工作的毕业生往往会以没钱可理财来拒绝学习理财。刚刚参加工作时，是开始理财的最佳阶段。收入刚刚增加，消费水平还没收水涨船高之前，可以把握理财机会，快速积累本金。</p>
<p>理财技能的高低不在于理财能产生多少收入，而在于理财的收益率，这是百分比，与本金无关。理财技能的提升需要几年时间，新手需要试错，如果现在不早早开始，等到你有钱了，想理财也无从下手了。</p>
<p>理财就是一种奋斗，虽然它周期较长，要十年甚至几十年才能看到成效，但是一旦理财初具规模，进入快车道，后面的增长速度绝对是普通工作望尘莫及的。理财开始得早，后面才能享受到快速增长的价值。</p>
<p>过早买房其实是你投资的一个障碍，不是说房子不重要，而是说要考虑清楚再下手，工作前几年是快速积累资本的时期，一套房子入手可能多年的资本积累一下子就烟消云散了。一套房子从使用角度来看，值不值的关键因素在于房价和房租的比例，买房不应该是一种约定俗成的习惯，而应该是深思熟虑后的决定。理财的目标是实现真正的财务自由。</p>
<p>资产与负债很容易搞混，自住的房子和自用的车子不能算资产，因为几乎不会主动变卖，房子和车子无法产生收益，只会产生越来越多的开支，所以他们都是负债。</p>
<p>理财：投资产品之前先投资自己。以证券投资这个话题为例，吃透十几本经典，基本就可以立于不败之地。用时间来抵消波动的不利。投资亏损实际上就是波动也的一种表现形式，能接受越高的波动性，才可能获得越高的收益。</p>
<p>保险：配置保险是理财不可缺失的一环。头号大坑是返还型保险。过分追求高保额是保险的另一个常见误区，保额要合理才有意义。低保额的保险尽可能回避。</p>
</blockquote>
<hr>
<h1>记录灵感</h1>
<blockquote>
<p>灵感是想要创作时的素材和数据来源，《程序员的思维修炼》这本书里说：</p>
<p>“每个人——不论教育背景、经济状况如何。不论日常工作是什么，不论年龄大小——都有好想法。但是在这么多拥有好想法的人里面，只有少数人在努力追踪它们。而其中，又只有更少数人会努力付诸行动。随后，仅有少之又少的人有能力将好想法成功实现。”</p>
<p>智能设备相对于纸笔记录有很大的优势：如信息多元化，可以图片链接等复杂内容。便携性，同步等。</p>
<p>笔记工具的要求：第一个基本要求就是打开软件能不能最快地新建一个笔记。市面上很多软件都做不到这一点，打开来需要同步，有的还有启动广告。打开完想记什么早就忘了。第二点是应该能人让你对笔记进行整理。要有文件夹、标签、搜索语法、最近使用、收藏、置顶等功能。有的一些人需要笔记软件支持Markdown。</p>
</blockquote>
]]></content>
      <categories>
        <category>工作效率</category>
      </categories>
      <tags>
        <tag>职场</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux基本命令</title>
    <url>/posts/4b6ea061.html</url>
    <content><![CDATA[<h1>命令的基本格式</h1>
<blockquote>
<p>[root@localhost~]</p>
<p>root为用户名</p>
<p>～表示当前所在位置</p>
<p>localhost主机名</p>
<p>‘#’超级用户</p>
<p>'$&quot;  普通用户</p>
</blockquote>
<a id="more"></a>
<p>命令的基本格式：</p>
<blockquote>
<p>命令  [选项]  [参数]</p>
</blockquote>
<hr>
<h1>查询目录的内容</h1>
<p>命令格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls [选项][文件或目录]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>选项：</p>
<p>-a 所有文件</p>
<p>-l  查看详情</p>
<p>-d查看目录属性</p>
<p>-h显示文件大小</p>
</blockquote>
<hr>
<h1>文件处理命令</h1>
<h2 id="1-建立目录"><a class="header-anchor" href="#1-建立目录">¶</a>1.建立目录</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p [目录名]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>-p表述递归建文件夹</p>
</blockquote>
<p>举例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir japan</span><br><span class="line"></span><br><span class="line">mkdir -p japan/cangjk</span><br></pre></td></tr></table></figure>
<h2 id="2-切换目录"><a class="header-anchor" href="#2-切换目录">¶</a>2.切换目录</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd [目录]</span><br></pre></td></tr></table></figure>
<p>简化操作：</p>
<blockquote>
<p>cd~  进入当前用户目录</p>
<p>cd- 上次目录</p>
<p>cd… 进入上一级目录</p>
<p>pwd查看当前目录所在位置</p>
</blockquote>
<h2 id="3-删除目录"><a class="header-anchor" href="#3-删除目录">¶</a>3.删除目录</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rmdir [目录]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>删除所有文件</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm -rf [目录]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>删除目录所有文件</p>
</blockquote>
<h2 id="4-复制目录"><a class="header-anchor" href="#4-复制目录">¶</a>4.复制目录</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp[选项][原文件目录][目标目录]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>选项：</p>
<p>-r复制目录</p>
<p>-p连文件属性一起复制</p>
<p>-a 相当于-pdr</p>
</blockquote>
<h2 id="5-剪切、改名"><a class="header-anchor" href="#5-剪切、改名">¶</a>5.剪切、改名</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv[原文件目录][目标文件目录]</span><br></pre></td></tr></table></figure>
<h2 id="6-常见目录作用"><a class="header-anchor" href="#6-常见目录作用">¶</a>6.常见目录作用</h2>
<blockquote>
<p>/ 根目录</p>
<p>/bin 命令保存目录</p>
<p>/boot  启动目录</p>
<p>/dev  设备文件命令</p>
<p>/etc  配置文件保存目录</p>
<p>/home  家目录</p>
<p>/lib  系统库保存命令</p>
<p>/mnt  系统挂载目录</p>
</blockquote>
<hr>
<h1>文件搜索命令</h1>
<h2 id="1-locate"><a class="header-anchor" href="#1-locate">¶</a>1.locate</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">locate [文件名]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在系统数据库中查找文件的</p>
</blockquote>
<blockquote>
<p>新建的文件，要执行updatedb操作之后才能搜到</p>
</blockquote>
<h2 id="2-命令搜索"><a class="header-anchor" href="#2-命令搜索">¶</a>2.命令搜索</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">whereis [选项] [命令名]</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">which [选项][命令名]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>选项：</p>
<p>-b 只查找可执行文件</p>
<p>-m 只查找帮助文件</p>
</blockquote>
<h2 id="3-文件搜索"><a class="header-anchor" href="#3-文件搜索">¶</a>3.文件搜索</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find [搜索范围][选项][条件]</span><br></pre></td></tr></table></figure>
<p>直接举例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find  /  -name install.log  </span><br><span class="line">在根目录下查找名为install.log文件</span><br><span class="line">find /root  -inname install.log</span><br><span class="line">忽略大小写查找文件</span><br><span class="line">find /var/log -mtime +10</span><br><span class="line"></span><br><span class="line">其中-mtime 文件修改时间</span><br><span class="line">-atime 文件访问时间</span><br><span class="line">-ctime 改变文件属性时间</span><br><span class="line"></span><br><span class="line">+10 10天前</span><br><span class="line">10  10天</span><br><span class="line">-10 10天内</span><br><span class="line">find /etc -size +20M</span><br><span class="line"></span><br><span class="line">查找文件大于20M的文件</span><br></pre></td></tr></table></figure>
<hr>
<h1>压缩与解压缩命令</h1>
<p>常见压缩格式：.zip  、 .gz 、 .bz2、<br>
.tar.gz  、 .tar.bz2</p>
<h2 id="1-zip格式"><a class="header-anchor" href="#1-zip格式">¶</a>1.zip格式</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//压缩文件</span><br><span class="line">zip [压缩文件名][原文件]</span><br><span class="line">//压缩目录</span><br><span class="line">zip -r  [压缩文件名][原文件]</span><br></pre></td></tr></table></figure>
<p>举例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">touch jp/cangls</span><br><span class="line"></span><br><span class="line">touch jp/longls</span><br><span class="line"></span><br><span class="line">zip -r jp.zip jp</span><br><span class="line"><span class="meta">#</span><span class="bash">解压：</span></span><br><span class="line">unzip [压缩文件名]</span><br></pre></td></tr></table></figure>
<h2 id="2-gz格式"><a class="header-anchor" href="#2-gz格式">¶</a>2.gz格式</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 压缩为gz格式，原文件不保留</span></span><br><span class="line">gzip [原文件]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">压缩.gz格式，原文件保留</span></span><br><span class="line"></span><br><span class="line">gzip -c 原文件 &gt; 压缩文件</span><br><span class="line"><span class="meta">#</span><span class="bash"> 压缩目录：</span></span><br><span class="line">gzip -r  目录</span><br></pre></td></tr></table></figure>
<p>解压：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">guzip [文件]</span><br><span class="line"></span><br><span class="line">guzip -r [目录]</span><br></pre></td></tr></table></figure>
<h2 id="3-tar格式"><a class="header-anchor" href="#3-tar格式">¶</a>3.tar格式</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 打包</span></span><br><span class="line">tar -cvf  打包文件名 原文件</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 解压</span></span><br><span class="line"></span><br><span class="line">tar -xvf jp.tar</span><br></pre></td></tr></table></figure>
<h2 id="4-tar-gz格式"><a class="header-anchor" href="#4-tar-gz格式">¶</a>4.tar.gz格式</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">打包</span></span><br><span class="line">tar -zcvf 压缩包名.tar.gz  原文件</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">解压</span></span><br><span class="line">tar -zxvf  压缩包名.tar.gz</span><br></pre></td></tr></table></figure>
<hr>
<h1>关机和重启</h1>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shutdown [选项][时间]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">选项：</span></span><br><span class="line">-c 取消前一个关机命令</span><br><span class="line">-h 关机</span><br><span class="line">-r 重启</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">init 6重启</span><br><span class="line"></span><br><span class="line">init 0关机</span><br><span class="line"></span><br><span class="line">logout退出登陆</span><br></pre></td></tr></table></figure>
<hr>
<h1>查看用户信息</h1>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">w</span><br><span class="line">who</span><br><span class="line">last</span><br><span class="line">lastlog</span><br></pre></td></tr></table></figure>
<hr>
<h1>shell基础</h1>
<h2 id="1-什么是shell"><a class="header-anchor" href="#1-什么是shell">¶</a>1.什么是shell</h2>
<p>shell是命令行解释器。</p>
<h2 id="2-echo-输出命令"><a class="header-anchor" href="#2-echo-输出命令">¶</a>2.echo 输出命令</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo[选项][输出内容]</span><br></pre></td></tr></table></figure>
<p>选项：</p>
<blockquote>
<p>-e:支持转义</p>
</blockquote>
<h2 id="3-创建一个脚本"><a class="header-anchor" href="#3-创建一个脚本">¶</a>3.创建一个脚本</h2>
<p><a href="http://xn--hello-ll6hz28e.sh" target="_blank" rel="noopener">创建hello.sh</a></p>
<blockquote>
<p>vim <a href="http://hello.sh" target="_blank" rel="noopener">hello.sh</a><br>
进入编辑：</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> the first program</span></span><br><span class="line"></span><br><span class="line">echo "hello world!"</span><br></pre></td></tr></table></figure>
<p>执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod 755 hello.sh</span><br><span class="line"></span><br><span class="line">./hello.sh</span><br></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bash hello.sh</span><br></pre></td></tr></table></figure>
<hr>
<h1>历史命令</h1>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">history 查看历史命令</span><br><span class="line">history [选项][历史保存文件]</span><br><span class="line">选项：</span><br><span class="line">-c清空历史</span><br><span class="line">-w把缓存中的历史写入历史命令保存文件</span><br></pre></td></tr></table></figure>
<hr>
<h1>输出重定向</h1>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">命令&gt;文件   以覆盖的方式，把正确的命令输出到指定文件</span><br><span class="line">命令&gt;&gt;文件  以追加的方式，把正确的命令输出到指定文件、</span><br><span class="line">错误命令 2&gt; 文件  以覆盖的方式把错误的命令覆盖到指定文件</span><br><span class="line">错误命令 2&gt;&gt; 文件  以追击的方式把错误的命令覆盖到指定文件</span><br><span class="line"></span><br><span class="line"> 命令&gt;&gt;文件 2&gt;&amp;1  同时追加正确命令和错误命令到 指定文件</span><br><span class="line">命令 &gt;&gt;文件1 2&gt;&gt;文件2   把正确的命令输出到文件1错误的文件2</span><br></pre></td></tr></table></figure>
<p>举个例子:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">/bin/bash</span></span><br><span class="line">while command</span><br><span class="line">do</span><br><span class="line">curl -d "userid=123343,action=getuserinfo" https://app.testasss.com.cn/ &gt;test.txt</span><br><span class="line">time=$(date)</span><br><span class="line">cat=$(cat test.txt |cut -d \: -f 3|cut -d \" -f 2)</span><br><span class="line">echo "$time $cat" &gt;&gt;test.log</span><br><span class="line">sleep 15s</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<hr>
<h1>网络相关</h1>
<h2 id="1-ifconfig查看ip"><a class="header-anchor" href="#1-ifconfig查看ip">¶</a>1.ifconfig查看ip</h2>
<p>举个例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">ifconfig&gt;</span><span class="bash">&gt; ip.log</span></span><br><span class="line">cat ip.log</span><br></pre></td></tr></table></figure>
<h2 id="2-查看网络状态"><a class="header-anchor" href="#2-查看网络状态">¶</a>2.查看网络状态</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat [选项]</span><br></pre></td></tr></table></figure>
<p>选项：</p>
<blockquote>
<p>-t: 列出tcp 协议端口<br>
-u: 列出upd协议端口<br>
-n  ip地址个端口号<br>
-l 列出监听状态的<br>
-a 所有</p>
</blockquote>
<h2 id="3-查看路由列表"><a class="header-anchor" href="#3-查看路由列表">¶</a>3.查看路由列表</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -rn</span><br><span class="line">或者</span><br><span class="line">route -n</span><br></pre></td></tr></table></figure>
<h2 id="4-查看某域名与自己的电脑的网络状态"><a class="header-anchor" href="#4-查看某域名与自己的电脑的网络状态">¶</a>4.查看某域名与自己的电脑的网络状态</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ping www.baodu.com</span><br></pre></td></tr></table></figure>
<hr>
<h1>vi编辑器</h1>
<p>vi的升级版是vim</p>
<h2 id="1-vim的操作模式"><a class="header-anchor" href="#1-vim的操作模式">¶</a>1.vim的操作模式</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">commond mode  命令模式</span><br><span class="line">inser tmode  编辑模式</span><br><span class="line">lastline mode  底行模式</span><br></pre></td></tr></table></figure>
<h2 id="2-模式切换"><a class="header-anchor" href="#2-模式切换">¶</a>2.模式切换</h2>
<p>i  进入编辑模式<br>
esc  进入命令行模式</p>
<h2 id="3-命令模式"><a class="header-anchor" href="#3-命令模式">¶</a>3.命令模式</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim [文件]         进入文件或者创建文件（文件不存在的情况下）</span><br><span class="line">vim + [文件名]   进入文件尾部</span><br><span class="line">vim +/[字符串] [文件名]  光标定位到文件第一次出现该字符串的位置</span><br></pre></td></tr></table></figure>
<h2 id="4-底行模式"><a class="header-anchor" href="#4-底行模式">¶</a>4.底行模式</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">:w  保存</span><br><span class="line">:q 退出</span><br><span class="line">:! 强制</span><br><span class="line">:15  定位的第15行</span><br><span class="line">/[字符串]  光标位置向后搜索该字符串</span><br><span class="line">?[字符串]  光标位置向前搜索该字符串</span><br><span class="line">dd  删除光标所在行</span><br><span class="line"></span><br><span class="line">ctr+f   向下翻页</span><br><span class="line">ctr+b  向上翻页</span><br></pre></td></tr></table></figure>
<hr>
<h1>常用操作快捷键</h1>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ctr+c  终止当前命令</span><br><span class="line">ctr+l 清屏  相当于 clear</span><br><span class="line">ctr+a  光标移到行首</span><br><span class="line">ctr+e  光标移到行尾</span><br><span class="line">ctr+u  把光标所在位置删除到行首</span><br><span class="line">ctr+z  把命令放入后台</span><br><span class="line">ctr+r  在历史命令中搜索</span><br></pre></td></tr></table></figure>
<hr>
<h1>其他</h1>
<p>常用工具：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Vmware  虚拟机</span><br><span class="line">centos.iso   centos系统镜像 ,绝大多数服务器是这个系统</span><br><span class="line">SecureCRT  远程登陆工具</span><br><span class="line">Xshell 远程登陆工具</span><br><span class="line">winscp copy文件工具</span><br></pre></td></tr></table></figure>
<p>原文链接：<a href="https://www.jianshu.com/p/0718b3abedcf" target="_blank" rel="noopener">https://www.jianshu.com/p/0718b3abedcf</a></p>
]]></content>
      <categories>
        <category>Linux指令</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>资料整理</tag>
      </tags>
  </entry>
</search>
